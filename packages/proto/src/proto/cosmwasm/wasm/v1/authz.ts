// @ts-nocheck
/* eslint-disable */
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: cosmwasm/wasm/v1/authz.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../../gogoproto/gogo";
import * as dependency_2 from "./../../../cosmos_proto/cosmos";
import * as dependency_3 from "./../../../cosmos/base/v1beta1/coin";
import * as dependency_4 from "./../../../google/protobuf/any";
import * as pb_1 from "google-protobuf";
export namespace cosmwasm.wasm.v1 {
    export class ContractExecutionAuthorization extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            grants?: ContractGrant[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("grants" in data && data.grants != undefined) {
                    this.grants = data.grants;
                }
            }
        }
        get grants() {
            return pb_1.Message.getRepeatedWrapperField(this, ContractGrant, 1) as ContractGrant[];
        }
        set grants(value: ContractGrant[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            grants?: ReturnType<typeof ContractGrant.prototype.toObject>[];
        }): ContractExecutionAuthorization {
            const message = new ContractExecutionAuthorization({});
            if (data.grants != null) {
                message.grants = data.grants.map(item => ContractGrant.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                grants?: ReturnType<typeof ContractGrant.prototype.toObject>[];
            } = {};
            if (this.grants != null) {
                data.grants = this.grants.map((item: ContractGrant) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.grants.length)
                writer.writeRepeatedMessage(1, this.grants, (item: ContractGrant) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ContractExecutionAuthorization {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ContractExecutionAuthorization();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.grants, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ContractGrant.deserialize(reader), ContractGrant));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ContractExecutionAuthorization {
            return ContractExecutionAuthorization.deserialize(bytes);
        }
    }
    export class ContractMigrationAuthorization extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            grants?: ContractGrant[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("grants" in data && data.grants != undefined) {
                    this.grants = data.grants;
                }
            }
        }
        get grants() {
            return pb_1.Message.getRepeatedWrapperField(this, ContractGrant, 1) as ContractGrant[];
        }
        set grants(value: ContractGrant[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            grants?: ReturnType<typeof ContractGrant.prototype.toObject>[];
        }): ContractMigrationAuthorization {
            const message = new ContractMigrationAuthorization({});
            if (data.grants != null) {
                message.grants = data.grants.map(item => ContractGrant.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                grants?: ReturnType<typeof ContractGrant.prototype.toObject>[];
            } = {};
            if (this.grants != null) {
                data.grants = this.grants.map((item: ContractGrant) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.grants.length)
                writer.writeRepeatedMessage(1, this.grants, (item: ContractGrant) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ContractMigrationAuthorization {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ContractMigrationAuthorization();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.grants, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ContractGrant.deserialize(reader), ContractGrant));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ContractMigrationAuthorization {
            return ContractMigrationAuthorization.deserialize(bytes);
        }
    }
    export class ContractGrant extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            contract?: string;
            limit?: dependency_4.google.protobuf.Any;
            filter?: dependency_4.google.protobuf.Any;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("contract" in data && data.contract != undefined) {
                    this.contract = data.contract;
                }
                if ("limit" in data && data.limit != undefined) {
                    this.limit = data.limit;
                }
                if ("filter" in data && data.filter != undefined) {
                    this.filter = data.filter;
                }
            }
        }
        get contract() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set contract(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get limit() {
            return pb_1.Message.getWrapperField(this, dependency_4.google.protobuf.Any, 2) as dependency_4.google.protobuf.Any;
        }
        set limit(value: dependency_4.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_limit() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get filter() {
            return pb_1.Message.getWrapperField(this, dependency_4.google.protobuf.Any, 3) as dependency_4.google.protobuf.Any;
        }
        set filter(value: dependency_4.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_filter() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            contract?: string;
            limit?: ReturnType<typeof dependency_4.google.protobuf.Any.prototype.toObject>;
            filter?: ReturnType<typeof dependency_4.google.protobuf.Any.prototype.toObject>;
        }): ContractGrant {
            const message = new ContractGrant({});
            if (data.contract != null) {
                message.contract = data.contract;
            }
            if (data.limit != null) {
                message.limit = dependency_4.google.protobuf.Any.fromObject(data.limit);
            }
            if (data.filter != null) {
                message.filter = dependency_4.google.protobuf.Any.fromObject(data.filter);
            }
            return message;
        }
        toObject() {
            const data: {
                contract?: string;
                limit?: ReturnType<typeof dependency_4.google.protobuf.Any.prototype.toObject>;
                filter?: ReturnType<typeof dependency_4.google.protobuf.Any.prototype.toObject>;
            } = {};
            if (this.contract != null) {
                data.contract = this.contract;
            }
            if (this.limit != null) {
                data.limit = this.limit.toObject();
            }
            if (this.filter != null) {
                data.filter = this.filter.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.contract.length)
                writer.writeString(1, this.contract);
            if (this.has_limit)
                writer.writeMessage(2, this.limit, () => this.limit.serialize(writer));
            if (this.has_filter)
                writer.writeMessage(3, this.filter, () => this.filter.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ContractGrant {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ContractGrant();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.contract = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.limit, () => message.limit = dependency_4.google.protobuf.Any.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.filter, () => message.filter = dependency_4.google.protobuf.Any.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ContractGrant {
            return ContractGrant.deserialize(bytes);
        }
    }
    export class MaxCallsLimit extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            remaining?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("remaining" in data && data.remaining != undefined) {
                    this.remaining = data.remaining;
                }
            }
        }
        get remaining() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set remaining(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            remaining?: number;
        }): MaxCallsLimit {
            const message = new MaxCallsLimit({});
            if (data.remaining != null) {
                message.remaining = data.remaining;
            }
            return message;
        }
        toObject() {
            const data: {
                remaining?: number;
            } = {};
            if (this.remaining != null) {
                data.remaining = this.remaining;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.remaining != 0)
                writer.writeUint64(1, this.remaining);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MaxCallsLimit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MaxCallsLimit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.remaining = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MaxCallsLimit {
            return MaxCallsLimit.deserialize(bytes);
        }
    }
    export class MaxFundsLimit extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            amounts?: dependency_3.cosmos.base.v1beta1.Coin[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amounts" in data && data.amounts != undefined) {
                    this.amounts = data.amounts;
                }
            }
        }
        get amounts() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_3.cosmos.base.v1beta1.Coin, 1) as dependency_3.cosmos.base.v1beta1.Coin[];
        }
        set amounts(value: dependency_3.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            amounts?: ReturnType<typeof dependency_3.cosmos.base.v1beta1.Coin.prototype.toObject>[];
        }): MaxFundsLimit {
            const message = new MaxFundsLimit({});
            if (data.amounts != null) {
                message.amounts = data.amounts.map(item => dependency_3.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                amounts?: ReturnType<typeof dependency_3.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            } = {};
            if (this.amounts != null) {
                data.amounts = this.amounts.map((item: dependency_3.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amounts.length)
                writer.writeRepeatedMessage(1, this.amounts, (item: dependency_3.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MaxFundsLimit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MaxFundsLimit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.amounts, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_3.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_3.cosmos.base.v1beta1.Coin));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MaxFundsLimit {
            return MaxFundsLimit.deserialize(bytes);
        }
    }
    export class CombinedLimit extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            calls_remaining?: number;
            amounts?: dependency_3.cosmos.base.v1beta1.Coin[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("calls_remaining" in data && data.calls_remaining != undefined) {
                    this.calls_remaining = data.calls_remaining;
                }
                if ("amounts" in data && data.amounts != undefined) {
                    this.amounts = data.amounts;
                }
            }
        }
        get calls_remaining() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set calls_remaining(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get amounts() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_3.cosmos.base.v1beta1.Coin, 2) as dependency_3.cosmos.base.v1beta1.Coin[];
        }
        set amounts(value: dependency_3.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            calls_remaining?: number;
            amounts?: ReturnType<typeof dependency_3.cosmos.base.v1beta1.Coin.prototype.toObject>[];
        }): CombinedLimit {
            const message = new CombinedLimit({});
            if (data.calls_remaining != null) {
                message.calls_remaining = data.calls_remaining;
            }
            if (data.amounts != null) {
                message.amounts = data.amounts.map(item => dependency_3.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                calls_remaining?: number;
                amounts?: ReturnType<typeof dependency_3.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            } = {};
            if (this.calls_remaining != null) {
                data.calls_remaining = this.calls_remaining;
            }
            if (this.amounts != null) {
                data.amounts = this.amounts.map((item: dependency_3.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.calls_remaining != 0)
                writer.writeUint64(1, this.calls_remaining);
            if (this.amounts.length)
                writer.writeRepeatedMessage(2, this.amounts, (item: dependency_3.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CombinedLimit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CombinedLimit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.calls_remaining = reader.readUint64();
                        break;
                    case 2:
                        reader.readMessage(message.amounts, () => pb_1.Message.addToRepeatedWrapperField(message, 2, dependency_3.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_3.cosmos.base.v1beta1.Coin));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CombinedLimit {
            return CombinedLimit.deserialize(bytes);
        }
    }
    export class AllowAllMessagesFilter extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): AllowAllMessagesFilter {
            const message = new AllowAllMessagesFilter({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AllowAllMessagesFilter {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AllowAllMessagesFilter();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AllowAllMessagesFilter {
            return AllowAllMessagesFilter.deserialize(bytes);
        }
    }
    export class AcceptedMessageKeysFilter extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            keys?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("keys" in data && data.keys != undefined) {
                    this.keys = data.keys;
                }
            }
        }
        get keys() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set keys(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            keys?: string[];
        }): AcceptedMessageKeysFilter {
            const message = new AcceptedMessageKeysFilter({});
            if (data.keys != null) {
                message.keys = data.keys;
            }
            return message;
        }
        toObject() {
            const data: {
                keys?: string[];
            } = {};
            if (this.keys != null) {
                data.keys = this.keys;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.keys.length)
                writer.writeRepeatedString(1, this.keys);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AcceptedMessageKeysFilter {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AcceptedMessageKeysFilter();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AcceptedMessageKeysFilter {
            return AcceptedMessageKeysFilter.deserialize(bytes);
        }
    }
    export class AcceptedMessagesFilter extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            messages?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("messages" in data && data.messages != undefined) {
                    this.messages = data.messages;
                }
            }
        }
        get messages() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as Uint8Array[];
        }
        set messages(value: Uint8Array[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            messages?: Uint8Array[];
        }): AcceptedMessagesFilter {
            const message = new AcceptedMessagesFilter({});
            if (data.messages != null) {
                message.messages = data.messages;
            }
            return message;
        }
        toObject() {
            const data: {
                messages?: Uint8Array[];
            } = {};
            if (this.messages != null) {
                data.messages = this.messages;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.messages.length)
                writer.writeRepeatedBytes(1, this.messages);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AcceptedMessagesFilter {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AcceptedMessagesFilter();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AcceptedMessagesFilter {
            return AcceptedMessagesFilter.deserialize(bytes);
        }
    }
}
