// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file badges/transfers.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Balance, MustOwnBadges, UintRange } from "./balances_pb.js";
import { UserPermissions } from "./permissions_pb.js";

/**
 *
 * UserBalanceStore is the store for the user balances for a collection.
 *
 * It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
 * as well as the permissions for updating the approved incoming/outgoing transfers.
 *
 * Upon initialization, all fields (minus the balances) are set to the defaults specified by the collection.
 *
 * The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
 * If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)
 * and autoApproveSelfInitiatedOutgoingTransfers is set to true.
 *
 * The incoming transfers can be used to allow / disallow transfers which are sent to this user.
 * If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)
 * and autoApproveSelfInitiatedIncomingTransfers is set to true.
 *
 * Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
 * the user approved transfers. 
 *
 * The permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.
 *
 * @generated from message badges.UserBalanceStore
 */
export class UserBalanceStore extends Message<UserBalanceStore> {
  /**
   * The list of balances associated with this user.
   *
   * @generated from field: repeated badges.Balance balances = 1;
   */
  balances: Balance[] = [];

  /**
   * The list of approved outgoing transfers for this user.
   *
   * @generated from field: repeated badges.UserOutgoingApproval outgoingApprovals = 2;
   */
  outgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * The list of approved incoming transfers for this user.
   *
   * @generated from field: repeated badges.UserIncomingApproval incomingApprovals = 3;
   */
  incomingApprovals: UserIncomingApproval[] = [];

  /**
   * Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).
   *
   * @generated from field: bool autoApproveSelfInitiatedOutgoingTransfers = 4;
   */
  autoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).
   *
   * @generated from field: bool autoApproveSelfInitiatedIncomingTransfers = 5;
   */
  autoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * The permissions for this user's actions and transfers.
   *
   * @generated from field: badges.UserPermissions userPermissions = 6;
   */
  userPermissions?: UserPermissions;

  constructor(data?: PartialMessage<UserBalanceStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserBalanceStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 2, name: "outgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 3, name: "incomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 4, name: "autoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "autoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "userPermissions", kind: "message", T: UserPermissions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserBalanceStore {
    return new UserBalanceStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserBalanceStore {
    return new UserBalanceStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserBalanceStore {
    return new UserBalanceStore().fromJsonString(jsonString, options);
  }

  static equals(a: UserBalanceStore | PlainMessage<UserBalanceStore> | undefined, b: UserBalanceStore | PlainMessage<UserBalanceStore> | undefined): boolean {
    return proto3.util.equals(UserBalanceStore, a, b);
  }
}

/**
 *
 * Challenges define a rule for the approval in the form of a Merkle challenge.
 *
 * A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
 * then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.
 *
 * IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.
 *
 * IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
 * If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
 * We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
 *
 * @generated from message badges.MerkleChallenge
 */
export class MerkleChallenge extends Message<MerkleChallenge> {
  /**
   * The root hash of the Merkle tree to which the Merkle path must lead for verification.
   *
   * @generated from field: string root = 1;
   */
  root = "";

  /**
   * The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
   *
   * @generated from field: string expectedProofLength = 2;
   */
  expectedProofLength = "";

  /**
   * If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid Cosmos addresses.
   *
   * @generated from field: bool useCreatorAddressAsLeaf = 3;
   */
  useCreatorAddressAsLeaf = false;

  /**
   * The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
   *
   * @generated from field: string maxUsesPerLeaf = 4;
   */
  maxUsesPerLeaf = "";

  /**
   * The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
   *
   * @generated from field: string uri = 6;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this Merkle challenge.
   *
   * @generated from field: string customData = 7;
   */
  customData = "";

  constructor(data?: PartialMessage<MerkleChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expectedProofLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "useCreatorAddressAsLeaf", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "maxUsesPerLeaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined, b: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined): boolean {
    return proto3.util.equals(MerkleChallenge, a, b);
  }
}

/**
 * UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.
 *
 * @generated from message badges.UserOutgoingApproval
 */
export class UserOutgoingApproval extends Message<UserOutgoingApproval> {
  /**
   * The mapping ID for the recipient of the transfer.
   *
   * @generated from field: string toMappingId = 1;
   */
  toMappingId = "";

  /**
   * The mapping ID for the user who initiated the transfer.
   *
   * @generated from field: string initiatedByMappingId = 2;
   */
  initiatedByMappingId = "";

  /**
   * The allowed range of transfer times for approval.
   *
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * The allowed range of badge IDs for approval.
   *
   * @generated from field: repeated badges.UintRange badgeIds = 4;
   */
  badgeIds: UintRange[] = [];

  /**
   * The allowed range of ownership times for approval.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * The ID of the amount tracker associated with this approval.
   * We use this ID to track the number of transfers and amounts transferred.
   *
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * The ID of the challenge tracker associated with this approval.
   * We use this ID to track the number of uses per leaf for the Merkle challenge.
   *
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * The URI associated with this approval, optionally providing metadata about the approval.
   *
   * @generated from field: string uri = 8;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this approval.
   *
   * @generated from field: string customData = 9;
   */
  customData = "";

  /**
   * The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
   *
   * @generated from field: string approvalId = 10;
   */
  approvalId = "";

  /**
   * The criteria that must be met for this approval to be considered.
   *
   * @generated from field: badges.OutgoingApprovalCriteria approvalCriteria = 11;
   */
  approvalCriteria?: OutgoingApprovalCriteria;

  constructor(data?: PartialMessage<UserOutgoingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserOutgoingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "toMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "approvalCriteria", kind: "message", T: OutgoingApprovalCriteria },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserOutgoingApproval {
    return new UserOutgoingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserOutgoingApproval {
    return new UserOutgoingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserOutgoingApproval {
    return new UserOutgoingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: UserOutgoingApproval | PlainMessage<UserOutgoingApproval> | undefined, b: UserOutgoingApproval | PlainMessage<UserOutgoingApproval> | undefined): boolean {
    return proto3.util.equals(UserOutgoingApproval, a, b);
  }
}

/**
 * UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.
 *
 * @generated from message badges.UserIncomingApproval
 */
export class UserIncomingApproval extends Message<UserIncomingApproval> {
  /**
   * The mapping ID for the sender of the transfer.
   *
   * @generated from field: string fromMappingId = 1;
   */
  fromMappingId = "";

  /**
   * The mapping ID for the user who initiated the transfer.
   *
   * @generated from field: string initiatedByMappingId = 2;
   */
  initiatedByMappingId = "";

  /**
   * The allowed range of transfer times for approval.
   *
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * The allowed range of badge IDs for approval.
   *
   * @generated from field: repeated badges.UintRange badgeIds = 4;
   */
  badgeIds: UintRange[] = [];

  /**
   * The allowed range of ownership times for approval.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * The ID of the amount tracker associated with this approval.
   * We use this ID to track the number of transfers and amounts transferred.
   *
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * The ID of the challenge tracker associated with this approval.
   * We use this ID to track the number of uses per leaf for the Merkle challenge.
   *
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * The URI associated with this approval, optionally providing metadata about the approval.
   *
   * @generated from field: string uri = 8;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this approval.
   *
   * @generated from field: string customData = 9;
   */
  customData = "";

  /**
   * The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
   *
   * @generated from field: string approvalId = 10;
   */
  approvalId = "";

  /**
   * The criteria that must be met for this approval to be considered.
   *
   * @generated from field: badges.IncomingApprovalCriteria approvalCriteria = 11;
   */
  approvalCriteria?: IncomingApprovalCriteria;

  constructor(data?: PartialMessage<UserIncomingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserIncomingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "approvalCriteria", kind: "message", T: IncomingApprovalCriteria },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserIncomingApproval {
    return new UserIncomingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserIncomingApproval {
    return new UserIncomingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserIncomingApproval {
    return new UserIncomingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: UserIncomingApproval | PlainMessage<UserIncomingApproval> | undefined, b: UserIncomingApproval | PlainMessage<UserIncomingApproval> | undefined): boolean {
    return proto3.util.equals(UserIncomingApproval, a, b);
  }
}

/**
 * ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set. 
 *
 * @generated from message badges.ManualBalances
 */
export class ManualBalances extends Message<ManualBalances> {
  /**
   * @generated from field: repeated badges.Balance balances = 1;
   */
  balances: Balance[] = [];

  constructor(data?: PartialMessage<ManualBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ManualBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balances", kind: "message", T: Balance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ManualBalances {
    return new ManualBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ManualBalances {
    return new ManualBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ManualBalances {
    return new ManualBalances().fromJsonString(jsonString, options);
  }

  static equals(a: ManualBalances | PlainMessage<ManualBalances> | undefined, b: ManualBalances | PlainMessage<ManualBalances> | undefined): boolean {
    return proto3.util.equals(ManualBalances, a, b);
  }
}

/**
 * IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.
 *
 * @generated from message badges.IncrementedBalances
 */
export class IncrementedBalances extends Message<IncrementedBalances> {
  /**
   * @generated from field: repeated badges.Balance startBalances = 1;
   */
  startBalances: Balance[] = [];

  /**
   * The amount by which to increment badge IDs.
   *
   * @generated from field: string incrementBadgeIdsBy = 2;
   */
  incrementBadgeIdsBy = "";

  /**
   * The amount by which to increment ownership times.
   *
   * @generated from field: string incrementOwnershipTimesBy = 3;
   */
  incrementOwnershipTimesBy = "";

  constructor(data?: PartialMessage<IncrementedBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.IncrementedBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "startBalances", kind: "message", T: Balance, repeated: true },
    { no: 2, name: "incrementBadgeIdsBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "incrementOwnershipTimesBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromJsonString(jsonString, options);
  }

  static equals(a: IncrementedBalances | PlainMessage<IncrementedBalances> | undefined, b: IncrementedBalances | PlainMessage<IncrementedBalances> | undefined): boolean {
    return proto3.util.equals(IncrementedBalances, a, b);
  }
}

/**
 * PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.
 *
 * @generated from message badges.PredeterminedOrderCalculationMethod
 */
export class PredeterminedOrderCalculationMethod extends Message<PredeterminedOrderCalculationMethod> {
  /**
   * Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.
   *
   * @generated from field: bool useOverallNumTransfers = 1;
   */
  useOverallNumTransfers = false;

  /**
   * Use the number of transfers per "to" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.
   *
   * @generated from field: bool usePerToAddressNumTransfers = 2;
   */
  usePerToAddressNumTransfers = false;

  /**
   * Use the number of transfers per "from" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.
   *
   * @generated from field: bool usePerFromAddressNumTransfers = 3;
   */
  usePerFromAddressNumTransfers = false;

  /**
   * Use the number of transfers per "initiated by" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.
   *
   * @generated from field: bool usePerInitiatedByAddressNumTransfers = 4;
   */
  usePerInitiatedByAddressNumTransfers = false;

  /**
   * Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.
   *
   * @generated from field: bool useMerkleChallengeLeafIndex = 5;
   */
  useMerkleChallengeLeafIndex = false;

  constructor(data?: PartialMessage<PredeterminedOrderCalculationMethod>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PredeterminedOrderCalculationMethod";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "useOverallNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "usePerToAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "usePerFromAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "usePerInitiatedByAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "useMerkleChallengeLeafIndex", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromJsonString(jsonString, options);
  }

  static equals(a: PredeterminedOrderCalculationMethod | PlainMessage<PredeterminedOrderCalculationMethod> | undefined, b: PredeterminedOrderCalculationMethod | PlainMessage<PredeterminedOrderCalculationMethod> | undefined): boolean {
    return proto3.util.equals(PredeterminedOrderCalculationMethod, a, b);
  }
}

/**
 * PredeterminedBalances represents balances with predetermined order calculation.
 *
 * @generated from message badges.PredeterminedBalances
 */
export class PredeterminedBalances extends Message<PredeterminedBalances> {
  /**
   * Manual balances that can be entered. If this is nil, then we use the incremented balances.
   *
   * @generated from field: repeated badges.ManualBalances manualBalances = 1;
   */
  manualBalances: ManualBalances[] = [];

  /**
   * Balances that have a starting amount and increment. If this is nil, then we use the manual balances.
   *
   * @generated from field: badges.IncrementedBalances incrementedBalances = 2;
   */
  incrementedBalances?: IncrementedBalances;

  /**
   * The method to calculate the order of predetermined balances.
   *
   * @generated from field: badges.PredeterminedOrderCalculationMethod orderCalculationMethod = 3;
   */
  orderCalculationMethod?: PredeterminedOrderCalculationMethod;

  constructor(data?: PartialMessage<PredeterminedBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PredeterminedBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "manualBalances", kind: "message", T: ManualBalances, repeated: true },
    { no: 2, name: "incrementedBalances", kind: "message", T: IncrementedBalances },
    { no: 3, name: "orderCalculationMethod", kind: "message", T: PredeterminedOrderCalculationMethod },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromJsonString(jsonString, options);
  }

  static equals(a: PredeterminedBalances | PlainMessage<PredeterminedBalances> | undefined, b: PredeterminedBalances | PlainMessage<PredeterminedBalances> | undefined): boolean {
    return proto3.util.equals(PredeterminedBalances, a, b);
  }
}

/**
 * ApprovalAmounts defines approval amounts per unique "from," "to," and/or "initiated by" address.
 * If any of these are nil or "0", we assume unlimited approvals.
 * If they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times 
 * must not exceed the corresponding value.
 *
 * @generated from message badges.ApprovalAmounts
 */
export class ApprovalAmounts extends Message<ApprovalAmounts> {
  /**
   * Overall approval amount.
   *
   * @generated from field: string overallApprovalAmount = 1;
   */
  overallApprovalAmount = "";

  /**
   * Approval amount per "to" address.
   *
   * @generated from field: string perToAddressApprovalAmount = 2;
   */
  perToAddressApprovalAmount = "";

  /**
   * Approval amount per "from" address.
   *
   * @generated from field: string perFromAddressApprovalAmount = 3;
   */
  perFromAddressApprovalAmount = "";

  /**
   * Approval amount per "initiated by" address.
   *
   * @generated from field: string perInitiatedByAddressApprovalAmount = 4;
   */
  perInitiatedByAddressApprovalAmount = "";

  constructor(data?: PartialMessage<ApprovalAmounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalAmounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overallApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "perToAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "perFromAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "perInitiatedByAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalAmounts | PlainMessage<ApprovalAmounts> | undefined, b: ApprovalAmounts | PlainMessage<ApprovalAmounts> | undefined): boolean {
    return proto3.util.equals(ApprovalAmounts, a, b);
  }
}

/**
 * MaxNumTransfers defines the maximum number of transfers per unique "from," "to," and/or "initiated by" address.
 * If any of these are nil or "0", we assume unlimited approvals.
 * If they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times
 * must not exceed the corresponding value.
 *
 * @generated from message badges.MaxNumTransfers
 */
export class MaxNumTransfers extends Message<MaxNumTransfers> {
  /**
   * Overall maximum number of transfers.
   *
   * @generated from field: string overallMaxNumTransfers = 1;
   */
  overallMaxNumTransfers = "";

  /**
   * Maximum number of transfers per "to" address.
   *
   * @generated from field: string perToAddressMaxNumTransfers = 2;
   */
  perToAddressMaxNumTransfers = "";

  /**
   * Maximum number of transfers per "from" address.
   *
   * @generated from field: string perFromAddressMaxNumTransfers = 3;
   */
  perFromAddressMaxNumTransfers = "";

  /**
   * Maximum number of transfers per "initiated by" address.
   *
   * @generated from field: string perInitiatedByAddressMaxNumTransfers = 4;
   */
  perInitiatedByAddressMaxNumTransfers = "";

  constructor(data?: PartialMessage<MaxNumTransfers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MaxNumTransfers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overallMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "perToAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "perFromAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "perInitiatedByAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromJsonString(jsonString, options);
  }

  static equals(a: MaxNumTransfers | PlainMessage<MaxNumTransfers> | undefined, b: MaxNumTransfers | PlainMessage<MaxNumTransfers> | undefined): boolean {
    return proto3.util.equals(MaxNumTransfers, a, b);
  }
}

/**
 * ApprovalsTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.
 *
 * @generated from message badges.ApprovalsTracker
 */
export class ApprovalsTracker extends Message<ApprovalsTracker> {
  /**
   * The number of transfers that have been processed.
   *
   * @generated from field: string numTransfers = 1;
   */
  numTransfers = "";

  /**
   * Cumulative balances associated with the transfers that have been processed.
   *
   * @generated from field: repeated badges.Balance amounts = 2;
   */
  amounts: Balance[] = [];

  constructor(data?: PartialMessage<ApprovalsTracker>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalsTracker";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "numTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amounts", kind: "message", T: Balance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalsTracker {
    return new ApprovalsTracker().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalsTracker {
    return new ApprovalsTracker().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalsTracker {
    return new ApprovalsTracker().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalsTracker | PlainMessage<ApprovalsTracker> | undefined, b: ApprovalsTracker | PlainMessage<ApprovalsTracker> | undefined): boolean {
    return proto3.util.equals(ApprovalsTracker, a, b);
  }
}

/**
 * ApprovalCriteria defines the criteria for approving transfers.
 *
 * @generated from message badges.ApprovalCriteria
 */
export class ApprovalCriteria extends Message<ApprovalCriteria> {
  /**
   * List of badges that the user must own for approval.
   *
   * @generated from field: repeated badges.MustOwnBadges mustOwnBadges = 1;
   */
  mustOwnBadges: MustOwnBadges[] = [];

  /**
   * Merkle challenge that must be satisfied for approval.
   *
   * @generated from field: badges.MerkleChallenge merkleChallenge = 2;
   */
  merkleChallenge?: MerkleChallenge;

  /**
   * Predetermined balances for eeach approval.
   *
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 3;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * Threshold limit of amounts that can be transferred using this approval.
   *
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 4;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * Maximum number of transfers that can be processed using this approval.
   *
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 5;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * Require the "to" address to be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireToEqualsInitiatedBy = 9;
   */
  requireToEqualsInitiatedBy = false;

  /**
   * Require the "from" address to be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireFromEqualsInitiatedBy = 10;
   */
  requireFromEqualsInitiatedBy = false;

  /**
   * Require the "to" address to not be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireToDoesNotEqualInitiatedBy = 11;
   */
  requireToDoesNotEqualInitiatedBy = false;

  /**
   * Require the "from" address to not be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireFromDoesNotEqualInitiatedBy = 12;
   */
  requireFromDoesNotEqualInitiatedBy = false;

  /**
   * Overrides the user's outgoing approvals for approval.
   *
   * @generated from field: bool overridesFromOutgoingApprovals = 13;
   */
  overridesFromOutgoingApprovals = false;

  /**
   * Overrides the user's incoming approvals for approval.
   *
   * @generated from field: bool overridesToIncomingApprovals = 14;
   */
  overridesToIncomingApprovals = false;

  constructor(data?: PartialMessage<ApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mustOwnBadges", kind: "message", T: MustOwnBadges, repeated: true },
    { no: 2, name: "merkleChallenge", kind: "message", T: MerkleChallenge },
    { no: 3, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 4, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 5, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 9, name: "requireToEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "requireFromEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "requireToDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "requireFromDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "overridesFromOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "overridesToIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalCriteria | PlainMessage<ApprovalCriteria> | undefined, b: ApprovalCriteria | PlainMessage<ApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(ApprovalCriteria, a, b);
  }
}

/**
 * OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
 *
 * @generated from message badges.OutgoingApprovalCriteria
 */
export class OutgoingApprovalCriteria extends Message<OutgoingApprovalCriteria> {
  /**
   * List of badges that the user must own for approval.
   *
   * @generated from field: repeated badges.MustOwnBadges mustOwnBadges = 1;
   */
  mustOwnBadges: MustOwnBadges[] = [];

  /**
   * Merkle challenge that must be satisfied for approval.
   *
   * @generated from field: badges.MerkleChallenge merkleChallenge = 2;
   */
  merkleChallenge?: MerkleChallenge;

  /**
   * Predetermined balances for eeach approval.
   *
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 3;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * Threshold limit of amounts that can be transferred using this approval.
   *
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 4;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * Maximum number of transfers that can be processed using this approval.
   *
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 5;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * Require the "to" address to be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireToEqualsInitiatedBy = 9;
   */
  requireToEqualsInitiatedBy = false;

  /**
   * Require the "to" address to not be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireToDoesNotEqualInitiatedBy = 11;
   */
  requireToDoesNotEqualInitiatedBy = false;

  constructor(data?: PartialMessage<OutgoingApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.OutgoingApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mustOwnBadges", kind: "message", T: MustOwnBadges, repeated: true },
    { no: 2, name: "merkleChallenge", kind: "message", T: MerkleChallenge },
    { no: 3, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 4, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 5, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 9, name: "requireToEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "requireToDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: OutgoingApprovalCriteria | PlainMessage<OutgoingApprovalCriteria> | undefined, b: OutgoingApprovalCriteria | PlainMessage<OutgoingApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(OutgoingApprovalCriteria, a, b);
  }
}

/**
 * IncomingApprovalCriteria defines the criteria for approving incoming transfers.
 *
 * @generated from message badges.IncomingApprovalCriteria
 */
export class IncomingApprovalCriteria extends Message<IncomingApprovalCriteria> {
  /**
   * List of badges that the user must own for approval.
   *
   * @generated from field: repeated badges.MustOwnBadges mustOwnBadges = 1;
   */
  mustOwnBadges: MustOwnBadges[] = [];

  /**
   * Merkle challenge that must be satisfied for approval.
   *
   * @generated from field: badges.MerkleChallenge merkleChallenge = 2;
   */
  merkleChallenge?: MerkleChallenge;

  /**
   * Predetermined balances for eeach approval.
   *
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 3;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * Threshold limit of amounts that can be transferred using this approval.
   *
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 4;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * Maximum number of transfers that can be processed using this approval.
   *
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 5;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * Require the "from" address to be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireFromEqualsInitiatedBy = 10;
   */
  requireFromEqualsInitiatedBy = false;

  /**
   * Require the "from" address to not be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireFromDoesNotEqualInitiatedBy = 12;
   */
  requireFromDoesNotEqualInitiatedBy = false;

  constructor(data?: PartialMessage<IncomingApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.IncomingApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mustOwnBadges", kind: "message", T: MustOwnBadges, repeated: true },
    { no: 2, name: "merkleChallenge", kind: "message", T: MerkleChallenge },
    { no: 3, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 4, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 5, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 10, name: "requireFromEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "requireFromDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: IncomingApprovalCriteria | PlainMessage<IncomingApprovalCriteria> | undefined, b: IncomingApprovalCriteria | PlainMessage<IncomingApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(IncomingApprovalCriteria, a, b);
  }
}

/**
 * CollectionApproval defines the rules for the approval of a transfer on the collection level
 *
 * @generated from message badges.CollectionApproval
 */
export class CollectionApproval extends Message<CollectionApproval> {
  /**
   * The mapping ID for the sender of the transfer.
   *
   * @generated from field: string fromMappingId = 1;
   */
  fromMappingId = "";

  /**
   * The mapping ID for the recipient of the transfer.
   *
   * @generated from field: string toMappingId = 2;
   */
  toMappingId = "";

  /**
   * The mapping ID for the user who initiated the transfer.
   *
   * @generated from field: string initiatedByMappingId = 3;
   */
  initiatedByMappingId = "";

  /**
   * The allowed range of transfer times for approval.
   *
   * @generated from field: repeated badges.UintRange transferTimes = 4;
   */
  transferTimes: UintRange[] = [];

  /**
   * The allowed range of badge IDs for approval.
   *
   * @generated from field: repeated badges.UintRange badgeIds = 5;
   */
  badgeIds: UintRange[] = [];

  /**
   * The allowed range of ownership times for approval.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 6;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * The ID of the amount tracker associated with this approval.
   * We use this ID to track the number of transfers and amounts transferred.
   *
   * @generated from field: string amountTrackerId = 7;
   */
  amountTrackerId = "";

  /**
   * The ID of the challenge tracker associated with this approval.
   * We use this ID to track the number of uses per leaf for the Merkle challenge.
   *
   * @generated from field: string challengeTrackerId = 8;
   */
  challengeTrackerId = "";

  /**
   * The URI associated with this approval, optionally providing metadata about the approval.
   *
   * @generated from field: string uri = 9;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this approval.
   *
   * @generated from field: string customData = 10;
   */
  customData = "";

  /**
   * The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
   *
   * @generated from field: string approvalId = 11;
   */
  approvalId = "";

  /**
   * The criteria that must be met for this approval to be considered.
   *
   * @generated from field: badges.ApprovalCriteria approvalCriteria = 12;
   */
  approvalCriteria?: ApprovalCriteria;

  constructor(data?: PartialMessage<CollectionApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "initiatedByMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 7, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "approvalCriteria", kind: "message", T: ApprovalCriteria },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionApproval {
    return new CollectionApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionApproval {
    return new CollectionApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionApproval {
    return new CollectionApproval().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionApproval | PlainMessage<CollectionApproval> | undefined, b: CollectionApproval | PlainMessage<CollectionApproval> | undefined): boolean {
    return proto3.util.equals(CollectionApproval, a, b);
  }
}

/**
 * ApprovalIdentifierDetails defines the details to identify a specific approval.
 *
 * @generated from message badges.ApprovalIdentifierDetails
 */
export class ApprovalIdentifierDetails extends Message<ApprovalIdentifierDetails> {
  /**
   * The ID of the approval.
   *
   * @generated from field: string approvalId = 1;
   */
  approvalId = "";

  /**
   * The level of the approval. Can be "collection", "incoming", or "outgoing".
   *
   * @generated from field: string approvalLevel = 2;
   */
  approvalLevel = "";

  /**
   * The address of the approver. Leave blank "" if approvalLevel == "collection".
   *
   * @generated from field: string approverAddress = 3;
   */
  approverAddress = "";

  constructor(data?: PartialMessage<ApprovalIdentifierDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalIdentifierDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "approvalLevel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approverAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalIdentifierDetails {
    return new ApprovalIdentifierDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalIdentifierDetails {
    return new ApprovalIdentifierDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalIdentifierDetails {
    return new ApprovalIdentifierDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalIdentifierDetails | PlainMessage<ApprovalIdentifierDetails> | undefined, b: ApprovalIdentifierDetails | PlainMessage<ApprovalIdentifierDetails> | undefined): boolean {
    return proto3.util.equals(ApprovalIdentifierDetails, a, b);
  }
}

/**
 * Transfer defines the details of a transfer of badges.
 *
 * @generated from message badges.Transfer
 */
export class Transfer extends Message<Transfer> {
  /**
   * The address of the sender of the transfer.
   *
   * @generated from field: string from = 1;
   */
  from = "";

  /**
   * The addresses of the recipients of the transfer.
   *
   * @generated from field: repeated string toAddresses = 2;
   */
  toAddresses: string[] = [];

  /**
   * The balances to be transferred.
   *
   * @generated from field: repeated badges.Balance balances = 3;
   */
  balances: Balance[] = [];

  /**
   * If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
   * We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
   *
   * @generated from field: badges.ApprovalIdentifierDetails precalculateBalancesFromApproval = 4;
   */
  precalculateBalancesFromApproval?: ApprovalIdentifierDetails;

  /**
   * The Merkle proofs / solutions for all Merkle challenges required for the transfer.
   *
   * @generated from field: repeated badges.MerkleProof merkleProofs = 5;
   */
  merkleProofs: MerkleProof[] = [];

  /**
   * The memo for the transfer.
   *
   * @generated from field: string memo = 6;
   */
  memo = "";

  /**
   * The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
   * This field can be used to prioritize specific approvals and scan through them first.
   *
   * @generated from field: repeated badges.ApprovalIdentifierDetails prioritizedApprovals = 7;
   */
  prioritizedApprovals: ApprovalIdentifierDetails[] = [];

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedApprovals = 8;
   */
  onlyCheckPrioritizedApprovals = false;

  constructor(data?: PartialMessage<Transfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.Transfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toAddresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 4, name: "precalculateBalancesFromApproval", kind: "message", T: ApprovalIdentifierDetails },
    { no: 5, name: "merkleProofs", kind: "message", T: MerkleProof, repeated: true },
    { no: 6, name: "memo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "prioritizedApprovals", kind: "message", T: ApprovalIdentifierDetails, repeated: true },
    { no: 8, name: "onlyCheckPrioritizedApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transfer {
    return new Transfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJsonString(jsonString, options);
  }

  static equals(a: Transfer | PlainMessage<Transfer> | undefined, b: Transfer | PlainMessage<Transfer> | undefined): boolean {
    return proto3.util.equals(Transfer, a, b);
  }
}

/**
 * MerklePathItem represents an item in a Merkle path.
 *
 * @generated from message badges.MerklePathItem
 */
export class MerklePathItem extends Message<MerklePathItem> {
  /**
   * The hash of the sibling node (aunt) in the Merkle path.
   *
   * @generated from field: string aunt = 1;
   */
  aunt = "";

  /**
   * Indicates whether the aunt node is on the right side of the path.
   *
   * @generated from field: bool onRight = 2;
   */
  onRight = false;

  constructor(data?: PartialMessage<MerklePathItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerklePathItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aunt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "onRight", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerklePathItem {
    return new MerklePathItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJsonString(jsonString, options);
  }

  static equals(a: MerklePathItem | PlainMessage<MerklePathItem> | undefined, b: MerklePathItem | PlainMessage<MerklePathItem> | undefined): boolean {
    return proto3.util.equals(MerklePathItem, a, b);
  }
}

/**
 * MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
 *
 * @generated from message badges.MerkleProof
 */
export class MerkleProof extends Message<MerkleProof> {
  /**
   * The hash of the leaf node for which the proof is generated.
   *
   * @generated from field: string leaf = 1;
   */
  leaf = "";

  /**
   * List of Merkle path items (aunts) that make up the proof.
   *
   * @generated from field: repeated badges.MerklePathItem aunts = 2;
   */
  aunts: MerklePathItem[] = [];

  constructor(data?: PartialMessage<MerkleProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "leaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "aunts", kind: "message", T: MerklePathItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleProof {
    return new MerkleProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleProof | PlainMessage<MerkleProof> | undefined, b: MerkleProof | PlainMessage<MerkleProof> | undefined): boolean {
    return proto3.util.equals(MerkleProof, a, b);
  }
}

