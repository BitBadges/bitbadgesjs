// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file badges/transfers.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Balance, MustOwnBadges, UintRange } from "./balances_pb.js";
import { UserPermissions } from "./permissions_pb.js";

/**
 * UserBalanceStore is the store for the user balances
 * It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
 * and the permissions for updating the approved incoming/outgoing transfers.
 *
 * The default approved outgoing / incoming transfers are defined by the collection.
 *
 * The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
 * If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user).
 *
 * The incoming transfers can be used to allow / disallow transfers which are sent to this user.
 * If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user).
 *
 * Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
 * the user approved transfers.
 *
 * @generated from message badges.UserBalanceStore
 */
export class UserBalanceStore extends Message<UserBalanceStore> {
  /**
   * @generated from field: repeated badges.Balance balances = 1;
   */
  balances: Balance[] = [];

  /**
   * @generated from field: repeated badges.UserOutgoingApproval outgoingApprovals = 2;
   */
  outgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * @generated from field: repeated badges.UserIncomingApproval incomingApprovals = 3;
   */
  incomingApprovals: UserIncomingApproval[] = [];

  /**
   * @generated from field: bool autoApproveSelfInitiatedOutgoingTransfers = 4;
   */
  autoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * @generated from field: bool autoApproveSelfInitiatedIncomingTransfers = 5;
   */
  autoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * @generated from field: badges.UserPermissions userPermissions = 6;
   */
  userPermissions?: UserPermissions;

  constructor(data?: PartialMessage<UserBalanceStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserBalanceStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 2, name: "outgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 3, name: "incomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 4, name: "autoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "autoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "userPermissions", kind: "message", T: UserPermissions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserBalanceStore {
    return new UserBalanceStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserBalanceStore {
    return new UserBalanceStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserBalanceStore {
    return new UserBalanceStore().fromJsonString(jsonString, options);
  }

  static equals(a: UserBalanceStore | PlainMessage<UserBalanceStore> | undefined, b: UserBalanceStore | PlainMessage<UserBalanceStore> | undefined): boolean {
    return proto3.util.equals(UserBalanceStore, a, b);
  }
}

/**
 * Challenges define the rules for the approval.
 * If all challenge are not met with valid solutions, then the transfer is not approved.
 *
 * Currently, we only support Merkle tree challenges where the Merkle path must be to the provided root
 * and be the expected length.
 *
 * We also support the following options:
 * -useCreatorAddressAsLeaf: If true, then the leaf will be set to the creator address. Used for whitelist trees.
 * -maxOneUsePerLeaf: If true, then each leaf can only be used once. If false, then the leaf can be used multiple times.
 * This is very important to be set to true if you want to prevent replay attacks.
 * -useLeafIndexForDistributionOrder: If true, we will use the leafIndex to determine the order of the distribution of badges.
 * leafIndex 0 will be the leftmost leaf of the expectedProofLength layer
 *
 * IMPORTANT: We track the number of uses per leaf according to a challenge ID.
 * Please use unique challenge IDs for different challenges of the same timeline.
 * If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
 * It is highly recommended to avoid updating a challenge without resetting the tally via a new challenge ID.
 *
 * @generated from message badges.MerkleChallenge
 */
export class MerkleChallenge extends Message<MerkleChallenge> {
  /**
   * @generated from field: string root = 1;
   */
  root = "";

  /**
   * @generated from field: string expectedProofLength = 2;
   */
  expectedProofLength = "";

  /**
   * @generated from field: bool useCreatorAddressAsLeaf = 3;
   */
  useCreatorAddressAsLeaf = false;

  /**
   * @generated from field: string maxUsesPerLeaf = 4;
   */
  maxUsesPerLeaf = "";

  /**
   * @generated from field: string uri = 6;
   */
  uri = "";

  /**
   * @generated from field: string customData = 7;
   */
  customData = "";

  constructor(data?: PartialMessage<MerkleChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expectedProofLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "useCreatorAddressAsLeaf", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "maxUsesPerLeaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined, b: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined): boolean {
    return proto3.util.equals(MerkleChallenge, a, b);
  }
}

/**
 * UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.
 * See CollectionApproval for more details. This is the same minus a few fields.
 *
 * @generated from message badges.UserOutgoingApproval
 */
export class UserOutgoingApproval extends Message<UserOutgoingApproval> {
  /**
   * @generated from field: string toMappingId = 1;
   */
  toMappingId = "";

  /**
   * @generated from field: string initiatedByMappingId = 2;
   */
  initiatedByMappingId = "";

  /**
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange badgeIds = 4;
   */
  badgeIds: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * if approved, we use these. if not, these are ignored
   *
   * @generated from field: string uri = 8;
   */
  uri = "";

  /**
   * @generated from field: string customData = 9;
   */
  customData = "";

  /**
   * @generated from field: string approvalId = 10;
   */
  approvalId = "";

  /**
   * @generated from field: badges.OutgoingApprovalCriteria approvalCriteria = 11;
   */
  approvalCriteria?: OutgoingApprovalCriteria;

  constructor(data?: PartialMessage<UserOutgoingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserOutgoingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "toMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "approvalCriteria", kind: "message", T: OutgoingApprovalCriteria },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserOutgoingApproval {
    return new UserOutgoingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserOutgoingApproval {
    return new UserOutgoingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserOutgoingApproval {
    return new UserOutgoingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: UserOutgoingApproval | PlainMessage<UserOutgoingApproval> | undefined, b: UserOutgoingApproval | PlainMessage<UserOutgoingApproval> | undefined): boolean {
    return proto3.util.equals(UserOutgoingApproval, a, b);
  }
}

/**
 * UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.
 * See CollectionApproval for more details. This is the same minus a few fields.
 *
 * @generated from message badges.UserIncomingApproval
 */
export class UserIncomingApproval extends Message<UserIncomingApproval> {
  /**
   * @generated from field: string fromMappingId = 1;
   */
  fromMappingId = "";

  /**
   * @generated from field: string initiatedByMappingId = 2;
   */
  initiatedByMappingId = "";

  /**
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange badgeIds = 4;
   */
  badgeIds: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * if applicable
   *
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * if applicable
   *
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * @generated from field: string uri = 8;
   */
  uri = "";

  /**
   * @generated from field: string customData = 9;
   */
  customData = "";

  /**
   * if applicable
   *
   * @generated from field: string approvalId = 10;
   */
  approvalId = "";

  /**
   * @generated from field: badges.IncomingApprovalCriteria approvalCriteria = 11;
   */
  approvalCriteria?: IncomingApprovalCriteria;

  constructor(data?: PartialMessage<UserIncomingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserIncomingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "approvalCriteria", kind: "message", T: IncomingApprovalCriteria },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserIncomingApproval {
    return new UserIncomingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserIncomingApproval {
    return new UserIncomingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserIncomingApproval {
    return new UserIncomingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: UserIncomingApproval | PlainMessage<UserIncomingApproval> | undefined, b: UserIncomingApproval | PlainMessage<UserIncomingApproval> | undefined): boolean {
    return proto3.util.equals(UserIncomingApproval, a, b);
  }
}

/**
 * @generated from message badges.ManualBalances
 */
export class ManualBalances extends Message<ManualBalances> {
  /**
   * @generated from field: repeated badges.Balance balances = 1;
   */
  balances: Balance[] = [];

  constructor(data?: PartialMessage<ManualBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ManualBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balances", kind: "message", T: Balance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ManualBalances {
    return new ManualBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ManualBalances {
    return new ManualBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ManualBalances {
    return new ManualBalances().fromJsonString(jsonString, options);
  }

  static equals(a: ManualBalances | PlainMessage<ManualBalances> | undefined, b: ManualBalances | PlainMessage<ManualBalances> | undefined): boolean {
    return proto3.util.equals(ManualBalances, a, b);
  }
}

/**
 * @generated from message badges.IncrementedBalances
 */
export class IncrementedBalances extends Message<IncrementedBalances> {
  /**
   * @generated from field: repeated badges.Balance startBalances = 1;
   */
  startBalances: Balance[] = [];

  /**
   * @generated from field: string incrementBadgeIdsBy = 2;
   */
  incrementBadgeIdsBy = "";

  /**
   * @generated from field: string incrementOwnershipTimesBy = 3;
   */
  incrementOwnershipTimesBy = "";

  constructor(data?: PartialMessage<IncrementedBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.IncrementedBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "startBalances", kind: "message", T: Balance, repeated: true },
    { no: 2, name: "incrementBadgeIdsBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "incrementOwnershipTimesBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromJsonString(jsonString, options);
  }

  static equals(a: IncrementedBalances | PlainMessage<IncrementedBalances> | undefined, b: IncrementedBalances | PlainMessage<IncrementedBalances> | undefined): boolean {
    return proto3.util.equals(IncrementedBalances, a, b);
  }
}

/**
 * @generated from message badges.PredeterminedOrderCalculationMethod
 */
export class PredeterminedOrderCalculationMethod extends Message<PredeterminedOrderCalculationMethod> {
  /**
   * @generated from field: bool useOverallNumTransfers = 1;
   */
  useOverallNumTransfers = false;

  /**
   * @generated from field: bool usePerToAddressNumTransfers = 2;
   */
  usePerToAddressNumTransfers = false;

  /**
   * @generated from field: bool usePerFromAddressNumTransfers = 3;
   */
  usePerFromAddressNumTransfers = false;

  /**
   * @generated from field: bool usePerInitiatedByAddressNumTransfers = 4;
   */
  usePerInitiatedByAddressNumTransfers = false;

  /**
   * @generated from field: bool useMerkleChallengeLeafIndex = 5;
   */
  useMerkleChallengeLeafIndex = false;

  constructor(data?: PartialMessage<PredeterminedOrderCalculationMethod>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PredeterminedOrderCalculationMethod";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "useOverallNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "usePerToAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "usePerFromAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "usePerInitiatedByAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "useMerkleChallengeLeafIndex", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromJsonString(jsonString, options);
  }

  static equals(a: PredeterminedOrderCalculationMethod | PlainMessage<PredeterminedOrderCalculationMethod> | undefined, b: PredeterminedOrderCalculationMethod | PlainMessage<PredeterminedOrderCalculationMethod> | undefined): boolean {
    return proto3.util.equals(PredeterminedOrderCalculationMethod, a, b);
  }
}

/**
 * @generated from message badges.PredeterminedBalances
 */
export class PredeterminedBalances extends Message<PredeterminedBalances> {
  /**
   * @generated from field: repeated badges.ManualBalances manualBalances = 1;
   */
  manualBalances: ManualBalances[] = [];

  /**
   * @generated from field: badges.IncrementedBalances incrementedBalances = 2;
   */
  incrementedBalances?: IncrementedBalances;

  /**
   * @generated from field: badges.PredeterminedOrderCalculationMethod orderCalculationMethod = 3;
   */
  orderCalculationMethod?: PredeterminedOrderCalculationMethod;

  constructor(data?: PartialMessage<PredeterminedBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PredeterminedBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "manualBalances", kind: "message", T: ManualBalances, repeated: true },
    { no: 2, name: "incrementedBalances", kind: "message", T: IncrementedBalances },
    { no: 3, name: "orderCalculationMethod", kind: "message", T: PredeterminedOrderCalculationMethod },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromJsonString(jsonString, options);
  }

  static equals(a: PredeterminedBalances | PlainMessage<PredeterminedBalances> | undefined, b: PredeterminedBalances | PlainMessage<PredeterminedBalances> | undefined): boolean {
    return proto3.util.equals(PredeterminedBalances, a, b);
  }
}

/**
 * PerAddressApprovals defines the approvals per unique from, to, and/or initiatedBy address.
 *
 * @generated from message badges.ApprovalAmounts
 */
export class ApprovalAmounts extends Message<ApprovalAmounts> {
  /**
   * @generated from field: string overallApprovalAmount = 1;
   */
  overallApprovalAmount = "";

  /**
   * @generated from field: string perToAddressApprovalAmount = 2;
   */
  perToAddressApprovalAmount = "";

  /**
   * @generated from field: string perFromAddressApprovalAmount = 3;
   */
  perFromAddressApprovalAmount = "";

  /**
   * @generated from field: string perInitiatedByAddressApprovalAmount = 4;
   */
  perInitiatedByAddressApprovalAmount = "";

  constructor(data?: PartialMessage<ApprovalAmounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalAmounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overallApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "perToAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "perFromAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "perInitiatedByAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalAmounts | PlainMessage<ApprovalAmounts> | undefined, b: ApprovalAmounts | PlainMessage<ApprovalAmounts> | undefined): boolean {
    return proto3.util.equals(ApprovalAmounts, a, b);
  }
}

/**
 * @generated from message badges.MaxNumTransfers
 */
export class MaxNumTransfers extends Message<MaxNumTransfers> {
  /**
   * @generated from field: string overallMaxNumTransfers = 1;
   */
  overallMaxNumTransfers = "";

  /**
   * @generated from field: string perToAddressMaxNumTransfers = 2;
   */
  perToAddressMaxNumTransfers = "";

  /**
   * @generated from field: string perFromAddressMaxNumTransfers = 3;
   */
  perFromAddressMaxNumTransfers = "";

  /**
   * @generated from field: string perInitiatedByAddressMaxNumTransfers = 4;
   */
  perInitiatedByAddressMaxNumTransfers = "";

  constructor(data?: PartialMessage<MaxNumTransfers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MaxNumTransfers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overallMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "perToAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "perFromAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "perInitiatedByAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromJsonString(jsonString, options);
  }

  static equals(a: MaxNumTransfers | PlainMessage<MaxNumTransfers> | undefined, b: MaxNumTransfers | PlainMessage<MaxNumTransfers> | undefined): boolean {
    return proto3.util.equals(MaxNumTransfers, a, b);
  }
}

/**
 * @generated from message badges.ApprovalsTracker
 */
export class ApprovalsTracker extends Message<ApprovalsTracker> {
  /**
   * @generated from field: string numTransfers = 1;
   */
  numTransfers = "";

  /**
   * @generated from field: repeated badges.Balance amounts = 2;
   */
  amounts: Balance[] = [];

  constructor(data?: PartialMessage<ApprovalsTracker>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalsTracker";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "numTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amounts", kind: "message", T: Balance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalsTracker {
    return new ApprovalsTracker().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalsTracker {
    return new ApprovalsTracker().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalsTracker {
    return new ApprovalsTracker().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalsTracker | PlainMessage<ApprovalsTracker> | undefined, b: ApprovalsTracker | PlainMessage<ApprovalsTracker> | undefined): boolean {
    return proto3.util.equals(ApprovalsTracker, a, b);
  }
}

/**
 * @generated from message badges.ApprovalCriteria
 */
export class ApprovalCriteria extends Message<ApprovalCriteria> {
  /**
   * @generated from field: repeated badges.MustOwnBadges mustOwnBadges = 1;
   */
  mustOwnBadges: MustOwnBadges[] = [];

  /**
   * @generated from field: badges.MerkleChallenge merkleChallenge = 2;
   */
  merkleChallenge?: MerkleChallenge;

  /**
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 3;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 4;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 5;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * @generated from field: bool requireToEqualsInitiatedBy = 9;
   */
  requireToEqualsInitiatedBy = false;

  /**
   * @generated from field: bool requireFromEqualsInitiatedBy = 10;
   */
  requireFromEqualsInitiatedBy = false;

  /**
   * @generated from field: bool requireToDoesNotEqualInitiatedBy = 11;
   */
  requireToDoesNotEqualInitiatedBy = false;

  /**
   * @generated from field: bool requireFromDoesNotEqualInitiatedBy = 12;
   */
  requireFromDoesNotEqualInitiatedBy = false;

  /**
   * @generated from field: bool overridesFromOutgoingApprovals = 13;
   */
  overridesFromOutgoingApprovals = false;

  /**
   * @generated from field: bool overridesToIncomingApprovals = 14;
   */
  overridesToIncomingApprovals = false;

  constructor(data?: PartialMessage<ApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mustOwnBadges", kind: "message", T: MustOwnBadges, repeated: true },
    { no: 2, name: "merkleChallenge", kind: "message", T: MerkleChallenge },
    { no: 3, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 4, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 5, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 9, name: "requireToEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "requireFromEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "requireToDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "requireFromDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "overridesFromOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "overridesToIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalCriteria | PlainMessage<ApprovalCriteria> | undefined, b: ApprovalCriteria | PlainMessage<ApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(ApprovalCriteria, a, b);
  }
}

/**
 * @generated from message badges.OutgoingApprovalCriteria
 */
export class OutgoingApprovalCriteria extends Message<OutgoingApprovalCriteria> {
  /**
   * @generated from field: repeated badges.MustOwnBadges mustOwnBadges = 1;
   */
  mustOwnBadges: MustOwnBadges[] = [];

  /**
   * @generated from field: badges.MerkleChallenge merkleChallenge = 2;
   */
  merkleChallenge?: MerkleChallenge;

  /**
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 3;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 4;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 5;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * @generated from field: bool requireToEqualsInitiatedBy = 9;
   */
  requireToEqualsInitiatedBy = false;

  /**
   * @generated from field: bool requireToDoesNotEqualInitiatedBy = 11;
   */
  requireToDoesNotEqualInitiatedBy = false;

  constructor(data?: PartialMessage<OutgoingApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.OutgoingApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mustOwnBadges", kind: "message", T: MustOwnBadges, repeated: true },
    { no: 2, name: "merkleChallenge", kind: "message", T: MerkleChallenge },
    { no: 3, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 4, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 5, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 9, name: "requireToEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "requireToDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: OutgoingApprovalCriteria | PlainMessage<OutgoingApprovalCriteria> | undefined, b: OutgoingApprovalCriteria | PlainMessage<OutgoingApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(OutgoingApprovalCriteria, a, b);
  }
}

/**
 * @generated from message badges.IncomingApprovalCriteria
 */
export class IncomingApprovalCriteria extends Message<IncomingApprovalCriteria> {
  /**
   * @generated from field: repeated badges.MustOwnBadges mustOwnBadges = 1;
   */
  mustOwnBadges: MustOwnBadges[] = [];

  /**
   * @generated from field: badges.MerkleChallenge merkleChallenge = 2;
   */
  merkleChallenge?: MerkleChallenge;

  /**
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 3;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 4;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 5;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * @generated from field: bool requireFromEqualsInitiatedBy = 10;
   */
  requireFromEqualsInitiatedBy = false;

  /**
   * @generated from field: bool requireFromDoesNotEqualInitiatedBy = 12;
   */
  requireFromDoesNotEqualInitiatedBy = false;

  constructor(data?: PartialMessage<IncomingApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.IncomingApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mustOwnBadges", kind: "message", T: MustOwnBadges, repeated: true },
    { no: 2, name: "merkleChallenge", kind: "message", T: MerkleChallenge },
    { no: 3, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 4, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 5, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 10, name: "requireFromEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "requireFromDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: IncomingApprovalCriteria | PlainMessage<IncomingApprovalCriteria> | undefined, b: IncomingApprovalCriteria | PlainMessage<IncomingApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(IncomingApprovalCriteria, a, b);
  }
}

/**
 * @generated from message badges.CollectionApproval
 */
export class CollectionApproval extends Message<CollectionApproval> {
  /**
   * Match Criteria 
   *
   * @generated from field: string fromMappingId = 1;
   */
  fromMappingId = "";

  /**
   * @generated from field: string toMappingId = 2;
   */
  toMappingId = "";

  /**
   * @generated from field: string initiatedByMappingId = 3;
   */
  initiatedByMappingId = "";

  /**
   * @generated from field: repeated badges.UintRange transferTimes = 4;
   */
  transferTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange badgeIds = 5;
   */
  badgeIds: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange ownershipTimes = 6;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * if applicable
   *
   * @generated from field: string amountTrackerId = 7;
   */
  amountTrackerId = "";

  /**
   * if applicable
   *
   * @generated from field: string challengeTrackerId = 8;
   */
  challengeTrackerId = "";

  /**
   * @generated from field: string uri = 9;
   */
  uri = "";

  /**
   * @generated from field: string customData = 10;
   */
  customData = "";

  /**
   * if applicable
   *
   * @generated from field: string approvalId = 11;
   */
  approvalId = "";

  /**
   * @generated from field: badges.ApprovalCriteria approvalCriteria = 12;
   */
  approvalCriteria?: ApprovalCriteria;

  constructor(data?: PartialMessage<CollectionApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "initiatedByMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 7, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "approvalCriteria", kind: "message", T: ApprovalCriteria },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionApproval {
    return new CollectionApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionApproval {
    return new CollectionApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionApproval {
    return new CollectionApproval().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionApproval | PlainMessage<CollectionApproval> | undefined, b: CollectionApproval | PlainMessage<CollectionApproval> | undefined): boolean {
    return proto3.util.equals(CollectionApproval, a, b);
  }
}

/**
 * @generated from message badges.ApprovalIdentifierDetails
 */
export class ApprovalIdentifierDetails extends Message<ApprovalIdentifierDetails> {
  /**
   * @generated from field: string approvalId = 1;
   */
  approvalId = "";

  /**
   * "collection", "incoming", "outgoing"
   *
   * @generated from field: string approvalLevel = 2;
   */
  approvalLevel = "";

  /**
   * Leave blank if approvalLevel == "collection"
   *
   * @generated from field: string approverAddress = 3;
   */
  approverAddress = "";

  constructor(data?: PartialMessage<ApprovalIdentifierDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalIdentifierDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "approvalLevel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approverAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalIdentifierDetails {
    return new ApprovalIdentifierDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalIdentifierDetails {
    return new ApprovalIdentifierDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalIdentifierDetails {
    return new ApprovalIdentifierDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalIdentifierDetails | PlainMessage<ApprovalIdentifierDetails> | undefined, b: ApprovalIdentifierDetails | PlainMessage<ApprovalIdentifierDetails> | undefined): boolean {
    return proto3.util.equals(ApprovalIdentifierDetails, a, b);
  }
}

/**
 * @generated from message badges.Transfer
 */
export class Transfer extends Message<Transfer> {
  /**
   * @generated from field: string from = 1;
   */
  from = "";

  /**
   * @generated from field: repeated string toAddresses = 2;
   */
  toAddresses: string[] = [];

  /**
   * @generated from field: repeated badges.Balance balances = 3;
   */
  balances: Balance[] = [];

  /**
   * @generated from field: badges.ApprovalIdentifierDetails precalculateBalancesFromApproval = 4;
   */
  precalculateBalancesFromApproval?: ApprovalIdentifierDetails;

  /**
   * @generated from field: repeated badges.MerkleProof merkleProofs = 5;
   */
  merkleProofs: MerkleProof[] = [];

  /**
   * @generated from field: string memo = 6;
   */
  memo = "";

  /**
   * @generated from field: repeated badges.ApprovalIdentifierDetails prioritizedApprovals = 7;
   */
  prioritizedApprovals: ApprovalIdentifierDetails[] = [];

  /**
   * @generated from field: bool onlyCheckPrioritizedApprovals = 8;
   */
  onlyCheckPrioritizedApprovals = false;

  constructor(data?: PartialMessage<Transfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.Transfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toAddresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 4, name: "precalculateBalancesFromApproval", kind: "message", T: ApprovalIdentifierDetails },
    { no: 5, name: "merkleProofs", kind: "message", T: MerkleProof, repeated: true },
    { no: 6, name: "memo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "prioritizedApprovals", kind: "message", T: ApprovalIdentifierDetails, repeated: true },
    { no: 8, name: "onlyCheckPrioritizedApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transfer {
    return new Transfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJsonString(jsonString, options);
  }

  static equals(a: Transfer | PlainMessage<Transfer> | undefined, b: Transfer | PlainMessage<Transfer> | undefined): boolean {
    return proto3.util.equals(Transfer, a, b);
  }
}

/**
 * @generated from message badges.MerklePathItem
 */
export class MerklePathItem extends Message<MerklePathItem> {
  /**
   * @generated from field: string aunt = 1;
   */
  aunt = "";

  /**
   * @generated from field: bool onRight = 2;
   */
  onRight = false;

  constructor(data?: PartialMessage<MerklePathItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerklePathItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aunt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "onRight", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerklePathItem {
    return new MerklePathItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJsonString(jsonString, options);
  }

  static equals(a: MerklePathItem | PlainMessage<MerklePathItem> | undefined, b: MerklePathItem | PlainMessage<MerklePathItem> | undefined): boolean {
    return proto3.util.equals(MerklePathItem, a, b);
  }
}

/**
 * Consistent with tendermint/crypto merkle tree
 *
 * @generated from message badges.MerkleProof
 */
export class MerkleProof extends Message<MerkleProof> {
  /**
   * @generated from field: string leaf = 1;
   */
  leaf = "";

  /**
   * @generated from field: repeated badges.MerklePathItem aunts = 2;
   */
  aunts: MerklePathItem[] = [];

  constructor(data?: PartialMessage<MerkleProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "leaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "aunts", kind: "message", T: MerklePathItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleProof {
    return new MerkleProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleProof | PlainMessage<MerkleProof> | undefined, b: MerkleProof | PlainMessage<MerkleProof> | undefined): boolean {
    return proto3.util.equals(MerkleProof, a, b);
  }
}

