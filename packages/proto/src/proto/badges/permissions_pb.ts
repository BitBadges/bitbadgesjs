// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file badges/permissions.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { UintRange } from "./balances_pb.js";

/**
 * CollectionPermissions defines the permissions for the collection (i.e. what the manager can and cannot do).
 *
 * There are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BalancesActionPermission, and CollectionApprovalPermission.
 *
 * The permission type allows fine-grained access control for each action.
 * ActionPermission: defines when the manager can perform an action.
 * TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.
 * TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.
 * BalancesActionPermission: defines when the manager can perform an action for specific badges and specific badge ownership times.
 * CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs locked
 *
 * Note there are a few different times here which could get confusing:
 * - timelineTimes: the times when a timeline-based field is a specific value
 * - permitted/forbiddenTimes - the times that a permission can be performed
 * - transferTimes - the times that a transfer occurs
 * - ownershipTimes - the times when a badge is owned by a user
 *
 * The permitted/forbiddenTimes are used to determine when a permission can be executed.
 * Once a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.
 * If a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.
 *
 * Each permission type has a defaultValues field and a combinations field.
 * The defaultValues field defines the default values for the permission which can be manipulated by the combinations field (to avoid unnecessary repetition).
 * Ex: We can have default value badgeIds = [1,2] and combinations = [{invertDefault: true, isApproved: false}, {isApproved: true}].
 * This would mean that badgeIds [1,2] are allowed but everything else is not allowed.
 *
 * IMPORTANT: For all permissions, we ONLY take the first combination that matches. Any subsequent combinations are ignored. 
 * Ex: If we have defaultValues = {badgeIds: [1,2]} and combinations = [{isApproved: true}, {isApproved: false}].
 * This would mean that badgeIds [1,2] are allowed and the second combination is ignored.
 *
 * @generated from message badges.CollectionPermissions
 */
export class CollectionPermissions extends Message<CollectionPermissions> {
  /**
   * @generated from field: repeated badges.ActionPermission canDeleteCollection = 1;
   */
  canDeleteCollection: ActionPermission[] = [];

  /**
   * @generated from field: repeated badges.TimedUpdatePermission canArchiveCollection = 2;
   */
  canArchiveCollection: TimedUpdatePermission[] = [];

  /**
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateOffChainBalancesMetadata = 3;
   */
  canUpdateOffChainBalancesMetadata: TimedUpdatePermission[] = [];

  /**
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateStandards = 4;
   */
  canUpdateStandards: TimedUpdatePermission[] = [];

  /**
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateCustomData = 5;
   */
  canUpdateCustomData: TimedUpdatePermission[] = [];

  /**
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateManager = 6;
   */
  canUpdateManager: TimedUpdatePermission[] = [];

  /**
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateCollectionMetadata = 7;
   */
  canUpdateCollectionMetadata: TimedUpdatePermission[] = [];

  /**
   * @generated from field: repeated badges.BalancesActionPermission canCreateMoreBadges = 8;
   */
  canCreateMoreBadges: BalancesActionPermission[] = [];

  /**
   * @generated from field: repeated badges.TimedUpdateWithBadgeIdsPermission canUpdateBadgeMetadata = 9;
   */
  canUpdateBadgeMetadata: TimedUpdateWithBadgeIdsPermission[] = [];

  /**
   * @generated from field: repeated badges.CollectionApprovalPermission canUpdateCollectionApprovals = 10;
   */
  canUpdateCollectionApprovals: CollectionApprovalPermission[] = [];

  constructor(data?: PartialMessage<CollectionPermissions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionPermissions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "canDeleteCollection", kind: "message", T: ActionPermission, repeated: true },
    { no: 2, name: "canArchiveCollection", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 3, name: "canUpdateOffChainBalancesMetadata", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 4, name: "canUpdateStandards", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 5, name: "canUpdateCustomData", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 6, name: "canUpdateManager", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 7, name: "canUpdateCollectionMetadata", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 8, name: "canCreateMoreBadges", kind: "message", T: BalancesActionPermission, repeated: true },
    { no: 9, name: "canUpdateBadgeMetadata", kind: "message", T: TimedUpdateWithBadgeIdsPermission, repeated: true },
    { no: 10, name: "canUpdateCollectionApprovals", kind: "message", T: CollectionApprovalPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionPermissions {
    return new CollectionPermissions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionPermissions {
    return new CollectionPermissions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionPermissions {
    return new CollectionPermissions().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionPermissions | PlainMessage<CollectionPermissions> | undefined, b: CollectionPermissions | PlainMessage<CollectionPermissions> | undefined): boolean {
    return proto3.util.equals(CollectionPermissions, a, b);
  }
}

/**
 * UserPermissions defines the permissions for the user (i.e. what the user can and cannot do).
 *
 * See CollectionPermissions for more details on the different types of permissions.
 * The UserApprovedOutgoing and UserApprovedIncoming permissions are the same as the CollectionApprovalPermission,
 * but certain fields are removed because they are not relevant to the user.
 *
 * @generated from message badges.UserPermissions
 */
export class UserPermissions extends Message<UserPermissions> {
  /**
   * @generated from field: repeated badges.UserOutgoingApprovalPermission canUpdateOutgoingApprovals = 1;
   */
  canUpdateOutgoingApprovals: UserOutgoingApprovalPermission[] = [];

  /**
   * @generated from field: repeated badges.UserIncomingApprovalPermission canUpdateIncomingApprovals = 2;
   */
  canUpdateIncomingApprovals: UserIncomingApprovalPermission[] = [];

  /**
   * @generated from field: repeated badges.ActionPermission canUpdateAutoApproveSelfInitiatedOutgoingTransfers = 3;
   */
  canUpdateAutoApproveSelfInitiatedOutgoingTransfers: ActionPermission[] = [];

  /**
   * @generated from field: repeated badges.ActionPermission canUpdateAutoApproveSelfInitiatedIncomingTransfers = 4;
   */
  canUpdateAutoApproveSelfInitiatedIncomingTransfers: ActionPermission[] = [];

  constructor(data?: PartialMessage<UserPermissions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserPermissions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "canUpdateOutgoingApprovals", kind: "message", T: UserOutgoingApprovalPermission, repeated: true },
    { no: 2, name: "canUpdateIncomingApprovals", kind: "message", T: UserIncomingApprovalPermission, repeated: true },
    { no: 3, name: "canUpdateAutoApproveSelfInitiatedOutgoingTransfers", kind: "message", T: ActionPermission, repeated: true },
    { no: 4, name: "canUpdateAutoApproveSelfInitiatedIncomingTransfers", kind: "message", T: ActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPermissions {
    return new UserPermissions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPermissions {
    return new UserPermissions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPermissions {
    return new UserPermissions().fromJsonString(jsonString, options);
  }

  static equals(a: UserPermissions | PlainMessage<UserPermissions> | undefined, b: UserPermissions | PlainMessage<UserPermissions> | undefined): boolean {
    return proto3.util.equals(UserPermissions, a, b);
  }
}

/**
 * CollectionApprovalPermission defines what collection approved transfers can be updated vs are locked.
 *
 * Each transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.
 * For a transfer to match, we need to match ALL of the fields in the combination. 
 * These are detemined by the fromMappingId, toMappingId, initiatedByMappingId, transferTimes, badgeIds fields.
 * AddressMappings are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressMappings). 
 *
 * TimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?
 * permitted/forbidden TimelineTimes: when can the manager execute this permission?
 *
 * Ex: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", 10, 1000).
 * We would check to find the FIRST CollectionApprovalPermission that matches this combination.
 * If we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).
 *
 * Ex: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set
 * the combination ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", "All Transfer Times", 1) to always be forbidden at all timelineTimes.
 *
 * @generated from message badges.CollectionApprovalPermission
 */
export class CollectionApprovalPermission extends Message<CollectionApprovalPermission> {
  /**
   * @generated from field: string fromMappingId = 1;
   */
  fromMappingId = "";

  /**
   * @generated from field: string toMappingId = 2;
   */
  toMappingId = "";

  /**
   * @generated from field: string initiatedByMappingId = 3;
   */
  initiatedByMappingId = "";

  /**
   * @generated from field: repeated badges.UintRange transferTimes = 4;
   */
  transferTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange badgeIds = 5;
   */
  badgeIds: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange ownershipTimes = 6;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * @generated from field: string amountTrackerId = 7;
   */
  amountTrackerId = "";

  /**
   * @generated from field: string challengeTrackerId = 8;
   */
  challengeTrackerId = "";

  /**
   * @generated from field: repeated badges.UintRange permittedTimes = 9;
   */
  permittedTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange forbiddenTimes = 10;
   */
  forbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<CollectionApprovalPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionApprovalPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "initiatedByMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 7, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "permittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 10, name: "forbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionApprovalPermission {
    return new CollectionApprovalPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionApprovalPermission {
    return new CollectionApprovalPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionApprovalPermission {
    return new CollectionApprovalPermission().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionApprovalPermission | PlainMessage<CollectionApprovalPermission> | undefined, b: CollectionApprovalPermission | PlainMessage<CollectionApprovalPermission> | undefined): boolean {
    return proto3.util.equals(CollectionApprovalPermission, a, b);
  }
}

/**
 * UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.
 * See CollectionApprovalPermission for more details. This is equivalent without the fromMappingId field because that is always the user.
 *
 * @generated from message badges.UserOutgoingApprovalPermission
 */
export class UserOutgoingApprovalPermission extends Message<UserOutgoingApprovalPermission> {
  /**
   * @generated from field: string toMappingId = 1;
   */
  toMappingId = "";

  /**
   * @generated from field: string initiatedByMappingId = 2;
   */
  initiatedByMappingId = "";

  /**
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange badgeIds = 4;
   */
  badgeIds: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * @generated from field: repeated badges.UintRange permittedTimes = 8;
   */
  permittedTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange forbiddenTimes = 9;
   */
  forbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<UserOutgoingApprovalPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserOutgoingApprovalPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "toMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "permittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 9, name: "forbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserOutgoingApprovalPermission {
    return new UserOutgoingApprovalPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserOutgoingApprovalPermission {
    return new UserOutgoingApprovalPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserOutgoingApprovalPermission {
    return new UserOutgoingApprovalPermission().fromJsonString(jsonString, options);
  }

  static equals(a: UserOutgoingApprovalPermission | PlainMessage<UserOutgoingApprovalPermission> | undefined, b: UserOutgoingApprovalPermission | PlainMessage<UserOutgoingApprovalPermission> | undefined): boolean {
    return proto3.util.equals(UserOutgoingApprovalPermission, a, b);
  }
}

/**
 * UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.
 * See CollectionApprovalPermission for more details. This is equivalent without the toMappingId field because that is always the user.
 *
 * @generated from message badges.UserIncomingApprovalPermission
 */
export class UserIncomingApprovalPermission extends Message<UserIncomingApprovalPermission> {
  /**
   * @generated from field: string fromMappingId = 1;
   */
  fromMappingId = "";

  /**
   * @generated from field: string initiatedByMappingId = 2;
   */
  initiatedByMappingId = "";

  /**
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange badgeIds = 4;
   */
  badgeIds: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * @generated from field: repeated badges.UintRange permittedTimes = 8;
   */
  permittedTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange forbiddenTimes = 9;
   */
  forbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<UserIncomingApprovalPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserIncomingApprovalPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByMappingId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "permittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 9, name: "forbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserIncomingApprovalPermission {
    return new UserIncomingApprovalPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserIncomingApprovalPermission {
    return new UserIncomingApprovalPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserIncomingApprovalPermission {
    return new UserIncomingApprovalPermission().fromJsonString(jsonString, options);
  }

  static equals(a: UserIncomingApprovalPermission | PlainMessage<UserIncomingApprovalPermission> | undefined, b: UserIncomingApprovalPermission | PlainMessage<UserIncomingApprovalPermission> | undefined): boolean {
    return proto3.util.equals(UserIncomingApprovalPermission, a, b);
  }
}

/**
 * BalancesActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.
 * Currently, this is only used for creating new badges.
 *
 * Ex: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, 
 * you could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
 *
 * @generated from message badges.BalancesActionPermission
 */
export class BalancesActionPermission extends Message<BalancesActionPermission> {
  /**
   * @generated from field: repeated badges.UintRange badgeIds = 1;
   */
  badgeIds: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange ownershipTimes = 2;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange permittedTimes = 3;
   */
  permittedTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange forbiddenTimes = 4;
   */
  forbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<BalancesActionPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BalancesActionPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 2, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 3, name: "permittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "forbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BalancesActionPermission {
    return new BalancesActionPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BalancesActionPermission {
    return new BalancesActionPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BalancesActionPermission {
    return new BalancesActionPermission().fromJsonString(jsonString, options);
  }

  static equals(a: BalancesActionPermission | PlainMessage<BalancesActionPermission> | undefined, b: BalancesActionPermission | PlainMessage<BalancesActionPermission> | undefined): boolean {
    return proto3.util.equals(BalancesActionPermission, a, b);
  }
}

/**
 * ActionPermission defines the permissions for performing an action.
 *
 * This is simple and straightforward as the only thing we need to check is the permitted/forbidden times.
 *
 * @generated from message badges.ActionPermission
 */
export class ActionPermission extends Message<ActionPermission> {
  /**
   * @generated from field: repeated badges.UintRange permittedTimes = 1;
   */
  permittedTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange forbiddenTimes = 2;
   */
  forbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<ActionPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ActionPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "permittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 2, name: "forbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActionPermission {
    return new ActionPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActionPermission {
    return new ActionPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActionPermission {
    return new ActionPermission().fromJsonString(jsonString, options);
  }

  static equals(a: ActionPermission | PlainMessage<ActionPermission> | undefined, b: ActionPermission | PlainMessage<ActionPermission> | undefined): boolean {
    return proto3.util.equals(ActionPermission, a, b);
  }
}

/**
 * TimedUpdatePermission defines the permissions for updating a timeline-based field.
 *
 * Ex: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,
 * you could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
 *
 * @generated from message badges.TimedUpdatePermission
 */
export class TimedUpdatePermission extends Message<TimedUpdatePermission> {
  /**
   * @generated from field: repeated badges.UintRange timelineTimes = 1;
   */
  timelineTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange permittedTimes = 2;
   */
  permittedTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange forbiddenTimes = 3;
   */
  forbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<TimedUpdatePermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.TimedUpdatePermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timelineTimes", kind: "message", T: UintRange, repeated: true },
    { no: 2, name: "permittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 3, name: "forbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimedUpdatePermission {
    return new TimedUpdatePermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimedUpdatePermission {
    return new TimedUpdatePermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimedUpdatePermission {
    return new TimedUpdatePermission().fromJsonString(jsonString, options);
  }

  static equals(a: TimedUpdatePermission | PlainMessage<TimedUpdatePermission> | undefined, b: TimedUpdatePermission | PlainMessage<TimedUpdatePermission> | undefined): boolean {
    return proto3.util.equals(TimedUpdatePermission, a, b);
  }
}

/**
 * TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.
 *
 * Ex: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,
 * you could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
 *
 * @generated from message badges.TimedUpdateWithBadgeIdsPermission
 */
export class TimedUpdateWithBadgeIdsPermission extends Message<TimedUpdateWithBadgeIdsPermission> {
  /**
   * @generated from field: repeated badges.UintRange badgeIds = 1;
   */
  badgeIds: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange timelineTimes = 2;
   */
  timelineTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange permittedTimes = 3;
   */
  permittedTimes: UintRange[] = [];

  /**
   * @generated from field: repeated badges.UintRange forbiddenTimes = 4;
   */
  forbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<TimedUpdateWithBadgeIdsPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.TimedUpdateWithBadgeIdsPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 2, name: "timelineTimes", kind: "message", T: UintRange, repeated: true },
    { no: 3, name: "permittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "forbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimedUpdateWithBadgeIdsPermission {
    return new TimedUpdateWithBadgeIdsPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimedUpdateWithBadgeIdsPermission {
    return new TimedUpdateWithBadgeIdsPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimedUpdateWithBadgeIdsPermission {
    return new TimedUpdateWithBadgeIdsPermission().fromJsonString(jsonString, options);
  }

  static equals(a: TimedUpdateWithBadgeIdsPermission | PlainMessage<TimedUpdateWithBadgeIdsPermission> | undefined, b: TimedUpdateWithBadgeIdsPermission | PlainMessage<TimedUpdateWithBadgeIdsPermission> | undefined): boolean {
    return proto3.util.equals(TimedUpdateWithBadgeIdsPermission, a, b);
  }
}

