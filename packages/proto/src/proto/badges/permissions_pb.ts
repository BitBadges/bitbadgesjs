// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file badges/permissions.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { UintRange } from "./balances_pb.js";

/**
 *
 * CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).
 *
 * There are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BalancesActionPermission, and CollectionApprovalPermission.
 *
 * The permission type allows fine-grained access control for each action.
 * - ActionPermission: defines when the manager can perform an action.
 * - TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.
 * - TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.
 * - BalancesActionPermission: defines when the manager can perform an action for specific badges and specific badge ownership times.
 * - CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.
 *
 * Note there are a few different times here which could get confusing:
 * - timelineTimes: the times when a timeline-based field is a specific value
 * - permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed
 * - transferTimes - the times that a transfer occurs
 * - ownershipTimes - the times when a badge is owned by a user
 *
 * The permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.
 * Once a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.
 * If a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.
 *
 * IMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, 
 * we will only check the first permission (forbid time T) and not the second permission (permit time T).
 *
 * @generated from message badges.CollectionPermissions
 */
export class CollectionPermissions extends Message<CollectionPermissions> {
  /**
   * Permissions related to deleting the collection.
   *
   * @generated from field: repeated badges.ActionPermission canDeleteCollection = 1;
   */
  canDeleteCollection: ActionPermission[] = [];

  /**
   * Permissions related to archiving the collection.
   *
   * @generated from field: repeated badges.TimedUpdatePermission canArchiveCollection = 2;
   */
  canArchiveCollection: TimedUpdatePermission[] = [];

  /**
   * Permissions related to updating off-chain balances metadata.
   *
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateOffChainBalancesMetadata = 3;
   */
  canUpdateOffChainBalancesMetadata: TimedUpdatePermission[] = [];

  /**
   * Permissions related to updating standards for the collection.
   *
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateStandards = 4;
   */
  canUpdateStandards: TimedUpdatePermission[] = [];

  /**
   * Permissions related to updating custom data for the collection.
   *
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateCustomData = 5;
   */
  canUpdateCustomData: TimedUpdatePermission[] = [];

  /**
   * Permissions related to updating the collection's manager.
   *
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateManager = 6;
   */
  canUpdateManager: TimedUpdatePermission[] = [];

  /**
   * Permissions related to updating the metadata of the collection.
   *
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateCollectionMetadata = 7;
   */
  canUpdateCollectionMetadata: TimedUpdatePermission[] = [];

  /**
   * Permissions related to creating more badges for the collection.
   *
   * @generated from field: repeated badges.BalancesActionPermission canCreateMoreBadges = 8;
   */
  canCreateMoreBadges: BalancesActionPermission[] = [];

  /**
   * Permissions related to updating badge metadata for specific badges.
   *
   * @generated from field: repeated badges.TimedUpdateWithBadgeIdsPermission canUpdateBadgeMetadata = 9;
   */
  canUpdateBadgeMetadata: TimedUpdateWithBadgeIdsPermission[] = [];

  /**
   * Permissions related to updating collection approvals.
   *
   * @generated from field: repeated badges.CollectionApprovalPermission canUpdateCollectionApprovals = 10;
   */
  canUpdateCollectionApprovals: CollectionApprovalPermission[] = [];

  constructor(data?: PartialMessage<CollectionPermissions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionPermissions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "canDeleteCollection", kind: "message", T: ActionPermission, repeated: true },
    { no: 2, name: "canArchiveCollection", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 3, name: "canUpdateOffChainBalancesMetadata", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 4, name: "canUpdateStandards", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 5, name: "canUpdateCustomData", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 6, name: "canUpdateManager", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 7, name: "canUpdateCollectionMetadata", kind: "message", T: TimedUpdatePermission, repeated: true },
    { no: 8, name: "canCreateMoreBadges", kind: "message", T: BalancesActionPermission, repeated: true },
    { no: 9, name: "canUpdateBadgeMetadata", kind: "message", T: TimedUpdateWithBadgeIdsPermission, repeated: true },
    { no: 10, name: "canUpdateCollectionApprovals", kind: "message", T: CollectionApprovalPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionPermissions {
    return new CollectionPermissions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionPermissions {
    return new CollectionPermissions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionPermissions {
    return new CollectionPermissions().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionPermissions | PlainMessage<CollectionPermissions> | undefined, b: CollectionPermissions | PlainMessage<CollectionPermissions> | undefined): boolean {
    return proto3.util.equals(CollectionPermissions, a, b);
  }
}

/**
 *
 * UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).
 *
 * See CollectionPermissions for more details on the different types of permissions.
 *
 * canUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,
 * but certain fields are removed because they are not relevant to the user.
 *
 * @generated from message badges.UserPermissions
 */
export class UserPermissions extends Message<UserPermissions> {
  /**
   * Permissions related to updating the user's approved outgoing transfers.
   *
   * @generated from field: repeated badges.UserOutgoingApprovalPermission canUpdateOutgoingApprovals = 1;
   */
  canUpdateOutgoingApprovals: UserOutgoingApprovalPermission[] = [];

  /**
   * Permissions related to updating the user's approved incoming transfers.
   *
   * @generated from field: repeated badges.UserIncomingApprovalPermission canUpdateIncomingApprovals = 2;
   */
  canUpdateIncomingApprovals: UserIncomingApprovalPermission[] = [];

  /**
   * Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).
   *
   * @generated from field: repeated badges.ActionPermission canUpdateAutoApproveSelfInitiatedOutgoingTransfers = 3;
   */
  canUpdateAutoApproveSelfInitiatedOutgoingTransfers: ActionPermission[] = [];

  /**
   * Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).
   *
   * @generated from field: repeated badges.ActionPermission canUpdateAutoApproveSelfInitiatedIncomingTransfers = 4;
   */
  canUpdateAutoApproveSelfInitiatedIncomingTransfers: ActionPermission[] = [];

  constructor(data?: PartialMessage<UserPermissions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserPermissions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "canUpdateOutgoingApprovals", kind: "message", T: UserOutgoingApprovalPermission, repeated: true },
    { no: 2, name: "canUpdateIncomingApprovals", kind: "message", T: UserIncomingApprovalPermission, repeated: true },
    { no: 3, name: "canUpdateAutoApproveSelfInitiatedOutgoingTransfers", kind: "message", T: ActionPermission, repeated: true },
    { no: 4, name: "canUpdateAutoApproveSelfInitiatedIncomingTransfers", kind: "message", T: ActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPermissions {
    return new UserPermissions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPermissions {
    return new UserPermissions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPermissions {
    return new UserPermissions().fromJsonString(jsonString, options);
  }

  static equals(a: UserPermissions | PlainMessage<UserPermissions> | undefined, b: UserPermissions | PlainMessage<UserPermissions> | undefined): boolean {
    return proto3.util.equals(UserPermissions, a, b);
  }
}

/**
 *
 * CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.
 *
 * Each transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.
 * For a transfer to match, we need to match ALL of the fields in the combination. 
 * These are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.
 * AddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). 
 *
 * TimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?
 * permanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?
 *
 * Ex: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", 10, 1000).
 * We would check to find the FIRST CollectionApprovalPermission that matches this combination.
 * If we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).
 *
 * Ex: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set
 * the combination ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", "All Transfer Times", 1) to always be forbidden at all timelineTimes.
 *
 * @generated from message badges.CollectionApprovalPermission
 */
export class CollectionApprovalPermission extends Message<CollectionApprovalPermission> {
  /**
   * Identifier for the sender list.
   *
   * @generated from field: string fromListId = 1;
   */
  fromListId = "";

  /**
   * Identifier for the recipient list.
   *
   * @generated from field: string toListId = 2;
   */
  toListId = "";

  /**
   * Identifier for the initiator list (who is approved?).
   *
   * @generated from field: string initiatedByListId = 3;
   */
  initiatedByListId = "";

  /**
   * Specifies the times when the transfer can occur.
   *
   * @generated from field: repeated badges.UintRange transferTimes = 4;
   */
  transferTimes: UintRange[] = [];

  /**
   * Specifies the badge IDs involved in the transfer.
   *
   * @generated from field: repeated badges.UintRange badgeIds = 5;
   */
  badgeIds: UintRange[] = [];

  /**
   * Specifies the ownership times for the badges in the transfer.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 6;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * Identifier for the amountTrackerId. You can use "All" or "!trackerId" for shorthand.
   * If you use "All", this approval will match to all amountTrackerIds.
   * If you use "!trackerId", this approval will match to all amountTrackerIds except for trackerId.
   * If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
   *
   * @generated from field: string amountTrackerId = 7;
   */
  amountTrackerId = "";

  /**
   * Identifier for the challengeTrackerId. You can use "All" or "!trackerId" for shorthand.
   * If you use "All", this approval will match to all challengeTrackerIds.
   * If you use "!trackerId", this approval will match to all challengeTrackerIds except for trackerId.
   * If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
   *
   * @generated from field: string challengeTrackerId = 8;
   */
  challengeTrackerId = "";

  /**
   * Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyPermittedTimes = 9;
   */
  permanentlyPermittedTimes: UintRange[] = [];

  /**
   * Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyForbiddenTimes = 10;
   */
  permanentlyForbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<CollectionApprovalPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionApprovalPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "initiatedByListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 7, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "permanentlyPermittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 10, name: "permanentlyForbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionApprovalPermission {
    return new CollectionApprovalPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionApprovalPermission {
    return new CollectionApprovalPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionApprovalPermission {
    return new CollectionApprovalPermission().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionApprovalPermission | PlainMessage<CollectionApprovalPermission> | undefined, b: CollectionApprovalPermission | PlainMessage<CollectionApprovalPermission> | undefined): boolean {
    return proto3.util.equals(CollectionApprovalPermission, a, b);
  }
}

/**
 *
 * UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.
 *
 * @generated from message badges.UserOutgoingApprovalPermission
 */
export class UserOutgoingApprovalPermission extends Message<UserOutgoingApprovalPermission> {
  /**
   * Identifier for the recipient list.
   *
   * @generated from field: string toListId = 1;
   */
  toListId = "";

  /**
   * Identifier for the initiator list (who is approved?).
   *
   * @generated from field: string initiatedByListId = 2;
   */
  initiatedByListId = "";

  /**
   * Specifies the times when the transfer can occur.
   *
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * Specifies the badge IDs involved in the transfer.
   *
   * @generated from field: repeated badges.UintRange badgeIds = 4;
   */
  badgeIds: UintRange[] = [];

  /**
   * Specifies the ownership times for the badges in the transfer.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * Identifier for the amountTrackerId. You can use "All" or "!trackerId" for shorthand.
   * If you use "All", this approval will match to all amountTrackerIds.
   * If you use "!trackerId", this approval will match to all amountTrackerIds except for trackerId.
   * If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
   *
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * Identifier for the challengeTrackerId. You can use "All" or "!trackerId" for shorthand.
   * If you use "All", this approval will match to all challengeTrackerIds.
   * If you use "!trackerId", this approval will match to all challengeTrackerIds except for trackerId.
   * If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
   *
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyPermittedTimes = 8;
   */
  permanentlyPermittedTimes: UintRange[] = [];

  /**
   * Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyForbiddenTimes = 9;
   */
  permanentlyForbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<UserOutgoingApprovalPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserOutgoingApprovalPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "toListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "permanentlyPermittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 9, name: "permanentlyForbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserOutgoingApprovalPermission {
    return new UserOutgoingApprovalPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserOutgoingApprovalPermission {
    return new UserOutgoingApprovalPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserOutgoingApprovalPermission {
    return new UserOutgoingApprovalPermission().fromJsonString(jsonString, options);
  }

  static equals(a: UserOutgoingApprovalPermission | PlainMessage<UserOutgoingApprovalPermission> | undefined, b: UserOutgoingApprovalPermission | PlainMessage<UserOutgoingApprovalPermission> | undefined): boolean {
    return proto3.util.equals(UserOutgoingApprovalPermission, a, b);
  }
}

/**
 *
 * UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.
 *
 * See CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.
 *
 * @generated from message badges.UserIncomingApprovalPermission
 */
export class UserIncomingApprovalPermission extends Message<UserIncomingApprovalPermission> {
  /**
   * Identifier for the sender list.
   *
   * @generated from field: string fromListId = 1;
   */
  fromListId = "";

  /**
   * Identifier for the initiator list (who is approved?).
   *
   * @generated from field: string initiatedByListId = 2;
   */
  initiatedByListId = "";

  /**
   * Specifies the times when the transfer can occur.
   *
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * Specifies the badge IDs involved in the transfer.
   *
   * @generated from field: repeated badges.UintRange badgeIds = 4;
   */
  badgeIds: UintRange[] = [];

  /**
   * Specifies the ownership times for the badges in the transfer.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * Identifier for the amountTrackerId. You can use "All" or "!trackerId" for shorthand.
   * If you use "All", this approval will match to all amountTrackerIds.
   * If you use "!trackerId", this approval will match to all amountTrackerIds except for trackerId.
   * If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
   *
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * Identifier for the challengeTrackerId. You can use "All" or "!trackerId" for shorthand.
   * If you use "All", this approval will match to all challengeTrackerIds.
   * If you use "!trackerId", this approval will match to all challengeTrackerIds except for trackerId.
   * If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
   *
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyPermittedTimes = 8;
   */
  permanentlyPermittedTimes: UintRange[] = [];

  /**
   * Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyForbiddenTimes = 9;
   */
  permanentlyForbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<UserIncomingApprovalPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserIncomingApprovalPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "permanentlyPermittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 9, name: "permanentlyForbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserIncomingApprovalPermission {
    return new UserIncomingApprovalPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserIncomingApprovalPermission {
    return new UserIncomingApprovalPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserIncomingApprovalPermission {
    return new UserIncomingApprovalPermission().fromJsonString(jsonString, options);
  }

  static equals(a: UserIncomingApprovalPermission | PlainMessage<UserIncomingApprovalPermission> | undefined, b: UserIncomingApprovalPermission | PlainMessage<UserIncomingApprovalPermission> | undefined): boolean {
    return proto3.util.equals(UserIncomingApprovalPermission, a, b);
  }
}

/**
 *
 * BalancesActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.
 * Currently, this is only used for creating new badges.
 *
 * Ex: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, 
 * you could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
 *
 * @generated from message badges.BalancesActionPermission
 */
export class BalancesActionPermission extends Message<BalancesActionPermission> {
  /**
   * Specifies the badge IDs involved in the transfer.
   *
   * @generated from field: repeated badges.UintRange badgeIds = 1;
   */
  badgeIds: UintRange[] = [];

  /**
   * Specifies the ownership times for the badges in the transfer.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 2;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyPermittedTimes = 3;
   */
  permanentlyPermittedTimes: UintRange[] = [];

  /**
   * Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyForbiddenTimes = 4;
   */
  permanentlyForbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<BalancesActionPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BalancesActionPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 2, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 3, name: "permanentlyPermittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "permanentlyForbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BalancesActionPermission {
    return new BalancesActionPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BalancesActionPermission {
    return new BalancesActionPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BalancesActionPermission {
    return new BalancesActionPermission().fromJsonString(jsonString, options);
  }

  static equals(a: BalancesActionPermission | PlainMessage<BalancesActionPermission> | undefined, b: BalancesActionPermission | PlainMessage<BalancesActionPermission> | undefined): boolean {
    return proto3.util.equals(BalancesActionPermission, a, b);
  }
}

/**
 *
 * ActionPermission defines the permissions for performing an action.
 *
 * This is simple and straightforward as the only thing we need to check is the permitted/forbidden times.
 *
 * @generated from message badges.ActionPermission
 */
export class ActionPermission extends Message<ActionPermission> {
  /**
   * Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyPermittedTimes = 1;
   */
  permanentlyPermittedTimes: UintRange[] = [];

  /**
   * Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyForbiddenTimes = 2;
   */
  permanentlyForbiddenTimes: UintRange[] = [];

  constructor(data?: PartialMessage<ActionPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ActionPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "permanentlyPermittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 2, name: "permanentlyForbiddenTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActionPermission {
    return new ActionPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActionPermission {
    return new ActionPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActionPermission {
    return new ActionPermission().fromJsonString(jsonString, options);
  }

  static equals(a: ActionPermission | PlainMessage<ActionPermission> | undefined, b: ActionPermission | PlainMessage<ActionPermission> | undefined): boolean {
    return proto3.util.equals(ActionPermission, a, b);
  }
}

/**
 *
 * TimedUpdatePermission defines the permissions for updating a timeline-based field.
 *
 * Ex: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,
 * you could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
 *
 * @generated from message badges.TimedUpdatePermission
 */
export class TimedUpdatePermission extends Message<TimedUpdatePermission> {
  /**
   * Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyPermittedTimes = 1;
   */
  permanentlyPermittedTimes: UintRange[] = [];

  /**
   * Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyForbiddenTimes = 2;
   */
  permanentlyForbiddenTimes: UintRange[] = [];

  /**
   * Specifies the times when the timeline-based field is a specific value.
   *
   * @generated from field: repeated badges.UintRange timelineTimes = 3;
   */
  timelineTimes: UintRange[] = [];

  constructor(data?: PartialMessage<TimedUpdatePermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.TimedUpdatePermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "permanentlyPermittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 2, name: "permanentlyForbiddenTimes", kind: "message", T: UintRange, repeated: true },
    { no: 3, name: "timelineTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimedUpdatePermission {
    return new TimedUpdatePermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimedUpdatePermission {
    return new TimedUpdatePermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimedUpdatePermission {
    return new TimedUpdatePermission().fromJsonString(jsonString, options);
  }

  static equals(a: TimedUpdatePermission | PlainMessage<TimedUpdatePermission> | undefined, b: TimedUpdatePermission | PlainMessage<TimedUpdatePermission> | undefined): boolean {
    return proto3.util.equals(TimedUpdatePermission, a, b);
  }
}

/**
 *
 * TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.
 *
 * Ex: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,
 * you could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
 *
 * @generated from message badges.TimedUpdateWithBadgeIdsPermission
 */
export class TimedUpdateWithBadgeIdsPermission extends Message<TimedUpdateWithBadgeIdsPermission> {
  /**
   * Specifies the badge IDs involved in the transfer.
   *
   * @generated from field: repeated badges.UintRange badgeIds = 1;
   */
  badgeIds: UintRange[] = [];

  /**
   * Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyPermittedTimes = 2;
   */
  permanentlyPermittedTimes: UintRange[] = [];

  /**
   * Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
   *
   * @generated from field: repeated badges.UintRange permanentlyForbiddenTimes = 3;
   */
  permanentlyForbiddenTimes: UintRange[] = [];

  /**
   * Specifies the times when the timeline-based field is a specific value.
   *
   * @generated from field: repeated badges.UintRange timelineTimes = 4;
   */
  timelineTimes: UintRange[] = [];

  constructor(data?: PartialMessage<TimedUpdateWithBadgeIdsPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.TimedUpdateWithBadgeIdsPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "badgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 2, name: "permanentlyPermittedTimes", kind: "message", T: UintRange, repeated: true },
    { no: 3, name: "permanentlyForbiddenTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "timelineTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimedUpdateWithBadgeIdsPermission {
    return new TimedUpdateWithBadgeIdsPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimedUpdateWithBadgeIdsPermission {
    return new TimedUpdateWithBadgeIdsPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimedUpdateWithBadgeIdsPermission {
    return new TimedUpdateWithBadgeIdsPermission().fromJsonString(jsonString, options);
  }

  static equals(a: TimedUpdateWithBadgeIdsPermission | PlainMessage<TimedUpdateWithBadgeIdsPermission> | undefined, b: TimedUpdateWithBadgeIdsPermission | PlainMessage<TimedUpdateWithBadgeIdsPermission> | undefined): boolean {
    return proto3.util.equals(TimedUpdateWithBadgeIdsPermission, a, b);
  }
}

