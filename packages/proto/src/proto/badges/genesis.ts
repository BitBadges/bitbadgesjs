// @ts-nocheck
/* eslint-disable */
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: badges/genesis.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../gogoproto/gogo";
import * as dependency_2 from "./params";
import * as dependency_3 from "./collections";
import * as dependency_4 from "./balances";
import * as dependency_5 from "./transfers";
import * as dependency_6 from "./address_mappings";
import * as pb_1 from "google-protobuf";
export namespace bitbadges.bitbadgeschain.badges {
  export class GenesisState extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      params?: dependency_2.bitbadges.bitbadgeschain.badges.Params;
      port_id?: string;
      collections?: dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection[];
      nextCollectionId?: string;
      balances?: dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore[];
      balanceStoreKeys?: string[];
      numUsedForMerkleChallenges?: string[];
      numUsedForMerkleChallengesStoreKeys?: string[];
      addressMappings?: dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping[];
      approvalsTrackers?: dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker[];
      approvalsTrackerStoreKeys?: string[];
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 5, 6, 7, 8, 9, 10, 11], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("params" in data && data.params != undefined) {
          this.params = data.params;
        }
        if ("port_id" in data && data.port_id != undefined) {
          this.port_id = data.port_id;
        }
        if ("collections" in data && data.collections != undefined) {
          this.collections = data.collections;
        }
        if ("nextCollectionId" in data && data.nextCollectionId != undefined) {
          this.nextCollectionId = data.nextCollectionId;
        }
        if ("balances" in data && data.balances != undefined) {
          this.balances = data.balances;
        }
        if ("balanceStoreKeys" in data && data.balanceStoreKeys != undefined) {
          this.balanceStoreKeys = data.balanceStoreKeys;
        }
        if ("numUsedForMerkleChallenges" in data && data.numUsedForMerkleChallenges != undefined) {
          this.numUsedForMerkleChallenges = data.numUsedForMerkleChallenges;
        }
        if ("numUsedForMerkleChallengesStoreKeys" in data && data.numUsedForMerkleChallengesStoreKeys != undefined) {
          this.numUsedForMerkleChallengesStoreKeys = data.numUsedForMerkleChallengesStoreKeys;
        }
        if ("addressMappings" in data && data.addressMappings != undefined) {
          this.addressMappings = data.addressMappings;
        }
        if ("approvalsTrackers" in data && data.approvalsTrackers != undefined) {
          this.approvalsTrackers = data.approvalsTrackers;
        }
        if ("approvalsTrackerStoreKeys" in data && data.approvalsTrackerStoreKeys != undefined) {
          this.approvalsTrackerStoreKeys = data.approvalsTrackerStoreKeys;
        }
      }
    }
    get params() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.Params, 1) as dependency_2.bitbadges.bitbadgeschain.badges.Params;
    }
    set params(value: dependency_2.bitbadges.bitbadgeschain.badges.Params) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_params() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get port_id() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set port_id(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get collections() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection, 3) as dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection[];
    }
    set collections(value: dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection[]) {
      pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    get nextCollectionId() {
      return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set nextCollectionId(value: string) {
      pb_1.Message.setField(this, 4, value);
    }
    get balances() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore, 5) as dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore[];
    }
    set balances(value: dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore[]) {
      pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    get balanceStoreKeys() {
      return pb_1.Message.getFieldWithDefault(this, 6, []) as string[];
    }
    set balanceStoreKeys(value: string[]) {
      pb_1.Message.setField(this, 6, value);
    }
    get numUsedForMerkleChallenges() {
      return pb_1.Message.getFieldWithDefault(this, 7, []) as string[];
    }
    set numUsedForMerkleChallenges(value: string[]) {
      pb_1.Message.setField(this, 7, value);
    }
    get numUsedForMerkleChallengesStoreKeys() {
      return pb_1.Message.getFieldWithDefault(this, 8, []) as string[];
    }
    set numUsedForMerkleChallengesStoreKeys(value: string[]) {
      pb_1.Message.setField(this, 8, value);
    }
    get addressMappings() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping, 9) as dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping[];
    }
    set addressMappings(value: dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping[]) {
      pb_1.Message.setRepeatedWrapperField(this, 9, value);
    }
    get approvalsTrackers() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker, 10) as dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker[];
    }
    set approvalsTrackers(value: dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker[]) {
      pb_1.Message.setRepeatedWrapperField(this, 10, value);
    }
    get approvalsTrackerStoreKeys() {
      return pb_1.Message.getFieldWithDefault(this, 11, []) as string[];
    }
    set approvalsTrackerStoreKeys(value: string[]) {
      pb_1.Message.setField(this, 11, value);
    }
    static fromObject(data: {
      params?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.Params.prototype.toObject>;
      port_id?: string;
      collections?: ReturnType<typeof dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection.prototype.toObject>[];
      nextCollectionId?: string;
      balances?: ReturnType<typeof dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore.prototype.toObject>[];
      balanceStoreKeys?: string[];
      numUsedForMerkleChallenges?: string[];
      numUsedForMerkleChallengesStoreKeys?: string[];
      addressMappings?: ReturnType<typeof dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping.prototype.toObject>[];
      approvalsTrackers?: ReturnType<typeof dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker.prototype.toObject>[];
      approvalsTrackerStoreKeys?: string[];
    }): GenesisState {
      const message = new GenesisState({});
      if (data.params != null) {
        message.params = dependency_2.bitbadges.bitbadgeschain.badges.Params.fromObject(data.params);
      }
      if (data.port_id != null) {
        message.port_id = data.port_id;
      }
      if (data.collections != null) {
        message.collections = data.collections.map(item => dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection.fromObject(item));
      }
      if (data.nextCollectionId != null) {
        message.nextCollectionId = data.nextCollectionId;
      }
      if (data.balances != null) {
        message.balances = data.balances.map(item => dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore.fromObject(item));
      }
      if (data.balanceStoreKeys != null) {
        message.balanceStoreKeys = data.balanceStoreKeys;
      }
      if (data.numUsedForMerkleChallenges != null) {
        message.numUsedForMerkleChallenges = data.numUsedForMerkleChallenges;
      }
      if (data.numUsedForMerkleChallengesStoreKeys != null) {
        message.numUsedForMerkleChallengesStoreKeys = data.numUsedForMerkleChallengesStoreKeys;
      }
      if (data.addressMappings != null) {
        message.addressMappings = data.addressMappings.map(item => dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping.fromObject(item));
      }
      if (data.approvalsTrackers != null) {
        message.approvalsTrackers = data.approvalsTrackers.map(item => dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker.fromObject(item));
      }
      if (data.approvalsTrackerStoreKeys != null) {
        message.approvalsTrackerStoreKeys = data.approvalsTrackerStoreKeys;
      }
      return message;
    }
    toObject() {
      const data: {
        params?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.Params.prototype.toObject>;
        port_id?: string;
        collections?: ReturnType<typeof dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection.prototype.toObject>[];
        nextCollectionId?: string;
        balances?: ReturnType<typeof dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore.prototype.toObject>[];
        balanceStoreKeys?: string[];
        numUsedForMerkleChallenges?: string[];
        numUsedForMerkleChallengesStoreKeys?: string[];
        addressMappings?: ReturnType<typeof dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping.prototype.toObject>[];
        approvalsTrackers?: ReturnType<typeof dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker.prototype.toObject>[];
        approvalsTrackerStoreKeys?: string[];
      } = {};
      if (this.params != null) {
        data.params = this.params.toObject();
      }
      if (this.port_id != null) {
        data.port_id = this.port_id;
      }
      if (this.collections != null) {
        data.collections = this.collections.map((item: dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection) => item.toObject());
      }
      if (this.nextCollectionId != null) {
        data.nextCollectionId = this.nextCollectionId;
      }
      if (this.balances != null) {
        data.balances = this.balances.map((item: dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore) => item.toObject());
      }
      if (this.balanceStoreKeys != null) {
        data.balanceStoreKeys = this.balanceStoreKeys;
      }
      if (this.numUsedForMerkleChallenges != null) {
        data.numUsedForMerkleChallenges = this.numUsedForMerkleChallenges;
      }
      if (this.numUsedForMerkleChallengesStoreKeys != null) {
        data.numUsedForMerkleChallengesStoreKeys = this.numUsedForMerkleChallengesStoreKeys;
      }
      if (this.addressMappings != null) {
        data.addressMappings = this.addressMappings.map((item: dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping) => item.toObject());
      }
      if (this.approvalsTrackers != null) {
        data.approvalsTrackers = this.approvalsTrackers.map((item: dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker) => item.toObject());
      }
      if (this.approvalsTrackerStoreKeys != null) {
        data.approvalsTrackerStoreKeys = this.approvalsTrackerStoreKeys;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_params)
        writer.writeMessage(1, this.params, () => this.params.serialize(writer));
      if (this.port_id.length)
        writer.writeString(2, this.port_id);
      if (this.collections.length)
        writer.writeRepeatedMessage(3, this.collections, (item: dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection) => item.serialize(writer));
      if (this.nextCollectionId.length)
        writer.writeString(4, this.nextCollectionId);
      if (this.balances.length)
        writer.writeRepeatedMessage(5, this.balances, (item: dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore) => item.serialize(writer));
      if (this.balanceStoreKeys.length)
        writer.writeRepeatedString(6, this.balanceStoreKeys);
      if (this.numUsedForMerkleChallenges.length)
        writer.writeRepeatedString(7, this.numUsedForMerkleChallenges);
      if (this.numUsedForMerkleChallengesStoreKeys.length)
        writer.writeRepeatedString(8, this.numUsedForMerkleChallengesStoreKeys);
      if (this.addressMappings.length)
        writer.writeRepeatedMessage(9, this.addressMappings, (item: dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping) => item.serialize(writer));
      if (this.approvalsTrackers.length)
        writer.writeRepeatedMessage(10, this.approvalsTrackers, (item: dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker) => item.serialize(writer));
      if (this.approvalsTrackerStoreKeys.length)
        writer.writeRepeatedString(11, this.approvalsTrackerStoreKeys);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GenesisState {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GenesisState();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.params, () => message.params = dependency_2.bitbadges.bitbadgeschain.badges.Params.deserialize(reader));
            break;
          case 2:
            message.port_id = reader.readString();
            break;
          case 3:
            reader.readMessage(message.collections, () => pb_1.Message.addToRepeatedWrapperField(message, 3, dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection.deserialize(reader), dependency_3.bitbadges.bitbadgeschain.badges.BadgeCollection));
            break;
          case 4:
            message.nextCollectionId = reader.readString();
            break;
          case 5:
            reader.readMessage(message.balances, () => pb_1.Message.addToRepeatedWrapperField(message, 5, dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore.deserialize(reader), dependency_5.bitbadges.bitbadgeschain.badges.UserBalanceStore));
            break;
          case 6:
            pb_1.Message.addToRepeatedField(message, 6, reader.readString());
            break;
          case 7:
            pb_1.Message.addToRepeatedField(message, 7, reader.readString());
            break;
          case 8:
            pb_1.Message.addToRepeatedField(message, 8, reader.readString());
            break;
          case 9:
            reader.readMessage(message.addressMappings, () => pb_1.Message.addToRepeatedWrapperField(message, 9, dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping.deserialize(reader), dependency_6.bitbadges.bitbadgeschain.badges.AddressMapping));
            break;
          case 10:
            reader.readMessage(message.approvalsTrackers, () => pb_1.Message.addToRepeatedWrapperField(message, 10, dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker.deserialize(reader), dependency_5.bitbadges.bitbadgeschain.badges.ApprovalsTracker));
            break;
          case 11:
            pb_1.Message.addToRepeatedField(message, 11, reader.readString());
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): GenesisState {
      return GenesisState.deserialize(bytes);
    }
  }
}
