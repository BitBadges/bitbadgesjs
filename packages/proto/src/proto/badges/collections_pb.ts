// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file badges/collections.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { BadgeMetadataTimeline, CollectionMetadataTimeline, CustomDataTimeline, IsArchivedTimeline, ManagerTimeline, OffChainBalancesMetadataTimeline, StandardsTimeline } from "./timelines_pb.js";
import { CollectionPermissions, UserPermissions } from "./permissions_pb.js";
import { CollectionApproval, UserIncomingApproval, UserOutgoingApproval } from "./transfers_pb.js";

/**
 *
 * A BadgeCollection is the top-level object for a collection of badges.
 * It defines everything about the collection, such as the manager, metadata, etc.
 *
 * All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e., the first collection has ID 1).
 *
 * All collections also have a manager who is responsible for managing the collection.
 * They can be granted certain permissions, such as the ability to mint new badges.
 *
 * Certain fields are timeline-based, which means they may have different values at different block heights.
 * We fetch the value according to the current time.
 * For example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.
 *
 * Collections may have different balance types: standard vs. off-chain vs. inherited.
 *
 * See documentation for more details.
 *
 * @generated from message badges.BadgeCollection
 */
export class BadgeCollection extends Message<BadgeCollection> {
  /**
   * The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  /**
   * The metadata for the collection itself, which can vary over time.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 2;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * The metadata for each badge in the collection, also subject to changes over time.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 3;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * The type of balances this collection uses ("Standard", "Off-Chain - Indexed", or "Inherited").
   *
   * @generated from field: string balancesType = 4;
   */
  balancesType = "";

  /**
   * Metadata for fetching balances for collections with off-chain balances, subject to changes over time.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 5;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * An arbitrary field that can store any data, subject to changes over time.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 7;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * The address of the manager of this collection, subject to changes over time.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 8;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Permissions that define what the manager of the collection can do or not do.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 9;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Transferability of the collection for collections with standard balances, subject to changes over time.
   * Overrides user approvals for a transfer if specified.
   * Transfer must satisfy both user and collection-level approvals.
   * Not applicable for off-chain or inherited balances.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 10;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards that define how to interpret the fields of the collection, subject to changes over time.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 11;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Whether the collection is archived or not, subject to changes over time.
   * When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 12;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Default user-approved outgoing transfers for an uninitialized user balance.
   *
   * @generated from field: repeated badges.UserOutgoingApproval defaultUserOutgoingApprovals = 14;
   */
  defaultUserOutgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * Default user-approved incoming transfers for an uninitialized user balance.
   * Ex: Can be set to disallow all incoming transfers by default, allowing users to opt-in to receiving badges.
   *
   * @generated from field: repeated badges.UserIncomingApproval defaultUserIncomingApprovals = 15;
   */
  defaultUserIncomingApprovals: UserIncomingApproval[] = [];

  /**
   * Default user permissions for an uninitialized user balance.
   *
   * @generated from field: badges.UserPermissions defaultUserPermissions = 16;
   */
  defaultUserPermissions?: UserPermissions;

  /**
   * Whether self-initiated outgoing transfers are auto-approved by default.
   *
   * @generated from field: bool defaultAutoApproveSelfInitiatedOutgoingTransfers = 17;
   */
  defaultAutoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Whether self-initiated incoming transfers are auto-approved by default.
   *
   * @generated from field: bool defaultAutoApproveSelfInitiatedIncomingTransfers = 18;
   */
  defaultAutoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * The user or entity who created the badge collection.
   *
   * @generated from field: string createdBy = 19;
   */
  createdBy = "";

  constructor(data?: PartialMessage<BadgeCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BadgeCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 3, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 4, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 7, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 8, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 9, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 10, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 11, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 12, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 14, name: "defaultUserOutgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 15, name: "defaultUserIncomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 16, name: "defaultUserPermissions", kind: "message", T: UserPermissions },
    { no: 17, name: "defaultAutoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "defaultAutoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "createdBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadgeCollection {
    return new BadgeCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadgeCollection {
    return new BadgeCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadgeCollection {
    return new BadgeCollection().fromJsonString(jsonString, options);
  }

  static equals(a: BadgeCollection | PlainMessage<BadgeCollection> | undefined, b: BadgeCollection | PlainMessage<BadgeCollection> | undefined): boolean {
    return proto3.util.equals(BadgeCollection, a, b);
  }
}
