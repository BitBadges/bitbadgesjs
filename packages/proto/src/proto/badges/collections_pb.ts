// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file badges/collections.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { BadgeMetadataTimeline, CollectionMetadataTimeline, CustomDataTimeline, IsArchivedTimeline, ManagerTimeline, OffChainBalancesMetadataTimeline, StandardsTimeline } from "./timelines_pb.js";
import { CollectionPermissions, UserPermissions } from "./permissions_pb.js";
import { CollectionApproval, UserIncomingApproval, UserOutgoingApproval } from "./transfers_pb.js";

/**
 * A BadgeCollection is the top level object for a collection of badges. 
 * It defines everything about the collection, such as the manager, metadata, etc.
 *
 * All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. first collection has ID 1).
 *
 * All collections also have a manager who is responsible for managing the collection. 
 * They can be granted certain permissions, such as the ability to mint new badges.
 *
 * Certain fields are timeline-based, which means they may have different values at different block heights. 
 * We fetch the value according to the current time.
 * For example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.
 *
 * Collections may have different balance types: standard vs off-chain vs inherited. See documentation for differences.
 *
 * @generated from message badges.BadgeCollection
 */
export class BadgeCollection extends Message<BadgeCollection> {
  /**
   * The collectionId is the unique identifier for this collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  /**
   * The collection metadata is the metadata for the collection itself.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 2;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * The badge metadata is the metadata for each badge in the collection.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 3;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * The balancesType is the type of balances this collection uses (standard, off-chain, or inherited).
   *
   * @generated from field: string balancesType = 4;
   */
  balancesType = "";

  /**
   * The off-chain balances metadata defines where to fetch the balances for collections with off-chain balances.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 5;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * The custom data field is an arbitrary field that can be used to store any data.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 7;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * The manager is the address of the manager of this collection.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 8;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * The permissions define what the manager of the collection can do or not do.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 9;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * The approved transfers defines the transferability of the collection for collections with standard balances.
   * This defines it on a collection-level. All transfers must be explicitly allowed on the collection-level, or else, they will fail.
   *
   * Collection approved transfers can optionally specify to override the user approvals for a transfer (e.g. forcefully revoke a badge).
   * If user approvals are not overriden, then a transfer must also satisfy the From user's approved outgoing transfers and the To user's approved incoming transfers.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 10;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards allow us to define a standard for the collection. This lets others know how to interpret the fields of the collection.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 11;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * The isArchivedTimeline defines whether the collection is archived or not. 
   * When a collection is archived, it is read-only and no transactions can be processed.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 12;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * The defaultUserOutgoingApprovals defines the default user approved outgoing transfers for an uninitialized user balance. 
   * The user can change this value at any time.
   *
   * @generated from field: repeated badges.UserOutgoingApproval defaultUserOutgoingApprovals = 14;
   */
  defaultUserOutgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * The defaultUserIncomingApprovals defines the default user approved incoming transfers for an uninitialized user balance.
   * The user can change this value at any time.
   *
   * Ex: Set this to disallow all incoming transfers by default, making the user have to opt-in to receiving the badge.
   *
   * @generated from field: repeated badges.UserIncomingApproval defaultUserIncomingApprovals = 15;
   */
  defaultUserIncomingApprovals: UserIncomingApproval[] = [];

  /**
   * @generated from field: badges.UserPermissions defaultUserPermissions = 16;
   */
  defaultUserPermissions?: UserPermissions;

  /**
   * @generated from field: bool defaultAutoApproveSelfInitiatedOutgoingTransfers = 17;
   */
  defaultAutoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * @generated from field: bool defaultAutoApproveSelfInitiatedIncomingTransfers = 18;
   */
  defaultAutoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * @generated from field: string createdBy = 19;
   */
  createdBy = "";

  constructor(data?: PartialMessage<BadgeCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BadgeCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 3, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 4, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 7, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 8, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 9, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 10, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 11, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 12, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 14, name: "defaultUserOutgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 15, name: "defaultUserIncomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 16, name: "defaultUserPermissions", kind: "message", T: UserPermissions },
    { no: 17, name: "defaultAutoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "defaultAutoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "createdBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadgeCollection {
    return new BadgeCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadgeCollection {
    return new BadgeCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadgeCollection {
    return new BadgeCollection().fromJsonString(jsonString, options);
  }

  static equals(a: BadgeCollection | PlainMessage<BadgeCollection> | undefined, b: BadgeCollection | PlainMessage<BadgeCollection> | undefined): boolean {
    return proto3.util.equals(BadgeCollection, a, b);
  }
}

