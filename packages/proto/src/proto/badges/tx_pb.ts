// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file badges/tx.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { CollectionApproval, Transfer, UserIncomingApproval, UserOutgoingApproval } from "./transfers_pb.js";
import { Balance } from "./balances_pb.js";
import { CollectionPermissions, UserPermissions } from "./permissions_pb.js";
import { BadgeMetadataTimeline, CollectionMetadataTimeline, CustomDataTimeline, IsArchivedTimeline, ManagerTimeline, OffChainBalancesMetadataTimeline, StandardsTimeline } from "./timelines_pb.js";
import { AddressMapping } from "./address_mappings_pb.js";

/**
 * Used for WASM bindings and JSON parsing
 *
 * @generated from message badges.BadgeCustomMsgType
 */
export class BadgeCustomMsgType extends Message<BadgeCustomMsgType> {
  /**
   * @generated from field: badges.MsgCreateAddressMappings createAddressMappingsMsg = 1;
   */
  createAddressMappingsMsg?: MsgCreateAddressMappings;

  /**
   * @generated from field: badges.MsgUniversalUpdateCollection universalUpdateCollectionMsg = 2;
   */
  universalUpdateCollectionMsg?: MsgUniversalUpdateCollection;

  /**
   * @generated from field: badges.MsgDeleteCollection deleteCollectionMsg = 3;
   */
  deleteCollectionMsg?: MsgDeleteCollection;

  /**
   * @generated from field: badges.MsgTransferBadges transferBadgesMsg = 4;
   */
  transferBadgesMsg?: MsgTransferBadges;

  /**
   * @generated from field: badges.MsgUpdateUserApprovals updateUserApprovalsMsg = 5;
   */
  updateUserApprovalsMsg?: MsgUpdateUserApprovals;

  /**
   * @generated from field: badges.MsgUpdateCollection updateCollectionMsg = 6;
   */
  updateCollectionMsg?: MsgUpdateCollection;

  /**
   * @generated from field: badges.MsgCreateCollection createCollectionMsg = 7;
   */
  createCollectionMsg?: MsgCreateCollection;

  constructor(data?: PartialMessage<BadgeCustomMsgType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BadgeCustomMsgType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "createAddressMappingsMsg", kind: "message", T: MsgCreateAddressMappings },
    { no: 2, name: "universalUpdateCollectionMsg", kind: "message", T: MsgUniversalUpdateCollection },
    { no: 3, name: "deleteCollectionMsg", kind: "message", T: MsgDeleteCollection },
    { no: 4, name: "transferBadgesMsg", kind: "message", T: MsgTransferBadges },
    { no: 5, name: "updateUserApprovalsMsg", kind: "message", T: MsgUpdateUserApprovals },
    { no: 6, name: "updateCollectionMsg", kind: "message", T: MsgUpdateCollection },
    { no: 7, name: "createCollectionMsg", kind: "message", T: MsgCreateCollection },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromJsonString(jsonString, options);
  }

  static equals(a: BadgeCustomMsgType | PlainMessage<BadgeCustomMsgType> | undefined, b: BadgeCustomMsgType | PlainMessage<BadgeCustomMsgType> | undefined): boolean {
    return proto3.util.equals(BadgeCustomMsgType, a, b);
  }
}

/**
 * MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.
 * It is a universal interface that can be used for both creating and updating collections.
 * We have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.
 *
 * @generated from message badges.MsgUniversalUpdateCollection
 */
export class MsgUniversalUpdateCollection extends Message<MsgUniversalUpdateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection (0 for new collection).
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Type of balances "Standard" or "Off-Chain".
   *
   * @generated from field: string balancesType = 3;
   */
  balancesType = "";

  /**
   * Default incoming approvals for newly initiated accounts.
   *
   * @generated from field: repeated badges.UserOutgoingApproval defaultOutgoingApprovals = 4;
   */
  defaultOutgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * Default outgoing approvals for newly initiated accounts.
   *
   * @generated from field: repeated badges.UserIncomingApproval defaultIncomingApprovals = 5;
   */
  defaultIncomingApprovals: UserIncomingApproval[] = [];

  /**
   * Balances to create for the collection. Will be sent to the "Mint" address.
   *
   * @generated from field: repeated badges.Balance badgesToCreate = 6;
   */
  badgesToCreate: Balance[] = [];

  /**
   * Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionPermissions = 7;
   */
  updateCollectionPermissions = false;

  /**
   * New collection permissions to set.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 8;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateManagerTimeline = 9;
   */
  updateManagerTimeline = false;

  /**
   * New manager timeline to set.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 10;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionMetadataTimeline = 11;
   */
  updateCollectionMetadataTimeline = false;

  /**
   * New collection metadata timeline to set.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 12;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateBadgeMetadataTimeline = 13;
   */
  updateBadgeMetadataTimeline = false;

  /**
   * New badge metadata timeline to set.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 14;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOffChainBalancesMetadataTimeline = 15;
   */
  updateOffChainBalancesMetadataTimeline = false;

  /**
   * New off-chain balances metadata timeline to set.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 16;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCustomDataTimeline = 17;
   */
  updateCustomDataTimeline = false;

  /**
   * New custom data timeline to set.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 18;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionApprovals = 21;
   */
  updateCollectionApprovals = false;

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 22;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateStandardsTimeline = 23;
   */
  updateStandardsTimeline = false;

  /**
   * New standards timeline to set.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 24;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIsArchivedTimeline = 27;
   */
  updateIsArchivedTimeline = false;

  /**
   * New isArchived timeline to set.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 28;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Default auto-approve setting for self-initiated outgoing transfers for newly initiated accounts.
   *
   * @generated from field: bool defaultAutoApproveSelfInitiatedOutgoingTransfers = 29;
   */
  defaultAutoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Default auto-approve setting for self-initiated incoming transfers for newly initiated accounts.
   *
   * @generated from field: bool defaultAutoApproveSelfInitiatedIncomingTransfers = 30;
   */
  defaultAutoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Default user permissions for newly initiated accounts.
   *
   * @generated from field: badges.UserPermissions defaultUserPermissions = 31;
   */
  defaultUserPermissions?: UserPermissions;

  constructor(data?: PartialMessage<MsgUniversalUpdateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "defaultOutgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 5, name: "defaultIncomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 6, name: "badgesToCreate", kind: "message", T: Balance, repeated: true },
    { no: 7, name: "updateCollectionPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 9, name: "updateManagerTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 11, name: "updateCollectionMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 13, name: "updateBadgeMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 15, name: "updateOffChainBalancesMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 17, name: "updateCustomDataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 21, name: "updateCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 23, name: "updateStandardsTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 24, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 27, name: "updateIsArchivedTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 28, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 29, name: "defaultAutoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 30, name: "defaultAutoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 31, name: "defaultUserPermissions", kind: "message", T: UserPermissions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollection | PlainMessage<MsgUniversalUpdateCollection> | undefined, b: MsgUniversalUpdateCollection | PlainMessage<MsgUniversalUpdateCollection> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollection, a, b);
  }
}

/**
 * MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.
 *
 * @generated from message badges.MsgUniversalUpdateCollectionResponse
 */
export class MsgUniversalUpdateCollectionResponse extends Message<MsgUniversalUpdateCollectionResponse> {
  /**
   * ID of the badge collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgUniversalUpdateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollectionResponse | PlainMessage<MsgUniversalUpdateCollectionResponse> | undefined, b: MsgUniversalUpdateCollectionResponse | PlainMessage<MsgUniversalUpdateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollectionResponse, a, b);
  }
}

/**
 * MsgUpdateCollection is used to update a collection.
 *
 * @generated from message badges.MsgUpdateCollection
 */
export class MsgUpdateCollection extends Message<MsgUpdateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection (0 for new collection).
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Balances to create for the collection. Will be sent to the "Mint" address.
   *
   * @generated from field: repeated badges.Balance badgesToCreate = 6;
   */
  badgesToCreate: Balance[] = [];

  /**
   * Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionPermissions = 7;
   */
  updateCollectionPermissions = false;

  /**
   * New collection permissions to set.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 8;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateManagerTimeline = 9;
   */
  updateManagerTimeline = false;

  /**
   * New manager timeline to set.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 10;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionMetadataTimeline = 11;
   */
  updateCollectionMetadataTimeline = false;

  /**
   * New collection metadata timeline to set.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 12;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateBadgeMetadataTimeline = 13;
   */
  updateBadgeMetadataTimeline = false;

  /**
   * New badge metadata timeline to set.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 14;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOffChainBalancesMetadataTimeline = 15;
   */
  updateOffChainBalancesMetadataTimeline = false;

  /**
   * New off-chain balances metadata timeline to set.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 16;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCustomDataTimeline = 17;
   */
  updateCustomDataTimeline = false;

  /**
   * New custom data timeline to set.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 18;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionApprovals = 21;
   */
  updateCollectionApprovals = false;

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 22;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateStandardsTimeline = 23;
   */
  updateStandardsTimeline = false;

  /**
   * New standards timeline to set.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 24;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIsArchivedTimeline = 27;
   */
  updateIsArchivedTimeline = false;

  /**
   * New isArchived timeline to set.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 28;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  constructor(data?: PartialMessage<MsgUpdateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "badgesToCreate", kind: "message", T: Balance, repeated: true },
    { no: 7, name: "updateCollectionPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 9, name: "updateManagerTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 11, name: "updateCollectionMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 13, name: "updateBadgeMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 15, name: "updateOffChainBalancesMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 17, name: "updateCustomDataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 21, name: "updateCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 23, name: "updateStandardsTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 24, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 27, name: "updateIsArchivedTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 28, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateCollection | PlainMessage<MsgUpdateCollection> | undefined, b: MsgUpdateCollection | PlainMessage<MsgUpdateCollection> | undefined): boolean {
    return proto3.util.equals(MsgUpdateCollection, a, b);
  }
}

/**
 * MsgUpdateCollectionResponse is the response to MsgUpdateCollection.
 *
 * @generated from message badges.MsgUpdateCollectionResponse
 */
export class MsgUpdateCollectionResponse extends Message<MsgUpdateCollectionResponse> {
  /**
   * ID of the badge collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgUpdateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateCollectionResponse | PlainMessage<MsgUpdateCollectionResponse> | undefined, b: MsgUpdateCollectionResponse | PlainMessage<MsgUpdateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateCollectionResponse, a, b);
  }
}

/**
 * MsgCreateCollection is used to create a new collection.
 *
 * @generated from message badges.MsgCreateCollection
 */
export class MsgCreateCollection extends Message<MsgCreateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * Type of balances "Standard" or "Off-Chain".
   *
   * @generated from field: string balancesType = 2;
   */
  balancesType = "";

  /**
   * User's approved transfers for each badge ID.
   *
   * @generated from field: repeated badges.UserOutgoingApproval defaultOutgoingApprovals = 3;
   */
  defaultOutgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * User's approved incoming transfers for each badge ID.
   *
   * @generated from field: repeated badges.UserIncomingApproval defaultIncomingApprovals = 4;
   */
  defaultIncomingApprovals: UserIncomingApproval[] = [];

  /**
   * Balances to create for the collection. Will be sent to the "Mint" address.
   *
   * @generated from field: repeated badges.Balance badgesToCreate = 5;
   */
  badgesToCreate: Balance[] = [];

  /**
   * Collection permissions.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 6;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Manager timeline entries.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 7;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Collection metadata timeline entries.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 8;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Badge metadata timeline entries.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 9;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Off-chain balances metadata timeline entries.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 10;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * Custom data timeline entries.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 11;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Collection approvals.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 12;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards timeline entries.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 13;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * isArchived timeline entries.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 14;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Default auto-approve setting for self-initiated outgoing transfers.
   *
   * @generated from field: bool defaultAutoApproveSelfInitiatedOutgoingTransfers = 15;
   */
  defaultAutoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Default auto-approve setting for self-initiated incoming transfers.
   *
   * @generated from field: bool defaultAutoApproveSelfInitiatedIncomingTransfers = 16;
   */
  defaultAutoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Default user permissions.
   *
   * @generated from field: badges.UserPermissions defaultUserPermissions = 17;
   */
  defaultUserPermissions?: UserPermissions;

  constructor(data?: PartialMessage<MsgCreateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "defaultOutgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 4, name: "defaultIncomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 5, name: "badgesToCreate", kind: "message", T: Balance, repeated: true },
    { no: 6, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 7, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 8, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 9, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 10, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 11, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 12, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 13, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 14, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 15, name: "defaultAutoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "defaultAutoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "defaultUserPermissions", kind: "message", T: UserPermissions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateCollection | PlainMessage<MsgCreateCollection> | undefined, b: MsgCreateCollection | PlainMessage<MsgCreateCollection> | undefined): boolean {
    return proto3.util.equals(MsgCreateCollection, a, b);
  }
}

/**
 * MsgCreateCollectionResponse is the response to MsgCreateCollection.
 *
 * @generated from message badges.MsgCreateCollectionResponse
 */
export class MsgCreateCollectionResponse extends Message<MsgCreateCollectionResponse> {
  /**
   * ID of the badge collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgCreateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateCollectionResponse | PlainMessage<MsgCreateCollectionResponse> | undefined, b: MsgCreateCollectionResponse | PlainMessage<MsgCreateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateCollectionResponse, a, b);
  }
}

/**
 * MsgCreateAddressMappings is used to create address mappings.
 *
 * @generated from message badges.MsgCreateAddressMappings
 */
export class MsgCreateAddressMappings extends Message<MsgCreateAddressMappings> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * Address mappings to create.
   *
   * @generated from field: repeated badges.AddressMapping addressMappings = 2;
   */
  addressMappings: AddressMapping[] = [];

  constructor(data?: PartialMessage<MsgCreateAddressMappings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateAddressMappings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "addressMappings", kind: "message", T: AddressMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateAddressMappings {
    return new MsgCreateAddressMappings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateAddressMappings {
    return new MsgCreateAddressMappings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateAddressMappings {
    return new MsgCreateAddressMappings().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateAddressMappings | PlainMessage<MsgCreateAddressMappings> | undefined, b: MsgCreateAddressMappings | PlainMessage<MsgCreateAddressMappings> | undefined): boolean {
    return proto3.util.equals(MsgCreateAddressMappings, a, b);
  }
}

/**
 * MsgCreateAddressMappingsResponse is the response to MsgCreateAddressMappings.
 *
 * @generated from message badges.MsgCreateAddressMappingsResponse
 */
export class MsgCreateAddressMappingsResponse extends Message<MsgCreateAddressMappingsResponse> {
  constructor(data?: PartialMessage<MsgCreateAddressMappingsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateAddressMappingsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateAddressMappingsResponse {
    return new MsgCreateAddressMappingsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateAddressMappingsResponse {
    return new MsgCreateAddressMappingsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateAddressMappingsResponse {
    return new MsgCreateAddressMappingsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateAddressMappingsResponse | PlainMessage<MsgCreateAddressMappingsResponse> | undefined, b: MsgCreateAddressMappingsResponse | PlainMessage<MsgCreateAddressMappingsResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateAddressMappingsResponse, a, b);
  }
}

/**
 * MsgTransferBadges is used to transfer badges.
 *
 * @generated from message badges.MsgTransferBadges
 */
export class MsgTransferBadges extends Message<MsgTransferBadges> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Transfers to execute.
   *
   * @generated from field: repeated badges.Transfer transfers = 3;
   */
  transfers: Transfer[] = [];

  constructor(data?: PartialMessage<MsgTransferBadges>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgTransferBadges";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transfers", kind: "message", T: Transfer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgTransferBadges {
    return new MsgTransferBadges().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgTransferBadges {
    return new MsgTransferBadges().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgTransferBadges {
    return new MsgTransferBadges().fromJsonString(jsonString, options);
  }

  static equals(a: MsgTransferBadges | PlainMessage<MsgTransferBadges> | undefined, b: MsgTransferBadges | PlainMessage<MsgTransferBadges> | undefined): boolean {
    return proto3.util.equals(MsgTransferBadges, a, b);
  }
}

/**
 * MsgTransferBadgesResponse is the response to MsgTransferBadges.
 *
 * @generated from message badges.MsgTransferBadgesResponse
 */
export class MsgTransferBadgesResponse extends Message<MsgTransferBadgesResponse> {
  constructor(data?: PartialMessage<MsgTransferBadgesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgTransferBadgesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgTransferBadgesResponse {
    return new MsgTransferBadgesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgTransferBadgesResponse {
    return new MsgTransferBadgesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgTransferBadgesResponse {
    return new MsgTransferBadgesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgTransferBadgesResponse | PlainMessage<MsgTransferBadgesResponse> | undefined, b: MsgTransferBadgesResponse | PlainMessage<MsgTransferBadgesResponse> | undefined): boolean {
    return proto3.util.equals(MsgTransferBadgesResponse, a, b);
  }
}

/**
 * MsgDeleteCollection is used to delete a collection.
 *
 * @generated from message badges.MsgDeleteCollection
 */
export class MsgDeleteCollection extends Message<MsgDeleteCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgDeleteCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteCollection | PlainMessage<MsgDeleteCollection> | undefined, b: MsgDeleteCollection | PlainMessage<MsgDeleteCollection> | undefined): boolean {
    return proto3.util.equals(MsgDeleteCollection, a, b);
  }
}

/**
 * MsgDeleteCollectionResponse is the response to MsgDeleteCollection.
 *
 * @generated from message badges.MsgDeleteCollectionResponse
 */
export class MsgDeleteCollectionResponse extends Message<MsgDeleteCollectionResponse> {
  constructor(data?: PartialMessage<MsgDeleteCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteCollectionResponse | PlainMessage<MsgDeleteCollectionResponse> | undefined, b: MsgDeleteCollectionResponse | PlainMessage<MsgDeleteCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteCollectionResponse, a, b);
  }
}

/**
 * MsgUpdateUserApprovals is used to update user approvals.
 *
 * @generated from message badges.MsgUpdateUserApprovals
 */
export class MsgUpdateUserApprovals extends Message<MsgUpdateUserApprovals> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOutgoingApprovals = 3;
   */
  updateOutgoingApprovals = false;

  /**
   * New outgoing approvals to set. 
   *
   * @generated from field: repeated badges.UserOutgoingApproval outgoingApprovals = 4;
   */
  outgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIncomingApprovals = 5;
   */
  updateIncomingApprovals = false;

  /**
   * New incoming approvals to set.
   *
   * @generated from field: repeated badges.UserIncomingApproval incomingApprovals = 6;
   */
  incomingApprovals: UserIncomingApproval[] = [];

  /**
   * Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveSelfInitiatedOutgoingTransfers = 7;
   */
  updateAutoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Auto-approve setting for self-initiated outgoing transfers.
   *
   * @generated from field: bool autoApproveSelfInitiatedOutgoingTransfers = 8;
   */
  autoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveSelfInitiatedIncomingTransfers = 9;
   */
  updateAutoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Auto-approve setting for self-initiated incoming transfers.
   *
   * @generated from field: bool autoApproveSelfInitiatedIncomingTransfers = 10;
   */
  autoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateUserPermissions = 11;
   */
  updateUserPermissions = false;

  /**
   * New user permissions to set.
   *
   * @generated from field: badges.UserPermissions userPermissions = 12;
   */
  userPermissions?: UserPermissions;

  constructor(data?: PartialMessage<MsgUpdateUserApprovals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserApprovals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "updateOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "outgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 5, name: "updateIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "incomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 7, name: "updateAutoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "autoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "updateAutoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "autoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "updateUserPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "userPermissions", kind: "message", T: UserPermissions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserApprovals | PlainMessage<MsgUpdateUserApprovals> | undefined, b: MsgUpdateUserApprovals | PlainMessage<MsgUpdateUserApprovals> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserApprovals, a, b);
  }
}

/**
 * MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.
 *
 * @generated from message badges.MsgUpdateUserApprovalsResponse
 */
export class MsgUpdateUserApprovalsResponse extends Message<MsgUpdateUserApprovalsResponse> {
  constructor(data?: PartialMessage<MsgUpdateUserApprovalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserApprovalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserApprovalsResponse | PlainMessage<MsgUpdateUserApprovalsResponse> | undefined, b: MsgUpdateUserApprovalsResponse | PlainMessage<MsgUpdateUserApprovalsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserApprovalsResponse, a, b);
  }
}

