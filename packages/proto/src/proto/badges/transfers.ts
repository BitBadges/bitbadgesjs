// @ts-nocheck
/* eslint-disable *//**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: badges/transfers.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../gogoproto/gogo";
import * as dependency_2 from "./permissions";
import * as dependency_3 from "./address_mappings";
import * as dependency_4 from "./balances";
import * as pb_1 from "google-protobuf";
export namespace bitbadges.bitbadgeschain.badges {
  export class UserBalanceStore extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      balances?: dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
      approvedOutgoingTransfers?: UserApprovedOutgoingTransfer[];
      approvedIncomingTransfers?: UserApprovedIncomingTransfer[];
      userPermissions?: dependency_2.bitbadges.bitbadgeschain.badges.UserPermissions;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2, 3], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("balances" in data && data.balances != undefined) {
          this.balances = data.balances;
        }
        if ("approvedOutgoingTransfers" in data && data.approvedOutgoingTransfers != undefined) {
          this.approvedOutgoingTransfers = data.approvedOutgoingTransfers;
        }
        if ("approvedIncomingTransfers" in data && data.approvedIncomingTransfers != undefined) {
          this.approvedIncomingTransfers = data.approvedIncomingTransfers;
        }
        if ("userPermissions" in data && data.userPermissions != undefined) {
          this.userPermissions = data.userPermissions;
        }
      }
    }
    get balances() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.Balance, 1) as dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
    }
    set balances(value: dependency_4.bitbadges.bitbadgeschain.badges.Balance[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    get approvedOutgoingTransfers() {
      return pb_1.Message.getRepeatedWrapperField(this, UserApprovedOutgoingTransfer, 2) as UserApprovedOutgoingTransfer[];
    }
    set approvedOutgoingTransfers(value: UserApprovedOutgoingTransfer[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get approvedIncomingTransfers() {
      return pb_1.Message.getRepeatedWrapperField(this, UserApprovedIncomingTransfer, 3) as UserApprovedIncomingTransfer[];
    }
    set approvedIncomingTransfers(value: UserApprovedIncomingTransfer[]) {
      pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    get userPermissions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.UserPermissions, 4) as dependency_2.bitbadges.bitbadgeschain.badges.UserPermissions;
    }
    set userPermissions(value: dependency_2.bitbadges.bitbadgeschain.badges.UserPermissions) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_userPermissions() {
      return pb_1.Message.getField(this, 4) != null;
    }
    static fromObject(data: {
      balances?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
      approvedOutgoingTransfers?: ReturnType<typeof UserApprovedOutgoingTransfer.prototype.toObject>[];
      approvedIncomingTransfers?: ReturnType<typeof UserApprovedIncomingTransfer.prototype.toObject>[];
      userPermissions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.UserPermissions.prototype.toObject>;
    }): UserBalanceStore {
      const message = new UserBalanceStore({});
      if (data.balances != null) {
        message.balances = data.balances.map(item => dependency_4.bitbadges.bitbadgeschain.badges.Balance.fromObject(item));
      }
      if (data.approvedOutgoingTransfers != null) {
        message.approvedOutgoingTransfers = data.approvedOutgoingTransfers.map(item => UserApprovedOutgoingTransfer.fromObject(item));
      }
      if (data.approvedIncomingTransfers != null) {
        message.approvedIncomingTransfers = data.approvedIncomingTransfers.map(item => UserApprovedIncomingTransfer.fromObject(item));
      }
      if (data.userPermissions != null) {
        message.userPermissions = dependency_2.bitbadges.bitbadgeschain.badges.UserPermissions.fromObject(data.userPermissions);
      }
      return message;
    }
    toObject() {
      const data: {
        balances?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
        approvedOutgoingTransfers?: ReturnType<typeof UserApprovedOutgoingTransfer.prototype.toObject>[];
        approvedIncomingTransfers?: ReturnType<typeof UserApprovedIncomingTransfer.prototype.toObject>[];
        userPermissions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.UserPermissions.prototype.toObject>;
      } = {};
      if (this.balances != null) {
        data.balances = this.balances.map((item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.toObject());
      }
      if (this.approvedOutgoingTransfers != null) {
        data.approvedOutgoingTransfers = this.approvedOutgoingTransfers.map((item: UserApprovedOutgoingTransfer) => item.toObject());
      }
      if (this.approvedIncomingTransfers != null) {
        data.approvedIncomingTransfers = this.approvedIncomingTransfers.map((item: UserApprovedIncomingTransfer) => item.toObject());
      }
      if (this.userPermissions != null) {
        data.userPermissions = this.userPermissions.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.balances.length)
        writer.writeRepeatedMessage(1, this.balances, (item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.serialize(writer));
      if (this.approvedOutgoingTransfers.length)
        writer.writeRepeatedMessage(2, this.approvedOutgoingTransfers, (item: UserApprovedOutgoingTransfer) => item.serialize(writer));
      if (this.approvedIncomingTransfers.length)
        writer.writeRepeatedMessage(3, this.approvedIncomingTransfers, (item: UserApprovedIncomingTransfer) => item.serialize(writer));
      if (this.has_userPermissions)
        writer.writeMessage(4, this.userPermissions, () => this.userPermissions.serialize(writer));
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UserBalanceStore {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UserBalanceStore();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.balances, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_4.bitbadges.bitbadgeschain.badges.Balance.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.Balance));
            break;
          case 2:
            reader.readMessage(message.approvedOutgoingTransfers, () => pb_1.Message.addToRepeatedWrapperField(message, 2, UserApprovedOutgoingTransfer.deserialize(reader), UserApprovedOutgoingTransfer));
            break;
          case 3:
            reader.readMessage(message.approvedIncomingTransfers, () => pb_1.Message.addToRepeatedWrapperField(message, 3, UserApprovedIncomingTransfer.deserialize(reader), UserApprovedIncomingTransfer));
            break;
          case 4:
            reader.readMessage(message.userPermissions, () => message.userPermissions = dependency_2.bitbadges.bitbadgeschain.badges.UserPermissions.deserialize(reader));
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UserBalanceStore {
      return UserBalanceStore.deserialize(bytes);
    }
  }
  export class MerkleChallenge extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      root?: string;
      expectedProofLength?: string;
      useCreatorAddressAsLeaf?: boolean;
      maxOneUsePerLeaf?: boolean;
      useLeafIndexForTransferOrder?: boolean;
      challengeId?: string;
      uri?: string;
      customData?: string;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("root" in data && data.root != undefined) {
          this.root = data.root;
        }
        if ("expectedProofLength" in data && data.expectedProofLength != undefined) {
          this.expectedProofLength = data.expectedProofLength;
        }
        if ("useCreatorAddressAsLeaf" in data && data.useCreatorAddressAsLeaf != undefined) {
          this.useCreatorAddressAsLeaf = data.useCreatorAddressAsLeaf;
        }
        if ("maxOneUsePerLeaf" in data && data.maxOneUsePerLeaf != undefined) {
          this.maxOneUsePerLeaf = data.maxOneUsePerLeaf;
        }
        if ("useLeafIndexForTransferOrder" in data && data.useLeafIndexForTransferOrder != undefined) {
          this.useLeafIndexForTransferOrder = data.useLeafIndexForTransferOrder;
        }
        if ("challengeId" in data && data.challengeId != undefined) {
          this.challengeId = data.challengeId;
        }
        if ("uri" in data && data.uri != undefined) {
          this.uri = data.uri;
        }
        if ("customData" in data && data.customData != undefined) {
          this.customData = data.customData;
        }
      }
    }
    get root() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set root(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get expectedProofLength() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set expectedProofLength(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get useCreatorAddressAsLeaf() {
      return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
    }
    set useCreatorAddressAsLeaf(value: boolean) {
      pb_1.Message.setField(this, 3, value);
    }
    get maxOneUsePerLeaf() {
      return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
    }
    set maxOneUsePerLeaf(value: boolean) {
      pb_1.Message.setField(this, 4, value);
    }
    get useLeafIndexForTransferOrder() {
      return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
    }
    set useLeafIndexForTransferOrder(value: boolean) {
      pb_1.Message.setField(this, 5, value);
    }
    get challengeId() {
      return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set challengeId(value: string) {
      pb_1.Message.setField(this, 6, value);
    }
    get uri() {
      return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
    }
    set uri(value: string) {
      pb_1.Message.setField(this, 7, value);
    }
    get customData() {
      return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
    }
    set customData(value: string) {
      pb_1.Message.setField(this, 8, value);
    }
    static fromObject(data: {
      root?: string;
      expectedProofLength?: string;
      useCreatorAddressAsLeaf?: boolean;
      maxOneUsePerLeaf?: boolean;
      useLeafIndexForTransferOrder?: boolean;
      challengeId?: string;
      uri?: string;
      customData?: string;
    }): MerkleChallenge {
      const message = new MerkleChallenge({});
      if (data.root != null) {
        message.root = data.root;
      }
      if (data.expectedProofLength != null) {
        message.expectedProofLength = data.expectedProofLength;
      }
      if (data.useCreatorAddressAsLeaf != null) {
        message.useCreatorAddressAsLeaf = data.useCreatorAddressAsLeaf;
      }
      if (data.maxOneUsePerLeaf != null) {
        message.maxOneUsePerLeaf = data.maxOneUsePerLeaf;
      }
      if (data.useLeafIndexForTransferOrder != null) {
        message.useLeafIndexForTransferOrder = data.useLeafIndexForTransferOrder;
      }
      if (data.challengeId != null) {
        message.challengeId = data.challengeId;
      }
      if (data.uri != null) {
        message.uri = data.uri;
      }
      if (data.customData != null) {
        message.customData = data.customData;
      }
      return message;
    }
    toObject() {
      const data: {
        root?: string;
        expectedProofLength?: string;
        useCreatorAddressAsLeaf?: boolean;
        maxOneUsePerLeaf?: boolean;
        useLeafIndexForTransferOrder?: boolean;
        challengeId?: string;
        uri?: string;
        customData?: string;
      } = {};
      if (this.root != null) {
        data.root = this.root;
      }
      if (this.expectedProofLength != null) {
        data.expectedProofLength = this.expectedProofLength;
      }
      if (this.useCreatorAddressAsLeaf != null) {
        data.useCreatorAddressAsLeaf = this.useCreatorAddressAsLeaf;
      }
      if (this.maxOneUsePerLeaf != null) {
        data.maxOneUsePerLeaf = this.maxOneUsePerLeaf;
      }
      if (this.useLeafIndexForTransferOrder != null) {
        data.useLeafIndexForTransferOrder = this.useLeafIndexForTransferOrder;
      }
      if (this.challengeId != null) {
        data.challengeId = this.challengeId;
      }
      if (this.uri != null) {
        data.uri = this.uri;
      }
      if (this.customData != null) {
        data.customData = this.customData;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.root.length)
        writer.writeString(1, this.root);
      if (this.expectedProofLength.length)
        writer.writeString(2, this.expectedProofLength);
      if (this.useCreatorAddressAsLeaf != false)
        writer.writeBool(3, this.useCreatorAddressAsLeaf);
      if (this.maxOneUsePerLeaf != false)
        writer.writeBool(4, this.maxOneUsePerLeaf);
      if (this.useLeafIndexForTransferOrder != false)
        writer.writeBool(5, this.useLeafIndexForTransferOrder);
      if (this.challengeId.length)
        writer.writeString(6, this.challengeId);
      if (this.uri.length)
        writer.writeString(7, this.uri);
      if (this.customData.length)
        writer.writeString(8, this.customData);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MerkleChallenge {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MerkleChallenge();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.root = reader.readString();
            break;
          case 2:
            message.expectedProofLength = reader.readString();
            break;
          case 3:
            message.useCreatorAddressAsLeaf = reader.readBool();
            break;
          case 4:
            message.maxOneUsePerLeaf = reader.readBool();
            break;
          case 5:
            message.useLeafIndexForTransferOrder = reader.readBool();
            break;
          case 6:
            message.challengeId = reader.readString();
            break;
          case 7:
            message.uri = reader.readString();
            break;
          case 8:
            message.customData = reader.readString();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MerkleChallenge {
      return MerkleChallenge.deserialize(bytes);
    }
  }
  export class IsUserOutgoingTransferAllowed extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      toMappingOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      initiatedByMappingOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      transferTimesOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      badgeIdsOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      ownershipTimesOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      isApproved?: boolean;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("toMappingOptions" in data && data.toMappingOptions != undefined) {
          this.toMappingOptions = data.toMappingOptions;
        }
        if ("initiatedByMappingOptions" in data && data.initiatedByMappingOptions != undefined) {
          this.initiatedByMappingOptions = data.initiatedByMappingOptions;
        }
        if ("transferTimesOptions" in data && data.transferTimesOptions != undefined) {
          this.transferTimesOptions = data.transferTimesOptions;
        }
        if ("badgeIdsOptions" in data && data.badgeIdsOptions != undefined) {
          this.badgeIdsOptions = data.badgeIdsOptions;
        }
        if ("ownershipTimesOptions" in data && data.ownershipTimesOptions != undefined) {
          this.ownershipTimesOptions = data.ownershipTimesOptions;
        }
        if ("isApproved" in data && data.isApproved != undefined) {
          this.isApproved = data.isApproved;
        }
      }
    }
    get toMappingOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 2) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set toMappingOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_toMappingOptions() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get initiatedByMappingOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 3) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set initiatedByMappingOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_initiatedByMappingOptions() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get transferTimesOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 4) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set transferTimesOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_transferTimesOptions() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get badgeIdsOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 5) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set badgeIdsOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_badgeIdsOptions() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get ownershipTimesOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 6) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set ownershipTimesOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 6, value);
    }
    get has_ownershipTimesOptions() {
      return pb_1.Message.getField(this, 6) != null;
    }
    get isApproved() {
      return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
    }
    set isApproved(value: boolean) {
      pb_1.Message.setField(this, 7, value);
    }
    static fromObject(data: {
      toMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      initiatedByMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      transferTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      badgeIdsOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      ownershipTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      isApproved?: boolean;
    }): IsUserOutgoingTransferAllowed {
      const message = new IsUserOutgoingTransferAllowed({});
      if (data.toMappingOptions != null) {
        message.toMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.toMappingOptions);
      }
      if (data.initiatedByMappingOptions != null) {
        message.initiatedByMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.initiatedByMappingOptions);
      }
      if (data.transferTimesOptions != null) {
        message.transferTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.transferTimesOptions);
      }
      if (data.badgeIdsOptions != null) {
        message.badgeIdsOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.badgeIdsOptions);
      }
      if (data.ownershipTimesOptions != null) {
        message.ownershipTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.ownershipTimesOptions);
      }
      if (data.isApproved != null) {
        message.isApproved = data.isApproved;
      }
      return message;
    }
    toObject() {
      const data: {
        toMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        initiatedByMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        transferTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        badgeIdsOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        ownershipTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        isApproved?: boolean;
      } = {};
      if (this.toMappingOptions != null) {
        data.toMappingOptions = this.toMappingOptions.toObject();
      }
      if (this.initiatedByMappingOptions != null) {
        data.initiatedByMappingOptions = this.initiatedByMappingOptions.toObject();
      }
      if (this.transferTimesOptions != null) {
        data.transferTimesOptions = this.transferTimesOptions.toObject();
      }
      if (this.badgeIdsOptions != null) {
        data.badgeIdsOptions = this.badgeIdsOptions.toObject();
      }
      if (this.ownershipTimesOptions != null) {
        data.ownershipTimesOptions = this.ownershipTimesOptions.toObject();
      }
      if (this.isApproved != null) {
        data.isApproved = this.isApproved;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_toMappingOptions)
        writer.writeMessage(2, this.toMappingOptions, () => this.toMappingOptions.serialize(writer));
      if (this.has_initiatedByMappingOptions)
        writer.writeMessage(3, this.initiatedByMappingOptions, () => this.initiatedByMappingOptions.serialize(writer));
      if (this.has_transferTimesOptions)
        writer.writeMessage(4, this.transferTimesOptions, () => this.transferTimesOptions.serialize(writer));
      if (this.has_badgeIdsOptions)
        writer.writeMessage(5, this.badgeIdsOptions, () => this.badgeIdsOptions.serialize(writer));
      if (this.has_ownershipTimesOptions)
        writer.writeMessage(6, this.ownershipTimesOptions, () => this.ownershipTimesOptions.serialize(writer));
      if (this.isApproved != false)
        writer.writeBool(7, this.isApproved);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IsUserOutgoingTransferAllowed {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IsUserOutgoingTransferAllowed();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 2:
            reader.readMessage(message.toMappingOptions, () => message.toMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 3:
            reader.readMessage(message.initiatedByMappingOptions, () => message.initiatedByMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 4:
            reader.readMessage(message.transferTimesOptions, () => message.transferTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 5:
            reader.readMessage(message.badgeIdsOptions, () => message.badgeIdsOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 6:
            reader.readMessage(message.ownershipTimesOptions, () => message.ownershipTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 7:
            message.isApproved = reader.readBool();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IsUserOutgoingTransferAllowed {
      return IsUserOutgoingTransferAllowed.deserialize(bytes);
    }
  }
  export class IsUserIncomingTransferAllowed extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      fromMappingOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      initiatedByMappingOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      transferTimesOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      badgeIdsOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      ownershipTimesOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      isApproved?: boolean;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("fromMappingOptions" in data && data.fromMappingOptions != undefined) {
          this.fromMappingOptions = data.fromMappingOptions;
        }
        if ("initiatedByMappingOptions" in data && data.initiatedByMappingOptions != undefined) {
          this.initiatedByMappingOptions = data.initiatedByMappingOptions;
        }
        if ("transferTimesOptions" in data && data.transferTimesOptions != undefined) {
          this.transferTimesOptions = data.transferTimesOptions;
        }
        if ("badgeIdsOptions" in data && data.badgeIdsOptions != undefined) {
          this.badgeIdsOptions = data.badgeIdsOptions;
        }
        if ("ownershipTimesOptions" in data && data.ownershipTimesOptions != undefined) {
          this.ownershipTimesOptions = data.ownershipTimesOptions;
        }
        if ("isApproved" in data && data.isApproved != undefined) {
          this.isApproved = data.isApproved;
        }
      }
    }
    get fromMappingOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 2) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set fromMappingOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_fromMappingOptions() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get initiatedByMappingOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 3) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set initiatedByMappingOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_initiatedByMappingOptions() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get transferTimesOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 4) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set transferTimesOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_transferTimesOptions() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get badgeIdsOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 5) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set badgeIdsOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_badgeIdsOptions() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get ownershipTimesOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 6) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set ownershipTimesOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 6, value);
    }
    get has_ownershipTimesOptions() {
      return pb_1.Message.getField(this, 6) != null;
    }
    get isApproved() {
      return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
    }
    set isApproved(value: boolean) {
      pb_1.Message.setField(this, 7, value);
    }
    static fromObject(data: {
      fromMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      initiatedByMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      transferTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      badgeIdsOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      ownershipTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      isApproved?: boolean;
    }): IsUserIncomingTransferAllowed {
      const message = new IsUserIncomingTransferAllowed({});
      if (data.fromMappingOptions != null) {
        message.fromMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.fromMappingOptions);
      }
      if (data.initiatedByMappingOptions != null) {
        message.initiatedByMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.initiatedByMappingOptions);
      }
      if (data.transferTimesOptions != null) {
        message.transferTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.transferTimesOptions);
      }
      if (data.badgeIdsOptions != null) {
        message.badgeIdsOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.badgeIdsOptions);
      }
      if (data.ownershipTimesOptions != null) {
        message.ownershipTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.ownershipTimesOptions);
      }
      if (data.isApproved != null) {
        message.isApproved = data.isApproved;
      }
      return message;
    }
    toObject() {
      const data: {
        fromMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        initiatedByMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        transferTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        badgeIdsOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        ownershipTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        isApproved?: boolean;
      } = {};
      if (this.fromMappingOptions != null) {
        data.fromMappingOptions = this.fromMappingOptions.toObject();
      }
      if (this.initiatedByMappingOptions != null) {
        data.initiatedByMappingOptions = this.initiatedByMappingOptions.toObject();
      }
      if (this.transferTimesOptions != null) {
        data.transferTimesOptions = this.transferTimesOptions.toObject();
      }
      if (this.badgeIdsOptions != null) {
        data.badgeIdsOptions = this.badgeIdsOptions.toObject();
      }
      if (this.ownershipTimesOptions != null) {
        data.ownershipTimesOptions = this.ownershipTimesOptions.toObject();
      }
      if (this.isApproved != null) {
        data.isApproved = this.isApproved;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_fromMappingOptions)
        writer.writeMessage(2, this.fromMappingOptions, () => this.fromMappingOptions.serialize(writer));
      if (this.has_initiatedByMappingOptions)
        writer.writeMessage(3, this.initiatedByMappingOptions, () => this.initiatedByMappingOptions.serialize(writer));
      if (this.has_transferTimesOptions)
        writer.writeMessage(4, this.transferTimesOptions, () => this.transferTimesOptions.serialize(writer));
      if (this.has_badgeIdsOptions)
        writer.writeMessage(5, this.badgeIdsOptions, () => this.badgeIdsOptions.serialize(writer));
      if (this.has_ownershipTimesOptions)
        writer.writeMessage(6, this.ownershipTimesOptions, () => this.ownershipTimesOptions.serialize(writer));
      if (this.isApproved != false)
        writer.writeBool(7, this.isApproved);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IsUserIncomingTransferAllowed {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IsUserIncomingTransferAllowed();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 2:
            reader.readMessage(message.fromMappingOptions, () => message.fromMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 3:
            reader.readMessage(message.initiatedByMappingOptions, () => message.initiatedByMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 4:
            reader.readMessage(message.transferTimesOptions, () => message.transferTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 5:
            reader.readMessage(message.badgeIdsOptions, () => message.badgeIdsOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 6:
            reader.readMessage(message.ownershipTimesOptions, () => message.ownershipTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 7:
            message.isApproved = reader.readBool();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IsUserIncomingTransferAllowed {
      return IsUserIncomingTransferAllowed.deserialize(bytes);
    }
  }
  export class UserApprovedOutgoingTransfer extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      toMappingId?: string;
      initiatedByMappingId?: string;
      transferTimes?: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
      badgeIds?: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
      ownershipTimes?: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
      allowedCombinations?: IsUserOutgoingTransferAllowed[];
      approvalDetails?: OutgoingApprovalDetails[];
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 4, 7, 5, 6], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("toMappingId" in data && data.toMappingId != undefined) {
          this.toMappingId = data.toMappingId;
        }
        if ("initiatedByMappingId" in data && data.initiatedByMappingId != undefined) {
          this.initiatedByMappingId = data.initiatedByMappingId;
        }
        if ("transferTimes" in data && data.transferTimes != undefined) {
          this.transferTimes = data.transferTimes;
        }
        if ("badgeIds" in data && data.badgeIds != undefined) {
          this.badgeIds = data.badgeIds;
        }
        if ("ownershipTimes" in data && data.ownershipTimes != undefined) {
          this.ownershipTimes = data.ownershipTimes;
        }
        if ("allowedCombinations" in data && data.allowedCombinations != undefined) {
          this.allowedCombinations = data.allowedCombinations;
        }
        if ("approvalDetails" in data && data.approvalDetails != undefined) {
          this.approvalDetails = data.approvalDetails;
        }
      }
    }
    get toMappingId() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set toMappingId(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get initiatedByMappingId() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set initiatedByMappingId(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get transferTimes() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.UintRange, 3) as dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
    }
    set transferTimes(value: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    get badgeIds() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.UintRange, 4) as dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
    }
    set badgeIds(value: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    get ownershipTimes() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.UintRange, 7) as dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
    }
    set ownershipTimes(value: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 7, value);
    }
    get allowedCombinations() {
      return pb_1.Message.getRepeatedWrapperField(this, IsUserOutgoingTransferAllowed, 5) as IsUserOutgoingTransferAllowed[];
    }
    set allowedCombinations(value: IsUserOutgoingTransferAllowed[]) {
      pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    get approvalDetails() {
      return pb_1.Message.getRepeatedWrapperField(this, OutgoingApprovalDetails, 6) as OutgoingApprovalDetails[];
    }
    set approvalDetails(value: OutgoingApprovalDetails[]) {
      pb_1.Message.setRepeatedWrapperField(this, 6, value);
    }
    static fromObject(data: {
      toMappingId?: string;
      initiatedByMappingId?: string;
      transferTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
      badgeIds?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
      ownershipTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
      allowedCombinations?: ReturnType<typeof IsUserOutgoingTransferAllowed.prototype.toObject>[];
      approvalDetails?: ReturnType<typeof OutgoingApprovalDetails.prototype.toObject>[];
    }): UserApprovedOutgoingTransfer {
      const message = new UserApprovedOutgoingTransfer({});
      if (data.toMappingId != null) {
        message.toMappingId = data.toMappingId;
      }
      if (data.initiatedByMappingId != null) {
        message.initiatedByMappingId = data.initiatedByMappingId;
      }
      if (data.transferTimes != null) {
        message.transferTimes = data.transferTimes.map(item => dependency_4.bitbadges.bitbadgeschain.badges.UintRange.fromObject(item));
      }
      if (data.badgeIds != null) {
        message.badgeIds = data.badgeIds.map(item => dependency_4.bitbadges.bitbadgeschain.badges.UintRange.fromObject(item));
      }
      if (data.ownershipTimes != null) {
        message.ownershipTimes = data.ownershipTimes.map(item => dependency_4.bitbadges.bitbadgeschain.badges.UintRange.fromObject(item));
      }
      if (data.allowedCombinations != null) {
        message.allowedCombinations = data.allowedCombinations.map(item => IsUserOutgoingTransferAllowed.fromObject(item));
      }
      if (data.approvalDetails != null) {
        message.approvalDetails = data.approvalDetails.map(item => OutgoingApprovalDetails.fromObject(item));
      }
      return message;
    }
    toObject() {
      const data: {
        toMappingId?: string;
        initiatedByMappingId?: string;
        transferTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
        badgeIds?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
        ownershipTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
        allowedCombinations?: ReturnType<typeof IsUserOutgoingTransferAllowed.prototype.toObject>[];
        approvalDetails?: ReturnType<typeof OutgoingApprovalDetails.prototype.toObject>[];
      } = {};
      if (this.toMappingId != null) {
        data.toMappingId = this.toMappingId;
      }
      if (this.initiatedByMappingId != null) {
        data.initiatedByMappingId = this.initiatedByMappingId;
      }
      if (this.transferTimes != null) {
        data.transferTimes = this.transferTimes.map((item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.toObject());
      }
      if (this.badgeIds != null) {
        data.badgeIds = this.badgeIds.map((item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.toObject());
      }
      if (this.ownershipTimes != null) {
        data.ownershipTimes = this.ownershipTimes.map((item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.toObject());
      }
      if (this.allowedCombinations != null) {
        data.allowedCombinations = this.allowedCombinations.map((item: IsUserOutgoingTransferAllowed) => item.toObject());
      }
      if (this.approvalDetails != null) {
        data.approvalDetails = this.approvalDetails.map((item: OutgoingApprovalDetails) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.toMappingId.length)
        writer.writeString(1, this.toMappingId);
      if (this.initiatedByMappingId.length)
        writer.writeString(2, this.initiatedByMappingId);
      if (this.transferTimes.length)
        writer.writeRepeatedMessage(3, this.transferTimes, (item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.serialize(writer));
      if (this.badgeIds.length)
        writer.writeRepeatedMessage(4, this.badgeIds, (item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.serialize(writer));
      if (this.ownershipTimes.length)
        writer.writeRepeatedMessage(7, this.ownershipTimes, (item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.serialize(writer));
      if (this.allowedCombinations.length)
        writer.writeRepeatedMessage(5, this.allowedCombinations, (item: IsUserOutgoingTransferAllowed) => item.serialize(writer));
      if (this.approvalDetails.length)
        writer.writeRepeatedMessage(6, this.approvalDetails, (item: OutgoingApprovalDetails) => item.serialize(writer));
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UserApprovedOutgoingTransfer {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UserApprovedOutgoingTransfer();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.toMappingId = reader.readString();
            break;
          case 2:
            message.initiatedByMappingId = reader.readString();
            break;
          case 3:
            reader.readMessage(message.transferTimes, () => pb_1.Message.addToRepeatedWrapperField(message, 3, dependency_4.bitbadges.bitbadgeschain.badges.UintRange.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.UintRange));
            break;
          case 4:
            reader.readMessage(message.badgeIds, () => pb_1.Message.addToRepeatedWrapperField(message, 4, dependency_4.bitbadges.bitbadgeschain.badges.UintRange.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.UintRange));
            break;
          case 7:
            reader.readMessage(message.ownershipTimes, () => pb_1.Message.addToRepeatedWrapperField(message, 7, dependency_4.bitbadges.bitbadgeschain.badges.UintRange.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.UintRange));
            break;
          case 5:
            reader.readMessage(message.allowedCombinations, () => pb_1.Message.addToRepeatedWrapperField(message, 5, IsUserOutgoingTransferAllowed.deserialize(reader), IsUserOutgoingTransferAllowed));
            break;
          case 6:
            reader.readMessage(message.approvalDetails, () => pb_1.Message.addToRepeatedWrapperField(message, 6, OutgoingApprovalDetails.deserialize(reader), OutgoingApprovalDetails));
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UserApprovedOutgoingTransfer {
      return UserApprovedOutgoingTransfer.deserialize(bytes);
    }
  }
  export class UserApprovedIncomingTransfer extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      fromMappingId?: string;
      initiatedByMappingId?: string;
      transferTimes?: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
      badgeIds?: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
      ownershipTimes?: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
      allowedCombinations?: IsUserIncomingTransferAllowed[];
      approvalDetails?: IncomingApprovalDetails[];
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 4, 5, 6, 7], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("fromMappingId" in data && data.fromMappingId != undefined) {
          this.fromMappingId = data.fromMappingId;
        }
        if ("initiatedByMappingId" in data && data.initiatedByMappingId != undefined) {
          this.initiatedByMappingId = data.initiatedByMappingId;
        }
        if ("transferTimes" in data && data.transferTimes != undefined) {
          this.transferTimes = data.transferTimes;
        }
        if ("badgeIds" in data && data.badgeIds != undefined) {
          this.badgeIds = data.badgeIds;
        }
        if ("ownershipTimes" in data && data.ownershipTimes != undefined) {
          this.ownershipTimes = data.ownershipTimes;
        }
        if ("allowedCombinations" in data && data.allowedCombinations != undefined) {
          this.allowedCombinations = data.allowedCombinations;
        }
        if ("approvalDetails" in data && data.approvalDetails != undefined) {
          this.approvalDetails = data.approvalDetails;
        }
      }
    }
    get fromMappingId() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set fromMappingId(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get initiatedByMappingId() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set initiatedByMappingId(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get transferTimes() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.UintRange, 3) as dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
    }
    set transferTimes(value: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    get badgeIds() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.UintRange, 4) as dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
    }
    set badgeIds(value: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    get ownershipTimes() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.UintRange, 5) as dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
    }
    set ownershipTimes(value: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    get allowedCombinations() {
      return pb_1.Message.getRepeatedWrapperField(this, IsUserIncomingTransferAllowed, 6) as IsUserIncomingTransferAllowed[];
    }
    set allowedCombinations(value: IsUserIncomingTransferAllowed[]) {
      pb_1.Message.setRepeatedWrapperField(this, 6, value);
    }
    get approvalDetails() {
      return pb_1.Message.getRepeatedWrapperField(this, IncomingApprovalDetails, 7) as IncomingApprovalDetails[];
    }
    set approvalDetails(value: IncomingApprovalDetails[]) {
      pb_1.Message.setRepeatedWrapperField(this, 7, value);
    }
    static fromObject(data: {
      fromMappingId?: string;
      initiatedByMappingId?: string;
      transferTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
      badgeIds?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
      ownershipTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
      allowedCombinations?: ReturnType<typeof IsUserIncomingTransferAllowed.prototype.toObject>[];
      approvalDetails?: ReturnType<typeof IncomingApprovalDetails.prototype.toObject>[];
    }): UserApprovedIncomingTransfer {
      const message = new UserApprovedIncomingTransfer({});
      if (data.fromMappingId != null) {
        message.fromMappingId = data.fromMappingId;
      }
      if (data.initiatedByMappingId != null) {
        message.initiatedByMappingId = data.initiatedByMappingId;
      }
      if (data.transferTimes != null) {
        message.transferTimes = data.transferTimes.map(item => dependency_4.bitbadges.bitbadgeschain.badges.UintRange.fromObject(item));
      }
      if (data.badgeIds != null) {
        message.badgeIds = data.badgeIds.map(item => dependency_4.bitbadges.bitbadgeschain.badges.UintRange.fromObject(item));
      }
      if (data.ownershipTimes != null) {
        message.ownershipTimes = data.ownershipTimes.map(item => dependency_4.bitbadges.bitbadgeschain.badges.UintRange.fromObject(item));
      }
      if (data.allowedCombinations != null) {
        message.allowedCombinations = data.allowedCombinations.map(item => IsUserIncomingTransferAllowed.fromObject(item));
      }
      if (data.approvalDetails != null) {
        message.approvalDetails = data.approvalDetails.map(item => IncomingApprovalDetails.fromObject(item));
      }
      return message;
    }
    toObject() {
      const data: {
        fromMappingId?: string;
        initiatedByMappingId?: string;
        transferTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
        badgeIds?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
        ownershipTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
        allowedCombinations?: ReturnType<typeof IsUserIncomingTransferAllowed.prototype.toObject>[];
        approvalDetails?: ReturnType<typeof IncomingApprovalDetails.prototype.toObject>[];
      } = {};
      if (this.fromMappingId != null) {
        data.fromMappingId = this.fromMappingId;
      }
      if (this.initiatedByMappingId != null) {
        data.initiatedByMappingId = this.initiatedByMappingId;
      }
      if (this.transferTimes != null) {
        data.transferTimes = this.transferTimes.map((item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.toObject());
      }
      if (this.badgeIds != null) {
        data.badgeIds = this.badgeIds.map((item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.toObject());
      }
      if (this.ownershipTimes != null) {
        data.ownershipTimes = this.ownershipTimes.map((item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.toObject());
      }
      if (this.allowedCombinations != null) {
        data.allowedCombinations = this.allowedCombinations.map((item: IsUserIncomingTransferAllowed) => item.toObject());
      }
      if (this.approvalDetails != null) {
        data.approvalDetails = this.approvalDetails.map((item: IncomingApprovalDetails) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.fromMappingId.length)
        writer.writeString(1, this.fromMappingId);
      if (this.initiatedByMappingId.length)
        writer.writeString(2, this.initiatedByMappingId);
      if (this.transferTimes.length)
        writer.writeRepeatedMessage(3, this.transferTimes, (item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.serialize(writer));
      if (this.badgeIds.length)
        writer.writeRepeatedMessage(4, this.badgeIds, (item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.serialize(writer));
      if (this.ownershipTimes.length)
        writer.writeRepeatedMessage(5, this.ownershipTimes, (item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.serialize(writer));
      if (this.allowedCombinations.length)
        writer.writeRepeatedMessage(6, this.allowedCombinations, (item: IsUserIncomingTransferAllowed) => item.serialize(writer));
      if (this.approvalDetails.length)
        writer.writeRepeatedMessage(7, this.approvalDetails, (item: IncomingApprovalDetails) => item.serialize(writer));
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UserApprovedIncomingTransfer {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UserApprovedIncomingTransfer();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.fromMappingId = reader.readString();
            break;
          case 2:
            message.initiatedByMappingId = reader.readString();
            break;
          case 3:
            reader.readMessage(message.transferTimes, () => pb_1.Message.addToRepeatedWrapperField(message, 3, dependency_4.bitbadges.bitbadgeschain.badges.UintRange.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.UintRange));
            break;
          case 4:
            reader.readMessage(message.badgeIds, () => pb_1.Message.addToRepeatedWrapperField(message, 4, dependency_4.bitbadges.bitbadgeschain.badges.UintRange.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.UintRange));
            break;
          case 5:
            reader.readMessage(message.ownershipTimes, () => pb_1.Message.addToRepeatedWrapperField(message, 5, dependency_4.bitbadges.bitbadgeschain.badges.UintRange.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.UintRange));
            break;
          case 6:
            reader.readMessage(message.allowedCombinations, () => pb_1.Message.addToRepeatedWrapperField(message, 6, IsUserIncomingTransferAllowed.deserialize(reader), IsUserIncomingTransferAllowed));
            break;
          case 7:
            reader.readMessage(message.approvalDetails, () => pb_1.Message.addToRepeatedWrapperField(message, 7, IncomingApprovalDetails.deserialize(reader), IncomingApprovalDetails));
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UserApprovedIncomingTransfer {
      return UserApprovedIncomingTransfer.deserialize(bytes);
    }
  }
  export class IsCollectionTransferAllowed extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      fromMappingOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      toMappingOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      initiatedByMappingOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      transferTimesOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      badgeIdsOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      ownershipTimesOptions?: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
      isApproved?: boolean;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("fromMappingOptions" in data && data.fromMappingOptions != undefined) {
          this.fromMappingOptions = data.fromMappingOptions;
        }
        if ("toMappingOptions" in data && data.toMappingOptions != undefined) {
          this.toMappingOptions = data.toMappingOptions;
        }
        if ("initiatedByMappingOptions" in data && data.initiatedByMappingOptions != undefined) {
          this.initiatedByMappingOptions = data.initiatedByMappingOptions;
        }
        if ("transferTimesOptions" in data && data.transferTimesOptions != undefined) {
          this.transferTimesOptions = data.transferTimesOptions;
        }
        if ("badgeIdsOptions" in data && data.badgeIdsOptions != undefined) {
          this.badgeIdsOptions = data.badgeIdsOptions;
        }
        if ("ownershipTimesOptions" in data && data.ownershipTimesOptions != undefined) {
          this.ownershipTimesOptions = data.ownershipTimesOptions;
        }
        if ("isApproved" in data && data.isApproved != undefined) {
          this.isApproved = data.isApproved;
        }
      }
    }
    get fromMappingOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 1) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set fromMappingOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_fromMappingOptions() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get toMappingOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 2) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set toMappingOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_toMappingOptions() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get initiatedByMappingOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 3) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set initiatedByMappingOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_initiatedByMappingOptions() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get transferTimesOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 4) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set transferTimesOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_transferTimesOptions() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get badgeIdsOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 5) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set badgeIdsOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_badgeIdsOptions() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get ownershipTimesOptions() {
      return pb_1.Message.getWrapperField(this, dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions, 6) as dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions;
    }
    set ownershipTimesOptions(value: dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions) {
      pb_1.Message.setWrapperField(this, 6, value);
    }
    get has_ownershipTimesOptions() {
      return pb_1.Message.getField(this, 6) != null;
    }
    get isApproved() {
      return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
    }
    set isApproved(value: boolean) {
      pb_1.Message.setField(this, 7, value);
    }
    static fromObject(data: {
      fromMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      toMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      initiatedByMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      transferTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      badgeIdsOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      ownershipTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
      isApproved?: boolean;
    }): IsCollectionTransferAllowed {
      const message = new IsCollectionTransferAllowed({});
      if (data.fromMappingOptions != null) {
        message.fromMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.fromMappingOptions);
      }
      if (data.toMappingOptions != null) {
        message.toMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.toMappingOptions);
      }
      if (data.initiatedByMappingOptions != null) {
        message.initiatedByMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.initiatedByMappingOptions);
      }
      if (data.transferTimesOptions != null) {
        message.transferTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.transferTimesOptions);
      }
      if (data.badgeIdsOptions != null) {
        message.badgeIdsOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.badgeIdsOptions);
      }
      if (data.ownershipTimesOptions != null) {
        message.ownershipTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.fromObject(data.ownershipTimesOptions);
      }
      if (data.isApproved != null) {
        message.isApproved = data.isApproved;
      }
      return message;
    }
    toObject() {
      const data: {
        fromMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        toMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        initiatedByMappingOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        transferTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        badgeIdsOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        ownershipTimesOptions?: ReturnType<typeof dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.prototype.toObject>;
        isApproved?: boolean;
      } = {};
      if (this.fromMappingOptions != null) {
        data.fromMappingOptions = this.fromMappingOptions.toObject();
      }
      if (this.toMappingOptions != null) {
        data.toMappingOptions = this.toMappingOptions.toObject();
      }
      if (this.initiatedByMappingOptions != null) {
        data.initiatedByMappingOptions = this.initiatedByMappingOptions.toObject();
      }
      if (this.transferTimesOptions != null) {
        data.transferTimesOptions = this.transferTimesOptions.toObject();
      }
      if (this.badgeIdsOptions != null) {
        data.badgeIdsOptions = this.badgeIdsOptions.toObject();
      }
      if (this.ownershipTimesOptions != null) {
        data.ownershipTimesOptions = this.ownershipTimesOptions.toObject();
      }
      if (this.isApproved != null) {
        data.isApproved = this.isApproved;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_fromMappingOptions)
        writer.writeMessage(1, this.fromMappingOptions, () => this.fromMappingOptions.serialize(writer));
      if (this.has_toMappingOptions)
        writer.writeMessage(2, this.toMappingOptions, () => this.toMappingOptions.serialize(writer));
      if (this.has_initiatedByMappingOptions)
        writer.writeMessage(3, this.initiatedByMappingOptions, () => this.initiatedByMappingOptions.serialize(writer));
      if (this.has_transferTimesOptions)
        writer.writeMessage(4, this.transferTimesOptions, () => this.transferTimesOptions.serialize(writer));
      if (this.has_badgeIdsOptions)
        writer.writeMessage(5, this.badgeIdsOptions, () => this.badgeIdsOptions.serialize(writer));
      if (this.has_ownershipTimesOptions)
        writer.writeMessage(6, this.ownershipTimesOptions, () => this.ownershipTimesOptions.serialize(writer));
      if (this.isApproved != false)
        writer.writeBool(7, this.isApproved);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IsCollectionTransferAllowed {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IsCollectionTransferAllowed();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.fromMappingOptions, () => message.fromMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 2:
            reader.readMessage(message.toMappingOptions, () => message.toMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 3:
            reader.readMessage(message.initiatedByMappingOptions, () => message.initiatedByMappingOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 4:
            reader.readMessage(message.transferTimesOptions, () => message.transferTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 5:
            reader.readMessage(message.badgeIdsOptions, () => message.badgeIdsOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 6:
            reader.readMessage(message.ownershipTimesOptions, () => message.ownershipTimesOptions = dependency_2.bitbadges.bitbadgeschain.badges.ValueOptions.deserialize(reader));
            break;
          case 7:
            message.isApproved = reader.readBool();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IsCollectionTransferAllowed {
      return IsCollectionTransferAllowed.deserialize(bytes);
    }
  }
  export class ManualBalances extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      balances?: dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("balances" in data && data.balances != undefined) {
          this.balances = data.balances;
        }
      }
    }
    get balances() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.Balance, 1) as dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
    }
    set balances(value: dependency_4.bitbadges.bitbadgeschain.badges.Balance[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
      balances?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
    }): ManualBalances {
      const message = new ManualBalances({});
      if (data.balances != null) {
        message.balances = data.balances.map(item => dependency_4.bitbadges.bitbadgeschain.badges.Balance.fromObject(item));
      }
      return message;
    }
    toObject() {
      const data: {
        balances?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
      } = {};
      if (this.balances != null) {
        data.balances = this.balances.map((item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.balances.length)
        writer.writeRepeatedMessage(1, this.balances, (item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.serialize(writer));
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ManualBalances {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ManualBalances();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.balances, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_4.bitbadges.bitbadgeschain.badges.Balance.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.Balance));
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ManualBalances {
      return ManualBalances.deserialize(bytes);
    }
  }
  export class IncrementedBalances extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      startBalances?: dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
      incrementBadgeIdsBy?: string;
      incrementOwnershipTimesBy?: string;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("startBalances" in data && data.startBalances != undefined) {
          this.startBalances = data.startBalances;
        }
        if ("incrementBadgeIdsBy" in data && data.incrementBadgeIdsBy != undefined) {
          this.incrementBadgeIdsBy = data.incrementBadgeIdsBy;
        }
        if ("incrementOwnershipTimesBy" in data && data.incrementOwnershipTimesBy != undefined) {
          this.incrementOwnershipTimesBy = data.incrementOwnershipTimesBy;
        }
      }
    }
    get startBalances() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.Balance, 1) as dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
    }
    set startBalances(value: dependency_4.bitbadges.bitbadgeschain.badges.Balance[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    get incrementBadgeIdsBy() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set incrementBadgeIdsBy(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get incrementOwnershipTimesBy() {
      return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set incrementOwnershipTimesBy(value: string) {
      pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
      startBalances?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
      incrementBadgeIdsBy?: string;
      incrementOwnershipTimesBy?: string;
    }): IncrementedBalances {
      const message = new IncrementedBalances({});
      if (data.startBalances != null) {
        message.startBalances = data.startBalances.map(item => dependency_4.bitbadges.bitbadgeschain.badges.Balance.fromObject(item));
      }
      if (data.incrementBadgeIdsBy != null) {
        message.incrementBadgeIdsBy = data.incrementBadgeIdsBy;
      }
      if (data.incrementOwnershipTimesBy != null) {
        message.incrementOwnershipTimesBy = data.incrementOwnershipTimesBy;
      }
      return message;
    }
    toObject() {
      const data: {
        startBalances?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
        incrementBadgeIdsBy?: string;
        incrementOwnershipTimesBy?: string;
      } = {};
      if (this.startBalances != null) {
        data.startBalances = this.startBalances.map((item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.toObject());
      }
      if (this.incrementBadgeIdsBy != null) {
        data.incrementBadgeIdsBy = this.incrementBadgeIdsBy;
      }
      if (this.incrementOwnershipTimesBy != null) {
        data.incrementOwnershipTimesBy = this.incrementOwnershipTimesBy;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.startBalances.length)
        writer.writeRepeatedMessage(1, this.startBalances, (item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.serialize(writer));
      if (this.incrementBadgeIdsBy.length)
        writer.writeString(2, this.incrementBadgeIdsBy);
      if (this.incrementOwnershipTimesBy.length)
        writer.writeString(3, this.incrementOwnershipTimesBy);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IncrementedBalances {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IncrementedBalances();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.startBalances, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_4.bitbadges.bitbadgeschain.badges.Balance.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.Balance));
            break;
          case 2:
            message.incrementBadgeIdsBy = reader.readString();
            break;
          case 3:
            message.incrementOwnershipTimesBy = reader.readString();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IncrementedBalances {
      return IncrementedBalances.deserialize(bytes);
    }
  }
  export class PredeterminedOrderCalculationMethod extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      useOverallNumTransfers?: boolean;
      usePerToAddressNumTransfers?: boolean;
      usePerFromAddressNumTransfers?: boolean;
      usePerInitiatedByAddressNumTransfers?: boolean;
      useMerkleChallengeLeafIndex?: boolean;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("useOverallNumTransfers" in data && data.useOverallNumTransfers != undefined) {
          this.useOverallNumTransfers = data.useOverallNumTransfers;
        }
        if ("usePerToAddressNumTransfers" in data && data.usePerToAddressNumTransfers != undefined) {
          this.usePerToAddressNumTransfers = data.usePerToAddressNumTransfers;
        }
        if ("usePerFromAddressNumTransfers" in data && data.usePerFromAddressNumTransfers != undefined) {
          this.usePerFromAddressNumTransfers = data.usePerFromAddressNumTransfers;
        }
        if ("usePerInitiatedByAddressNumTransfers" in data && data.usePerInitiatedByAddressNumTransfers != undefined) {
          this.usePerInitiatedByAddressNumTransfers = data.usePerInitiatedByAddressNumTransfers;
        }
        if ("useMerkleChallengeLeafIndex" in data && data.useMerkleChallengeLeafIndex != undefined) {
          this.useMerkleChallengeLeafIndex = data.useMerkleChallengeLeafIndex;
        }
      }
    }
    get useOverallNumTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set useOverallNumTransfers(value: boolean) {
      pb_1.Message.setField(this, 1, value);
    }
    get usePerToAddressNumTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set usePerToAddressNumTransfers(value: boolean) {
      pb_1.Message.setField(this, 2, value);
    }
    get usePerFromAddressNumTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
    }
    set usePerFromAddressNumTransfers(value: boolean) {
      pb_1.Message.setField(this, 3, value);
    }
    get usePerInitiatedByAddressNumTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
    }
    set usePerInitiatedByAddressNumTransfers(value: boolean) {
      pb_1.Message.setField(this, 4, value);
    }
    get useMerkleChallengeLeafIndex() {
      return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
    }
    set useMerkleChallengeLeafIndex(value: boolean) {
      pb_1.Message.setField(this, 5, value);
    }
    static fromObject(data: {
      useOverallNumTransfers?: boolean;
      usePerToAddressNumTransfers?: boolean;
      usePerFromAddressNumTransfers?: boolean;
      usePerInitiatedByAddressNumTransfers?: boolean;
      useMerkleChallengeLeafIndex?: boolean;
    }): PredeterminedOrderCalculationMethod {
      const message = new PredeterminedOrderCalculationMethod({});
      if (data.useOverallNumTransfers != null) {
        message.useOverallNumTransfers = data.useOverallNumTransfers;
      }
      if (data.usePerToAddressNumTransfers != null) {
        message.usePerToAddressNumTransfers = data.usePerToAddressNumTransfers;
      }
      if (data.usePerFromAddressNumTransfers != null) {
        message.usePerFromAddressNumTransfers = data.usePerFromAddressNumTransfers;
      }
      if (data.usePerInitiatedByAddressNumTransfers != null) {
        message.usePerInitiatedByAddressNumTransfers = data.usePerInitiatedByAddressNumTransfers;
      }
      if (data.useMerkleChallengeLeafIndex != null) {
        message.useMerkleChallengeLeafIndex = data.useMerkleChallengeLeafIndex;
      }
      return message;
    }
    toObject() {
      const data: {
        useOverallNumTransfers?: boolean;
        usePerToAddressNumTransfers?: boolean;
        usePerFromAddressNumTransfers?: boolean;
        usePerInitiatedByAddressNumTransfers?: boolean;
        useMerkleChallengeLeafIndex?: boolean;
      } = {};
      if (this.useOverallNumTransfers != null) {
        data.useOverallNumTransfers = this.useOverallNumTransfers;
      }
      if (this.usePerToAddressNumTransfers != null) {
        data.usePerToAddressNumTransfers = this.usePerToAddressNumTransfers;
      }
      if (this.usePerFromAddressNumTransfers != null) {
        data.usePerFromAddressNumTransfers = this.usePerFromAddressNumTransfers;
      }
      if (this.usePerInitiatedByAddressNumTransfers != null) {
        data.usePerInitiatedByAddressNumTransfers = this.usePerInitiatedByAddressNumTransfers;
      }
      if (this.useMerkleChallengeLeafIndex != null) {
        data.useMerkleChallengeLeafIndex = this.useMerkleChallengeLeafIndex;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.useOverallNumTransfers != false)
        writer.writeBool(1, this.useOverallNumTransfers);
      if (this.usePerToAddressNumTransfers != false)
        writer.writeBool(2, this.usePerToAddressNumTransfers);
      if (this.usePerFromAddressNumTransfers != false)
        writer.writeBool(3, this.usePerFromAddressNumTransfers);
      if (this.usePerInitiatedByAddressNumTransfers != false)
        writer.writeBool(4, this.usePerInitiatedByAddressNumTransfers);
      if (this.useMerkleChallengeLeafIndex != false)
        writer.writeBool(5, this.useMerkleChallengeLeafIndex);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PredeterminedOrderCalculationMethod {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PredeterminedOrderCalculationMethod();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.useOverallNumTransfers = reader.readBool();
            break;
          case 2:
            message.usePerToAddressNumTransfers = reader.readBool();
            break;
          case 3:
            message.usePerFromAddressNumTransfers = reader.readBool();
            break;
          case 4:
            message.usePerInitiatedByAddressNumTransfers = reader.readBool();
            break;
          case 5:
            message.useMerkleChallengeLeafIndex = reader.readBool();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): PredeterminedOrderCalculationMethod {
      return PredeterminedOrderCalculationMethod.deserialize(bytes);
    }
  }
  export class PredeterminedBalances extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      precalculationId?: string;
      manualBalances?: ManualBalances[];
      incrementedBalances?: IncrementedBalances;
      orderCalculationMethod?: PredeterminedOrderCalculationMethod;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("precalculationId" in data && data.precalculationId != undefined) {
          this.precalculationId = data.precalculationId;
        }
        if ("manualBalances" in data && data.manualBalances != undefined) {
          this.manualBalances = data.manualBalances;
        }
        if ("incrementedBalances" in data && data.incrementedBalances != undefined) {
          this.incrementedBalances = data.incrementedBalances;
        }
        if ("orderCalculationMethod" in data && data.orderCalculationMethod != undefined) {
          this.orderCalculationMethod = data.orderCalculationMethod;
        }
      }
    }
    get precalculationId() {
      return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set precalculationId(value: string) {
      pb_1.Message.setField(this, 4, value);
    }
    get manualBalances() {
      return pb_1.Message.getRepeatedWrapperField(this, ManualBalances, 1) as ManualBalances[];
    }
    set manualBalances(value: ManualBalances[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    get incrementedBalances() {
      return pb_1.Message.getWrapperField(this, IncrementedBalances, 2) as IncrementedBalances;
    }
    set incrementedBalances(value: IncrementedBalances) {
      pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_incrementedBalances() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get orderCalculationMethod() {
      return pb_1.Message.getWrapperField(this, PredeterminedOrderCalculationMethod, 3) as PredeterminedOrderCalculationMethod;
    }
    set orderCalculationMethod(value: PredeterminedOrderCalculationMethod) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_orderCalculationMethod() {
      return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
      precalculationId?: string;
      manualBalances?: ReturnType<typeof ManualBalances.prototype.toObject>[];
      incrementedBalances?: ReturnType<typeof IncrementedBalances.prototype.toObject>;
      orderCalculationMethod?: ReturnType<typeof PredeterminedOrderCalculationMethod.prototype.toObject>;
    }): PredeterminedBalances {
      const message = new PredeterminedBalances({});
      if (data.precalculationId != null) {
        message.precalculationId = data.precalculationId;
      }
      if (data.manualBalances != null) {
        message.manualBalances = data.manualBalances.map(item => ManualBalances.fromObject(item));
      }
      if (data.incrementedBalances != null) {
        message.incrementedBalances = IncrementedBalances.fromObject(data.incrementedBalances);
      }
      if (data.orderCalculationMethod != null) {
        message.orderCalculationMethod = PredeterminedOrderCalculationMethod.fromObject(data.orderCalculationMethod);
      }
      return message;
    }
    toObject() {
      const data: {
        precalculationId?: string;
        manualBalances?: ReturnType<typeof ManualBalances.prototype.toObject>[];
        incrementedBalances?: ReturnType<typeof IncrementedBalances.prototype.toObject>;
        orderCalculationMethod?: ReturnType<typeof PredeterminedOrderCalculationMethod.prototype.toObject>;
      } = {};
      if (this.precalculationId != null) {
        data.precalculationId = this.precalculationId;
      }
      if (this.manualBalances != null) {
        data.manualBalances = this.manualBalances.map((item: ManualBalances) => item.toObject());
      }
      if (this.incrementedBalances != null) {
        data.incrementedBalances = this.incrementedBalances.toObject();
      }
      if (this.orderCalculationMethod != null) {
        data.orderCalculationMethod = this.orderCalculationMethod.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.precalculationId.length)
        writer.writeString(4, this.precalculationId);
      if (this.manualBalances.length)
        writer.writeRepeatedMessage(1, this.manualBalances, (item: ManualBalances) => item.serialize(writer));
      if (this.has_incrementedBalances)
        writer.writeMessage(2, this.incrementedBalances, () => this.incrementedBalances.serialize(writer));
      if (this.has_orderCalculationMethod)
        writer.writeMessage(3, this.orderCalculationMethod, () => this.orderCalculationMethod.serialize(writer));
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PredeterminedBalances {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PredeterminedBalances();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 4:
            message.precalculationId = reader.readString();
            break;
          case 1:
            reader.readMessage(message.manualBalances, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ManualBalances.deserialize(reader), ManualBalances));
            break;
          case 2:
            reader.readMessage(message.incrementedBalances, () => message.incrementedBalances = IncrementedBalances.deserialize(reader));
            break;
          case 3:
            reader.readMessage(message.orderCalculationMethod, () => message.orderCalculationMethod = PredeterminedOrderCalculationMethod.deserialize(reader));
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): PredeterminedBalances {
      return PredeterminedBalances.deserialize(bytes);
    }
  }
  export class ApprovalAmounts extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      overallApprovalAmount?: string;
      perToAddressApprovalAmount?: string;
      perFromAddressApprovalAmount?: string;
      perInitiatedByAddressApprovalAmount?: string;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("overallApprovalAmount" in data && data.overallApprovalAmount != undefined) {
          this.overallApprovalAmount = data.overallApprovalAmount;
        }
        if ("perToAddressApprovalAmount" in data && data.perToAddressApprovalAmount != undefined) {
          this.perToAddressApprovalAmount = data.perToAddressApprovalAmount;
        }
        if ("perFromAddressApprovalAmount" in data && data.perFromAddressApprovalAmount != undefined) {
          this.perFromAddressApprovalAmount = data.perFromAddressApprovalAmount;
        }
        if ("perInitiatedByAddressApprovalAmount" in data && data.perInitiatedByAddressApprovalAmount != undefined) {
          this.perInitiatedByAddressApprovalAmount = data.perInitiatedByAddressApprovalAmount;
        }
      }
    }
    get overallApprovalAmount() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set overallApprovalAmount(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get perToAddressApprovalAmount() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set perToAddressApprovalAmount(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get perFromAddressApprovalAmount() {
      return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set perFromAddressApprovalAmount(value: string) {
      pb_1.Message.setField(this, 3, value);
    }
    get perInitiatedByAddressApprovalAmount() {
      return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set perInitiatedByAddressApprovalAmount(value: string) {
      pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
      overallApprovalAmount?: string;
      perToAddressApprovalAmount?: string;
      perFromAddressApprovalAmount?: string;
      perInitiatedByAddressApprovalAmount?: string;
    }): ApprovalAmounts {
      const message = new ApprovalAmounts({});
      if (data.overallApprovalAmount != null) {
        message.overallApprovalAmount = data.overallApprovalAmount;
      }
      if (data.perToAddressApprovalAmount != null) {
        message.perToAddressApprovalAmount = data.perToAddressApprovalAmount;
      }
      if (data.perFromAddressApprovalAmount != null) {
        message.perFromAddressApprovalAmount = data.perFromAddressApprovalAmount;
      }
      if (data.perInitiatedByAddressApprovalAmount != null) {
        message.perInitiatedByAddressApprovalAmount = data.perInitiatedByAddressApprovalAmount;
      }
      return message;
    }
    toObject() {
      const data: {
        overallApprovalAmount?: string;
        perToAddressApprovalAmount?: string;
        perFromAddressApprovalAmount?: string;
        perInitiatedByAddressApprovalAmount?: string;
      } = {};
      if (this.overallApprovalAmount != null) {
        data.overallApprovalAmount = this.overallApprovalAmount;
      }
      if (this.perToAddressApprovalAmount != null) {
        data.perToAddressApprovalAmount = this.perToAddressApprovalAmount;
      }
      if (this.perFromAddressApprovalAmount != null) {
        data.perFromAddressApprovalAmount = this.perFromAddressApprovalAmount;
      }
      if (this.perInitiatedByAddressApprovalAmount != null) {
        data.perInitiatedByAddressApprovalAmount = this.perInitiatedByAddressApprovalAmount;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.overallApprovalAmount.length)
        writer.writeString(1, this.overallApprovalAmount);
      if (this.perToAddressApprovalAmount.length)
        writer.writeString(2, this.perToAddressApprovalAmount);
      if (this.perFromAddressApprovalAmount.length)
        writer.writeString(3, this.perFromAddressApprovalAmount);
      if (this.perInitiatedByAddressApprovalAmount.length)
        writer.writeString(4, this.perInitiatedByAddressApprovalAmount);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ApprovalAmounts {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ApprovalAmounts();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.overallApprovalAmount = reader.readString();
            break;
          case 2:
            message.perToAddressApprovalAmount = reader.readString();
            break;
          case 3:
            message.perFromAddressApprovalAmount = reader.readString();
            break;
          case 4:
            message.perInitiatedByAddressApprovalAmount = reader.readString();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ApprovalAmounts {
      return ApprovalAmounts.deserialize(bytes);
    }
  }
  export class MaxNumTransfers extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      overallMaxNumTransfers?: string;
      perToAddressMaxNumTransfers?: string;
      perFromAddressMaxNumTransfers?: string;
      perInitiatedByAddressMaxNumTransfers?: string;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("overallMaxNumTransfers" in data && data.overallMaxNumTransfers != undefined) {
          this.overallMaxNumTransfers = data.overallMaxNumTransfers;
        }
        if ("perToAddressMaxNumTransfers" in data && data.perToAddressMaxNumTransfers != undefined) {
          this.perToAddressMaxNumTransfers = data.perToAddressMaxNumTransfers;
        }
        if ("perFromAddressMaxNumTransfers" in data && data.perFromAddressMaxNumTransfers != undefined) {
          this.perFromAddressMaxNumTransfers = data.perFromAddressMaxNumTransfers;
        }
        if ("perInitiatedByAddressMaxNumTransfers" in data && data.perInitiatedByAddressMaxNumTransfers != undefined) {
          this.perInitiatedByAddressMaxNumTransfers = data.perInitiatedByAddressMaxNumTransfers;
        }
      }
    }
    get overallMaxNumTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set overallMaxNumTransfers(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get perToAddressMaxNumTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set perToAddressMaxNumTransfers(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get perFromAddressMaxNumTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set perFromAddressMaxNumTransfers(value: string) {
      pb_1.Message.setField(this, 3, value);
    }
    get perInitiatedByAddressMaxNumTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set perInitiatedByAddressMaxNumTransfers(value: string) {
      pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
      overallMaxNumTransfers?: string;
      perToAddressMaxNumTransfers?: string;
      perFromAddressMaxNumTransfers?: string;
      perInitiatedByAddressMaxNumTransfers?: string;
    }): MaxNumTransfers {
      const message = new MaxNumTransfers({});
      if (data.overallMaxNumTransfers != null) {
        message.overallMaxNumTransfers = data.overallMaxNumTransfers;
      }
      if (data.perToAddressMaxNumTransfers != null) {
        message.perToAddressMaxNumTransfers = data.perToAddressMaxNumTransfers;
      }
      if (data.perFromAddressMaxNumTransfers != null) {
        message.perFromAddressMaxNumTransfers = data.perFromAddressMaxNumTransfers;
      }
      if (data.perInitiatedByAddressMaxNumTransfers != null) {
        message.perInitiatedByAddressMaxNumTransfers = data.perInitiatedByAddressMaxNumTransfers;
      }
      return message;
    }
    toObject() {
      const data: {
        overallMaxNumTransfers?: string;
        perToAddressMaxNumTransfers?: string;
        perFromAddressMaxNumTransfers?: string;
        perInitiatedByAddressMaxNumTransfers?: string;
      } = {};
      if (this.overallMaxNumTransfers != null) {
        data.overallMaxNumTransfers = this.overallMaxNumTransfers;
      }
      if (this.perToAddressMaxNumTransfers != null) {
        data.perToAddressMaxNumTransfers = this.perToAddressMaxNumTransfers;
      }
      if (this.perFromAddressMaxNumTransfers != null) {
        data.perFromAddressMaxNumTransfers = this.perFromAddressMaxNumTransfers;
      }
      if (this.perInitiatedByAddressMaxNumTransfers != null) {
        data.perInitiatedByAddressMaxNumTransfers = this.perInitiatedByAddressMaxNumTransfers;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.overallMaxNumTransfers.length)
        writer.writeString(1, this.overallMaxNumTransfers);
      if (this.perToAddressMaxNumTransfers.length)
        writer.writeString(2, this.perToAddressMaxNumTransfers);
      if (this.perFromAddressMaxNumTransfers.length)
        writer.writeString(3, this.perFromAddressMaxNumTransfers);
      if (this.perInitiatedByAddressMaxNumTransfers.length)
        writer.writeString(4, this.perInitiatedByAddressMaxNumTransfers);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MaxNumTransfers {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MaxNumTransfers();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.overallMaxNumTransfers = reader.readString();
            break;
          case 2:
            message.perToAddressMaxNumTransfers = reader.readString();
            break;
          case 3:
            message.perFromAddressMaxNumTransfers = reader.readString();
            break;
          case 4:
            message.perInitiatedByAddressMaxNumTransfers = reader.readString();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MaxNumTransfers {
      return MaxNumTransfers.deserialize(bytes);
    }
  }
  export class ApprovalsTracker extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      numTransfers?: string;
      amounts?: dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("numTransfers" in data && data.numTransfers != undefined) {
          this.numTransfers = data.numTransfers;
        }
        if ("amounts" in data && data.amounts != undefined) {
          this.amounts = data.amounts;
        }
      }
    }
    get numTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set numTransfers(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get amounts() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.Balance, 2) as dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
    }
    set amounts(value: dependency_4.bitbadges.bitbadgeschain.badges.Balance[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
      numTransfers?: string;
      amounts?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
    }): ApprovalsTracker {
      const message = new ApprovalsTracker({});
      if (data.numTransfers != null) {
        message.numTransfers = data.numTransfers;
      }
      if (data.amounts != null) {
        message.amounts = data.amounts.map(item => dependency_4.bitbadges.bitbadgeschain.badges.Balance.fromObject(item));
      }
      return message;
    }
    toObject() {
      const data: {
        numTransfers?: string;
        amounts?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
      } = {};
      if (this.numTransfers != null) {
        data.numTransfers = this.numTransfers;
      }
      if (this.amounts != null) {
        data.amounts = this.amounts.map((item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.numTransfers.length)
        writer.writeString(1, this.numTransfers);
      if (this.amounts.length)
        writer.writeRepeatedMessage(2, this.amounts, (item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.serialize(writer));
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ApprovalsTracker {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ApprovalsTracker();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.numTransfers = reader.readString();
            break;
          case 2:
            reader.readMessage(message.amounts, () => pb_1.Message.addToRepeatedWrapperField(message, 2, dependency_4.bitbadges.bitbadgeschain.badges.Balance.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.Balance));
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ApprovalsTracker {
      return ApprovalsTracker.deserialize(bytes);
    }
  }
  export class ApprovalDetails extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      approvalTrackerId?: string;
      uri?: string;
      customData?: string;
      mustOwnBadges?: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges[];
      merkleChallenges?: MerkleChallenge[];
      predeterminedBalances?: PredeterminedBalances;
      approvalAmounts?: ApprovalAmounts;
      maxNumTransfers?: MaxNumTransfers;
      requireToEqualsInitiatedBy?: boolean;
      requireFromEqualsInitiatedBy?: boolean;
      requireToDoesNotEqualInitiatedBy?: boolean;
      requireFromDoesNotEqualInitiatedBy?: boolean;
      overridesFromApprovedOutgoingTransfers?: boolean;
      overridesToApprovedIncomingTransfers?: boolean;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("approvalTrackerId" in data && data.approvalTrackerId != undefined) {
          this.approvalTrackerId = data.approvalTrackerId;
        }
        if ("uri" in data && data.uri != undefined) {
          this.uri = data.uri;
        }
        if ("customData" in data && data.customData != undefined) {
          this.customData = data.customData;
        }
        if ("mustOwnBadges" in data && data.mustOwnBadges != undefined) {
          this.mustOwnBadges = data.mustOwnBadges;
        }
        if ("merkleChallenges" in data && data.merkleChallenges != undefined) {
          this.merkleChallenges = data.merkleChallenges;
        }
        if ("predeterminedBalances" in data && data.predeterminedBalances != undefined) {
          this.predeterminedBalances = data.predeterminedBalances;
        }
        if ("approvalAmounts" in data && data.approvalAmounts != undefined) {
          this.approvalAmounts = data.approvalAmounts;
        }
        if ("maxNumTransfers" in data && data.maxNumTransfers != undefined) {
          this.maxNumTransfers = data.maxNumTransfers;
        }
        if ("requireToEqualsInitiatedBy" in data && data.requireToEqualsInitiatedBy != undefined) {
          this.requireToEqualsInitiatedBy = data.requireToEqualsInitiatedBy;
        }
        if ("requireFromEqualsInitiatedBy" in data && data.requireFromEqualsInitiatedBy != undefined) {
          this.requireFromEqualsInitiatedBy = data.requireFromEqualsInitiatedBy;
        }
        if ("requireToDoesNotEqualInitiatedBy" in data && data.requireToDoesNotEqualInitiatedBy != undefined) {
          this.requireToDoesNotEqualInitiatedBy = data.requireToDoesNotEqualInitiatedBy;
        }
        if ("requireFromDoesNotEqualInitiatedBy" in data && data.requireFromDoesNotEqualInitiatedBy != undefined) {
          this.requireFromDoesNotEqualInitiatedBy = data.requireFromDoesNotEqualInitiatedBy;
        }
        if ("overridesFromApprovedOutgoingTransfers" in data && data.overridesFromApprovedOutgoingTransfers != undefined) {
          this.overridesFromApprovedOutgoingTransfers = data.overridesFromApprovedOutgoingTransfers;
        }
        if ("overridesToApprovedIncomingTransfers" in data && data.overridesToApprovedIncomingTransfers != undefined) {
          this.overridesToApprovedIncomingTransfers = data.overridesToApprovedIncomingTransfers;
        }
      }
    }
    get approvalTrackerId() {
      return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set approvalTrackerId(value: string) {
      pb_1.Message.setField(this, 6, value);
    }
    get uri() {
      return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
    }
    set uri(value: string) {
      pb_1.Message.setField(this, 7, value);
    }
    get customData() {
      return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
    }
    set customData(value: string) {
      pb_1.Message.setField(this, 8, value);
    }
    get mustOwnBadges() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges, 1) as dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges[];
    }
    set mustOwnBadges(value: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    get merkleChallenges() {
      return pb_1.Message.getRepeatedWrapperField(this, MerkleChallenge, 2) as MerkleChallenge[];
    }
    set merkleChallenges(value: MerkleChallenge[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get predeterminedBalances() {
      return pb_1.Message.getWrapperField(this, PredeterminedBalances, 3) as PredeterminedBalances;
    }
    set predeterminedBalances(value: PredeterminedBalances) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_predeterminedBalances() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get approvalAmounts() {
      return pb_1.Message.getWrapperField(this, ApprovalAmounts, 4) as ApprovalAmounts;
    }
    set approvalAmounts(value: ApprovalAmounts) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_approvalAmounts() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get maxNumTransfers() {
      return pb_1.Message.getWrapperField(this, MaxNumTransfers, 5) as MaxNumTransfers;
    }
    set maxNumTransfers(value: MaxNumTransfers) {
      pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_maxNumTransfers() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get requireToEqualsInitiatedBy() {
      return pb_1.Message.getFieldWithDefault(this, 9, false) as boolean;
    }
    set requireToEqualsInitiatedBy(value: boolean) {
      pb_1.Message.setField(this, 9, value);
    }
    get requireFromEqualsInitiatedBy() {
      return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
    }
    set requireFromEqualsInitiatedBy(value: boolean) {
      pb_1.Message.setField(this, 10, value);
    }
    get requireToDoesNotEqualInitiatedBy() {
      return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
    }
    set requireToDoesNotEqualInitiatedBy(value: boolean) {
      pb_1.Message.setField(this, 11, value);
    }
    get requireFromDoesNotEqualInitiatedBy() {
      return pb_1.Message.getFieldWithDefault(this, 12, false) as boolean;
    }
    set requireFromDoesNotEqualInitiatedBy(value: boolean) {
      pb_1.Message.setField(this, 12, value);
    }
    get overridesFromApprovedOutgoingTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 13, false) as boolean;
    }
    set overridesFromApprovedOutgoingTransfers(value: boolean) {
      pb_1.Message.setField(this, 13, value);
    }
    get overridesToApprovedIncomingTransfers() {
      return pb_1.Message.getFieldWithDefault(this, 14, false) as boolean;
    }
    set overridesToApprovedIncomingTransfers(value: boolean) {
      pb_1.Message.setField(this, 14, value);
    }
    static fromObject(data: {
      approvalTrackerId?: string;
      uri?: string;
      customData?: string;
      mustOwnBadges?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.prototype.toObject>[];
      merkleChallenges?: ReturnType<typeof MerkleChallenge.prototype.toObject>[];
      predeterminedBalances?: ReturnType<typeof PredeterminedBalances.prototype.toObject>;
      approvalAmounts?: ReturnType<typeof ApprovalAmounts.prototype.toObject>;
      maxNumTransfers?: ReturnType<typeof MaxNumTransfers.prototype.toObject>;
      requireToEqualsInitiatedBy?: boolean;
      requireFromEqualsInitiatedBy?: boolean;
      requireToDoesNotEqualInitiatedBy?: boolean;
      requireFromDoesNotEqualInitiatedBy?: boolean;
      overridesFromApprovedOutgoingTransfers?: boolean;
      overridesToApprovedIncomingTransfers?: boolean;
    }): ApprovalDetails {
      const message = new ApprovalDetails({});
      if (data.approvalTrackerId != null) {
        message.approvalTrackerId = data.approvalTrackerId;
      }
      if (data.uri != null) {
        message.uri = data.uri;
      }
      if (data.customData != null) {
        message.customData = data.customData;
      }
      if (data.mustOwnBadges != null) {
        message.mustOwnBadges = data.mustOwnBadges.map(item => dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.fromObject(item));
      }
      if (data.merkleChallenges != null) {
        message.merkleChallenges = data.merkleChallenges.map(item => MerkleChallenge.fromObject(item));
      }
      if (data.predeterminedBalances != null) {
        message.predeterminedBalances = PredeterminedBalances.fromObject(data.predeterminedBalances);
      }
      if (data.approvalAmounts != null) {
        message.approvalAmounts = ApprovalAmounts.fromObject(data.approvalAmounts);
      }
      if (data.maxNumTransfers != null) {
        message.maxNumTransfers = MaxNumTransfers.fromObject(data.maxNumTransfers);
      }
      if (data.requireToEqualsInitiatedBy != null) {
        message.requireToEqualsInitiatedBy = data.requireToEqualsInitiatedBy;
      }
      if (data.requireFromEqualsInitiatedBy != null) {
        message.requireFromEqualsInitiatedBy = data.requireFromEqualsInitiatedBy;
      }
      if (data.requireToDoesNotEqualInitiatedBy != null) {
        message.requireToDoesNotEqualInitiatedBy = data.requireToDoesNotEqualInitiatedBy;
      }
      if (data.requireFromDoesNotEqualInitiatedBy != null) {
        message.requireFromDoesNotEqualInitiatedBy = data.requireFromDoesNotEqualInitiatedBy;
      }
      if (data.overridesFromApprovedOutgoingTransfers != null) {
        message.overridesFromApprovedOutgoingTransfers = data.overridesFromApprovedOutgoingTransfers;
      }
      if (data.overridesToApprovedIncomingTransfers != null) {
        message.overridesToApprovedIncomingTransfers = data.overridesToApprovedIncomingTransfers;
      }
      return message;
    }
    toObject() {
      const data: {
        approvalTrackerId?: string;
        uri?: string;
        customData?: string;
        mustOwnBadges?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.prototype.toObject>[];
        merkleChallenges?: ReturnType<typeof MerkleChallenge.prototype.toObject>[];
        predeterminedBalances?: ReturnType<typeof PredeterminedBalances.prototype.toObject>;
        approvalAmounts?: ReturnType<typeof ApprovalAmounts.prototype.toObject>;
        maxNumTransfers?: ReturnType<typeof MaxNumTransfers.prototype.toObject>;
        requireToEqualsInitiatedBy?: boolean;
        requireFromEqualsInitiatedBy?: boolean;
        requireToDoesNotEqualInitiatedBy?: boolean;
        requireFromDoesNotEqualInitiatedBy?: boolean;
        overridesFromApprovedOutgoingTransfers?: boolean;
        overridesToApprovedIncomingTransfers?: boolean;
      } = {};
      if (this.approvalTrackerId != null) {
        data.approvalTrackerId = this.approvalTrackerId;
      }
      if (this.uri != null) {
        data.uri = this.uri;
      }
      if (this.customData != null) {
        data.customData = this.customData;
      }
      if (this.mustOwnBadges != null) {
        data.mustOwnBadges = this.mustOwnBadges.map((item: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges) => item.toObject());
      }
      if (this.merkleChallenges != null) {
        data.merkleChallenges = this.merkleChallenges.map((item: MerkleChallenge) => item.toObject());
      }
      if (this.predeterminedBalances != null) {
        data.predeterminedBalances = this.predeterminedBalances.toObject();
      }
      if (this.approvalAmounts != null) {
        data.approvalAmounts = this.approvalAmounts.toObject();
      }
      if (this.maxNumTransfers != null) {
        data.maxNumTransfers = this.maxNumTransfers.toObject();
      }
      if (this.requireToEqualsInitiatedBy != null) {
        data.requireToEqualsInitiatedBy = this.requireToEqualsInitiatedBy;
      }
      if (this.requireFromEqualsInitiatedBy != null) {
        data.requireFromEqualsInitiatedBy = this.requireFromEqualsInitiatedBy;
      }
      if (this.requireToDoesNotEqualInitiatedBy != null) {
        data.requireToDoesNotEqualInitiatedBy = this.requireToDoesNotEqualInitiatedBy;
      }
      if (this.requireFromDoesNotEqualInitiatedBy != null) {
        data.requireFromDoesNotEqualInitiatedBy = this.requireFromDoesNotEqualInitiatedBy;
      }
      if (this.overridesFromApprovedOutgoingTransfers != null) {
        data.overridesFromApprovedOutgoingTransfers = this.overridesFromApprovedOutgoingTransfers;
      }
      if (this.overridesToApprovedIncomingTransfers != null) {
        data.overridesToApprovedIncomingTransfers = this.overridesToApprovedIncomingTransfers;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.approvalTrackerId.length)
        writer.writeString(6, this.approvalTrackerId);
      if (this.uri.length)
        writer.writeString(7, this.uri);
      if (this.customData.length)
        writer.writeString(8, this.customData);
      if (this.mustOwnBadges.length)
        writer.writeRepeatedMessage(1, this.mustOwnBadges, (item: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges) => item.serialize(writer));
      if (this.merkleChallenges.length)
        writer.writeRepeatedMessage(2, this.merkleChallenges, (item: MerkleChallenge) => item.serialize(writer));
      if (this.has_predeterminedBalances)
        writer.writeMessage(3, this.predeterminedBalances, () => this.predeterminedBalances.serialize(writer));
      if (this.has_approvalAmounts)
        writer.writeMessage(4, this.approvalAmounts, () => this.approvalAmounts.serialize(writer));
      if (this.has_maxNumTransfers)
        writer.writeMessage(5, this.maxNumTransfers, () => this.maxNumTransfers.serialize(writer));
      if (this.requireToEqualsInitiatedBy != false)
        writer.writeBool(9, this.requireToEqualsInitiatedBy);
      if (this.requireFromEqualsInitiatedBy != false)
        writer.writeBool(10, this.requireFromEqualsInitiatedBy);
      if (this.requireToDoesNotEqualInitiatedBy != false)
        writer.writeBool(11, this.requireToDoesNotEqualInitiatedBy);
      if (this.requireFromDoesNotEqualInitiatedBy != false)
        writer.writeBool(12, this.requireFromDoesNotEqualInitiatedBy);
      if (this.overridesFromApprovedOutgoingTransfers != false)
        writer.writeBool(13, this.overridesFromApprovedOutgoingTransfers);
      if (this.overridesToApprovedIncomingTransfers != false)
        writer.writeBool(14, this.overridesToApprovedIncomingTransfers);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ApprovalDetails {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ApprovalDetails();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 6:
            message.approvalTrackerId = reader.readString();
            break;
          case 7:
            message.uri = reader.readString();
            break;
          case 8:
            message.customData = reader.readString();
            break;
          case 1:
            reader.readMessage(message.mustOwnBadges, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges));
            break;
          case 2:
            reader.readMessage(message.merkleChallenges, () => pb_1.Message.addToRepeatedWrapperField(message, 2, MerkleChallenge.deserialize(reader), MerkleChallenge));
            break;
          case 3:
            reader.readMessage(message.predeterminedBalances, () => message.predeterminedBalances = PredeterminedBalances.deserialize(reader));
            break;
          case 4:
            reader.readMessage(message.approvalAmounts, () => message.approvalAmounts = ApprovalAmounts.deserialize(reader));
            break;
          case 5:
            reader.readMessage(message.maxNumTransfers, () => message.maxNumTransfers = MaxNumTransfers.deserialize(reader));
            break;
          case 9:
            message.requireToEqualsInitiatedBy = reader.readBool();
            break;
          case 10:
            message.requireFromEqualsInitiatedBy = reader.readBool();
            break;
          case 11:
            message.requireToDoesNotEqualInitiatedBy = reader.readBool();
            break;
          case 12:
            message.requireFromDoesNotEqualInitiatedBy = reader.readBool();
            break;
          case 13:
            message.overridesFromApprovedOutgoingTransfers = reader.readBool();
            break;
          case 14:
            message.overridesToApprovedIncomingTransfers = reader.readBool();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ApprovalDetails {
      return ApprovalDetails.deserialize(bytes);
    }
  }
  export class OutgoingApprovalDetails extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      approvalTrackerId?: string;
      uri?: string;
      customData?: string;
      mustOwnBadges?: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges[];
      merkleChallenges?: MerkleChallenge[];
      predeterminedBalances?: PredeterminedBalances;
      approvalAmounts?: ApprovalAmounts;
      maxNumTransfers?: MaxNumTransfers;
      requireToEqualsInitiatedBy?: boolean;
      requireToDoesNotEqualInitiatedBy?: boolean;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("approvalTrackerId" in data && data.approvalTrackerId != undefined) {
          this.approvalTrackerId = data.approvalTrackerId;
        }
        if ("uri" in data && data.uri != undefined) {
          this.uri = data.uri;
        }
        if ("customData" in data && data.customData != undefined) {
          this.customData = data.customData;
        }
        if ("mustOwnBadges" in data && data.mustOwnBadges != undefined) {
          this.mustOwnBadges = data.mustOwnBadges;
        }
        if ("merkleChallenges" in data && data.merkleChallenges != undefined) {
          this.merkleChallenges = data.merkleChallenges;
        }
        if ("predeterminedBalances" in data && data.predeterminedBalances != undefined) {
          this.predeterminedBalances = data.predeterminedBalances;
        }
        if ("approvalAmounts" in data && data.approvalAmounts != undefined) {
          this.approvalAmounts = data.approvalAmounts;
        }
        if ("maxNumTransfers" in data && data.maxNumTransfers != undefined) {
          this.maxNumTransfers = data.maxNumTransfers;
        }
        if ("requireToEqualsInitiatedBy" in data && data.requireToEqualsInitiatedBy != undefined) {
          this.requireToEqualsInitiatedBy = data.requireToEqualsInitiatedBy;
        }
        if ("requireToDoesNotEqualInitiatedBy" in data && data.requireToDoesNotEqualInitiatedBy != undefined) {
          this.requireToDoesNotEqualInitiatedBy = data.requireToDoesNotEqualInitiatedBy;
        }
      }
    }
    get approvalTrackerId() {
      return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set approvalTrackerId(value: string) {
      pb_1.Message.setField(this, 6, value);
    }
    get uri() {
      return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
    }
    set uri(value: string) {
      pb_1.Message.setField(this, 7, value);
    }
    get customData() {
      return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
    }
    set customData(value: string) {
      pb_1.Message.setField(this, 8, value);
    }
    get mustOwnBadges() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges, 1) as dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges[];
    }
    set mustOwnBadges(value: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    get merkleChallenges() {
      return pb_1.Message.getRepeatedWrapperField(this, MerkleChallenge, 2) as MerkleChallenge[];
    }
    set merkleChallenges(value: MerkleChallenge[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get predeterminedBalances() {
      return pb_1.Message.getWrapperField(this, PredeterminedBalances, 3) as PredeterminedBalances;
    }
    set predeterminedBalances(value: PredeterminedBalances) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_predeterminedBalances() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get approvalAmounts() {
      return pb_1.Message.getWrapperField(this, ApprovalAmounts, 4) as ApprovalAmounts;
    }
    set approvalAmounts(value: ApprovalAmounts) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_approvalAmounts() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get maxNumTransfers() {
      return pb_1.Message.getWrapperField(this, MaxNumTransfers, 5) as MaxNumTransfers;
    }
    set maxNumTransfers(value: MaxNumTransfers) {
      pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_maxNumTransfers() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get requireToEqualsInitiatedBy() {
      return pb_1.Message.getFieldWithDefault(this, 9, false) as boolean;
    }
    set requireToEqualsInitiatedBy(value: boolean) {
      pb_1.Message.setField(this, 9, value);
    }
    get requireToDoesNotEqualInitiatedBy() {
      return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
    }
    set requireToDoesNotEqualInitiatedBy(value: boolean) {
      pb_1.Message.setField(this, 11, value);
    }
    static fromObject(data: {
      approvalTrackerId?: string;
      uri?: string;
      customData?: string;
      mustOwnBadges?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.prototype.toObject>[];
      merkleChallenges?: ReturnType<typeof MerkleChallenge.prototype.toObject>[];
      predeterminedBalances?: ReturnType<typeof PredeterminedBalances.prototype.toObject>;
      approvalAmounts?: ReturnType<typeof ApprovalAmounts.prototype.toObject>;
      maxNumTransfers?: ReturnType<typeof MaxNumTransfers.prototype.toObject>;
      requireToEqualsInitiatedBy?: boolean;
      requireToDoesNotEqualInitiatedBy?: boolean;
    }): OutgoingApprovalDetails {
      const message = new OutgoingApprovalDetails({});
      if (data.approvalTrackerId != null) {
        message.approvalTrackerId = data.approvalTrackerId;
      }
      if (data.uri != null) {
        message.uri = data.uri;
      }
      if (data.customData != null) {
        message.customData = data.customData;
      }
      if (data.mustOwnBadges != null) {
        message.mustOwnBadges = data.mustOwnBadges.map(item => dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.fromObject(item));
      }
      if (data.merkleChallenges != null) {
        message.merkleChallenges = data.merkleChallenges.map(item => MerkleChallenge.fromObject(item));
      }
      if (data.predeterminedBalances != null) {
        message.predeterminedBalances = PredeterminedBalances.fromObject(data.predeterminedBalances);
      }
      if (data.approvalAmounts != null) {
        message.approvalAmounts = ApprovalAmounts.fromObject(data.approvalAmounts);
      }
      if (data.maxNumTransfers != null) {
        message.maxNumTransfers = MaxNumTransfers.fromObject(data.maxNumTransfers);
      }
      if (data.requireToEqualsInitiatedBy != null) {
        message.requireToEqualsInitiatedBy = data.requireToEqualsInitiatedBy;
      }
      if (data.requireToDoesNotEqualInitiatedBy != null) {
        message.requireToDoesNotEqualInitiatedBy = data.requireToDoesNotEqualInitiatedBy;
      }
      return message;
    }
    toObject() {
      const data: {
        approvalTrackerId?: string;
        uri?: string;
        customData?: string;
        mustOwnBadges?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.prototype.toObject>[];
        merkleChallenges?: ReturnType<typeof MerkleChallenge.prototype.toObject>[];
        predeterminedBalances?: ReturnType<typeof PredeterminedBalances.prototype.toObject>;
        approvalAmounts?: ReturnType<typeof ApprovalAmounts.prototype.toObject>;
        maxNumTransfers?: ReturnType<typeof MaxNumTransfers.prototype.toObject>;
        requireToEqualsInitiatedBy?: boolean;
        requireToDoesNotEqualInitiatedBy?: boolean;
      } = {};
      if (this.approvalTrackerId != null) {
        data.approvalTrackerId = this.approvalTrackerId;
      }
      if (this.uri != null) {
        data.uri = this.uri;
      }
      if (this.customData != null) {
        data.customData = this.customData;
      }
      if (this.mustOwnBadges != null) {
        data.mustOwnBadges = this.mustOwnBadges.map((item: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges) => item.toObject());
      }
      if (this.merkleChallenges != null) {
        data.merkleChallenges = this.merkleChallenges.map((item: MerkleChallenge) => item.toObject());
      }
      if (this.predeterminedBalances != null) {
        data.predeterminedBalances = this.predeterminedBalances.toObject();
      }
      if (this.approvalAmounts != null) {
        data.approvalAmounts = this.approvalAmounts.toObject();
      }
      if (this.maxNumTransfers != null) {
        data.maxNumTransfers = this.maxNumTransfers.toObject();
      }
      if (this.requireToEqualsInitiatedBy != null) {
        data.requireToEqualsInitiatedBy = this.requireToEqualsInitiatedBy;
      }
      if (this.requireToDoesNotEqualInitiatedBy != null) {
        data.requireToDoesNotEqualInitiatedBy = this.requireToDoesNotEqualInitiatedBy;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.approvalTrackerId.length)
        writer.writeString(6, this.approvalTrackerId);
      if (this.uri.length)
        writer.writeString(7, this.uri);
      if (this.customData.length)
        writer.writeString(8, this.customData);
      if (this.mustOwnBadges.length)
        writer.writeRepeatedMessage(1, this.mustOwnBadges, (item: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges) => item.serialize(writer));
      if (this.merkleChallenges.length)
        writer.writeRepeatedMessage(2, this.merkleChallenges, (item: MerkleChallenge) => item.serialize(writer));
      if (this.has_predeterminedBalances)
        writer.writeMessage(3, this.predeterminedBalances, () => this.predeterminedBalances.serialize(writer));
      if (this.has_approvalAmounts)
        writer.writeMessage(4, this.approvalAmounts, () => this.approvalAmounts.serialize(writer));
      if (this.has_maxNumTransfers)
        writer.writeMessage(5, this.maxNumTransfers, () => this.maxNumTransfers.serialize(writer));
      if (this.requireToEqualsInitiatedBy != false)
        writer.writeBool(9, this.requireToEqualsInitiatedBy);
      if (this.requireToDoesNotEqualInitiatedBy != false)
        writer.writeBool(11, this.requireToDoesNotEqualInitiatedBy);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OutgoingApprovalDetails {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OutgoingApprovalDetails();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 6:
            message.approvalTrackerId = reader.readString();
            break;
          case 7:
            message.uri = reader.readString();
            break;
          case 8:
            message.customData = reader.readString();
            break;
          case 1:
            reader.readMessage(message.mustOwnBadges, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges));
            break;
          case 2:
            reader.readMessage(message.merkleChallenges, () => pb_1.Message.addToRepeatedWrapperField(message, 2, MerkleChallenge.deserialize(reader), MerkleChallenge));
            break;
          case 3:
            reader.readMessage(message.predeterminedBalances, () => message.predeterminedBalances = PredeterminedBalances.deserialize(reader));
            break;
          case 4:
            reader.readMessage(message.approvalAmounts, () => message.approvalAmounts = ApprovalAmounts.deserialize(reader));
            break;
          case 5:
            reader.readMessage(message.maxNumTransfers, () => message.maxNumTransfers = MaxNumTransfers.deserialize(reader));
            break;
          case 9:
            message.requireToEqualsInitiatedBy = reader.readBool();
            break;
          case 11:
            message.requireToDoesNotEqualInitiatedBy = reader.readBool();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OutgoingApprovalDetails {
      return OutgoingApprovalDetails.deserialize(bytes);
    }
  }
  export class IncomingApprovalDetails extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      approvalTrackerId?: string;
      uri?: string;
      customData?: string;
      mustOwnBadges?: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges[];
      merkleChallenges?: MerkleChallenge[];
      predeterminedBalances?: PredeterminedBalances;
      approvalAmounts?: ApprovalAmounts;
      maxNumTransfers?: MaxNumTransfers;
      requireFromEqualsInitiatedBy?: boolean;
      requireFromDoesNotEqualInitiatedBy?: boolean;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("approvalTrackerId" in data && data.approvalTrackerId != undefined) {
          this.approvalTrackerId = data.approvalTrackerId;
        }
        if ("uri" in data && data.uri != undefined) {
          this.uri = data.uri;
        }
        if ("customData" in data && data.customData != undefined) {
          this.customData = data.customData;
        }
        if ("mustOwnBadges" in data && data.mustOwnBadges != undefined) {
          this.mustOwnBadges = data.mustOwnBadges;
        }
        if ("merkleChallenges" in data && data.merkleChallenges != undefined) {
          this.merkleChallenges = data.merkleChallenges;
        }
        if ("predeterminedBalances" in data && data.predeterminedBalances != undefined) {
          this.predeterminedBalances = data.predeterminedBalances;
        }
        if ("approvalAmounts" in data && data.approvalAmounts != undefined) {
          this.approvalAmounts = data.approvalAmounts;
        }
        if ("maxNumTransfers" in data && data.maxNumTransfers != undefined) {
          this.maxNumTransfers = data.maxNumTransfers;
        }
        if ("requireFromEqualsInitiatedBy" in data && data.requireFromEqualsInitiatedBy != undefined) {
          this.requireFromEqualsInitiatedBy = data.requireFromEqualsInitiatedBy;
        }
        if ("requireFromDoesNotEqualInitiatedBy" in data && data.requireFromDoesNotEqualInitiatedBy != undefined) {
          this.requireFromDoesNotEqualInitiatedBy = data.requireFromDoesNotEqualInitiatedBy;
        }
      }
    }
    get approvalTrackerId() {
      return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set approvalTrackerId(value: string) {
      pb_1.Message.setField(this, 6, value);
    }
    get uri() {
      return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
    }
    set uri(value: string) {
      pb_1.Message.setField(this, 7, value);
    }
    get customData() {
      return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
    }
    set customData(value: string) {
      pb_1.Message.setField(this, 8, value);
    }
    get mustOwnBadges() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges, 1) as dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges[];
    }
    set mustOwnBadges(value: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    get merkleChallenges() {
      return pb_1.Message.getRepeatedWrapperField(this, MerkleChallenge, 2) as MerkleChallenge[];
    }
    set merkleChallenges(value: MerkleChallenge[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get predeterminedBalances() {
      return pb_1.Message.getWrapperField(this, PredeterminedBalances, 3) as PredeterminedBalances;
    }
    set predeterminedBalances(value: PredeterminedBalances) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_predeterminedBalances() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get approvalAmounts() {
      return pb_1.Message.getWrapperField(this, ApprovalAmounts, 4) as ApprovalAmounts;
    }
    set approvalAmounts(value: ApprovalAmounts) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_approvalAmounts() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get maxNumTransfers() {
      return pb_1.Message.getWrapperField(this, MaxNumTransfers, 5) as MaxNumTransfers;
    }
    set maxNumTransfers(value: MaxNumTransfers) {
      pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_maxNumTransfers() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get requireFromEqualsInitiatedBy() {
      return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
    }
    set requireFromEqualsInitiatedBy(value: boolean) {
      pb_1.Message.setField(this, 10, value);
    }
    get requireFromDoesNotEqualInitiatedBy() {
      return pb_1.Message.getFieldWithDefault(this, 12, false) as boolean;
    }
    set requireFromDoesNotEqualInitiatedBy(value: boolean) {
      pb_1.Message.setField(this, 12, value);
    }
    static fromObject(data: {
      approvalTrackerId?: string;
      uri?: string;
      customData?: string;
      mustOwnBadges?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.prototype.toObject>[];
      merkleChallenges?: ReturnType<typeof MerkleChallenge.prototype.toObject>[];
      predeterminedBalances?: ReturnType<typeof PredeterminedBalances.prototype.toObject>;
      approvalAmounts?: ReturnType<typeof ApprovalAmounts.prototype.toObject>;
      maxNumTransfers?: ReturnType<typeof MaxNumTransfers.prototype.toObject>;
      requireFromEqualsInitiatedBy?: boolean;
      requireFromDoesNotEqualInitiatedBy?: boolean;
    }): IncomingApprovalDetails {
      const message = new IncomingApprovalDetails({});
      if (data.approvalTrackerId != null) {
        message.approvalTrackerId = data.approvalTrackerId;
      }
      if (data.uri != null) {
        message.uri = data.uri;
      }
      if (data.customData != null) {
        message.customData = data.customData;
      }
      if (data.mustOwnBadges != null) {
        message.mustOwnBadges = data.mustOwnBadges.map(item => dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.fromObject(item));
      }
      if (data.merkleChallenges != null) {
        message.merkleChallenges = data.merkleChallenges.map(item => MerkleChallenge.fromObject(item));
      }
      if (data.predeterminedBalances != null) {
        message.predeterminedBalances = PredeterminedBalances.fromObject(data.predeterminedBalances);
      }
      if (data.approvalAmounts != null) {
        message.approvalAmounts = ApprovalAmounts.fromObject(data.approvalAmounts);
      }
      if (data.maxNumTransfers != null) {
        message.maxNumTransfers = MaxNumTransfers.fromObject(data.maxNumTransfers);
      }
      if (data.requireFromEqualsInitiatedBy != null) {
        message.requireFromEqualsInitiatedBy = data.requireFromEqualsInitiatedBy;
      }
      if (data.requireFromDoesNotEqualInitiatedBy != null) {
        message.requireFromDoesNotEqualInitiatedBy = data.requireFromDoesNotEqualInitiatedBy;
      }
      return message;
    }
    toObject() {
      const data: {
        approvalTrackerId?: string;
        uri?: string;
        customData?: string;
        mustOwnBadges?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.prototype.toObject>[];
        merkleChallenges?: ReturnType<typeof MerkleChallenge.prototype.toObject>[];
        predeterminedBalances?: ReturnType<typeof PredeterminedBalances.prototype.toObject>;
        approvalAmounts?: ReturnType<typeof ApprovalAmounts.prototype.toObject>;
        maxNumTransfers?: ReturnType<typeof MaxNumTransfers.prototype.toObject>;
        requireFromEqualsInitiatedBy?: boolean;
        requireFromDoesNotEqualInitiatedBy?: boolean;
      } = {};
      if (this.approvalTrackerId != null) {
        data.approvalTrackerId = this.approvalTrackerId;
      }
      if (this.uri != null) {
        data.uri = this.uri;
      }
      if (this.customData != null) {
        data.customData = this.customData;
      }
      if (this.mustOwnBadges != null) {
        data.mustOwnBadges = this.mustOwnBadges.map((item: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges) => item.toObject());
      }
      if (this.merkleChallenges != null) {
        data.merkleChallenges = this.merkleChallenges.map((item: MerkleChallenge) => item.toObject());
      }
      if (this.predeterminedBalances != null) {
        data.predeterminedBalances = this.predeterminedBalances.toObject();
      }
      if (this.approvalAmounts != null) {
        data.approvalAmounts = this.approvalAmounts.toObject();
      }
      if (this.maxNumTransfers != null) {
        data.maxNumTransfers = this.maxNumTransfers.toObject();
      }
      if (this.requireFromEqualsInitiatedBy != null) {
        data.requireFromEqualsInitiatedBy = this.requireFromEqualsInitiatedBy;
      }
      if (this.requireFromDoesNotEqualInitiatedBy != null) {
        data.requireFromDoesNotEqualInitiatedBy = this.requireFromDoesNotEqualInitiatedBy;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.approvalTrackerId.length)
        writer.writeString(6, this.approvalTrackerId);
      if (this.uri.length)
        writer.writeString(7, this.uri);
      if (this.customData.length)
        writer.writeString(8, this.customData);
      if (this.mustOwnBadges.length)
        writer.writeRepeatedMessage(1, this.mustOwnBadges, (item: dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges) => item.serialize(writer));
      if (this.merkleChallenges.length)
        writer.writeRepeatedMessage(2, this.merkleChallenges, (item: MerkleChallenge) => item.serialize(writer));
      if (this.has_predeterminedBalances)
        writer.writeMessage(3, this.predeterminedBalances, () => this.predeterminedBalances.serialize(writer));
      if (this.has_approvalAmounts)
        writer.writeMessage(4, this.approvalAmounts, () => this.approvalAmounts.serialize(writer));
      if (this.has_maxNumTransfers)
        writer.writeMessage(5, this.maxNumTransfers, () => this.maxNumTransfers.serialize(writer));
      if (this.requireFromEqualsInitiatedBy != false)
        writer.writeBool(10, this.requireFromEqualsInitiatedBy);
      if (this.requireFromDoesNotEqualInitiatedBy != false)
        writer.writeBool(12, this.requireFromDoesNotEqualInitiatedBy);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IncomingApprovalDetails {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IncomingApprovalDetails();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 6:
            message.approvalTrackerId = reader.readString();
            break;
          case 7:
            message.uri = reader.readString();
            break;
          case 8:
            message.customData = reader.readString();
            break;
          case 1:
            reader.readMessage(message.mustOwnBadges, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.MustOwnBadges));
            break;
          case 2:
            reader.readMessage(message.merkleChallenges, () => pb_1.Message.addToRepeatedWrapperField(message, 2, MerkleChallenge.deserialize(reader), MerkleChallenge));
            break;
          case 3:
            reader.readMessage(message.predeterminedBalances, () => message.predeterminedBalances = PredeterminedBalances.deserialize(reader));
            break;
          case 4:
            reader.readMessage(message.approvalAmounts, () => message.approvalAmounts = ApprovalAmounts.deserialize(reader));
            break;
          case 5:
            reader.readMessage(message.maxNumTransfers, () => message.maxNumTransfers = MaxNumTransfers.deserialize(reader));
            break;
          case 10:
            message.requireFromEqualsInitiatedBy = reader.readBool();
            break;
          case 12:
            message.requireFromDoesNotEqualInitiatedBy = reader.readBool();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IncomingApprovalDetails {
      return IncomingApprovalDetails.deserialize(bytes);
    }
  }
  export class CollectionApprovedTransfer extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      fromMappingId?: string;
      toMappingId?: string;
      initiatedByMappingId?: string;
      transferTimes?: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
      badgeIds?: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
      ownershipTimes?: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
      allowedCombinations?: IsCollectionTransferAllowed[];
      approvalDetails?: ApprovalDetails[];
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7, 8, 9, 10, 11], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("fromMappingId" in data && data.fromMappingId != undefined) {
          this.fromMappingId = data.fromMappingId;
        }
        if ("toMappingId" in data && data.toMappingId != undefined) {
          this.toMappingId = data.toMappingId;
        }
        if ("initiatedByMappingId" in data && data.initiatedByMappingId != undefined) {
          this.initiatedByMappingId = data.initiatedByMappingId;
        }
        if ("transferTimes" in data && data.transferTimes != undefined) {
          this.transferTimes = data.transferTimes;
        }
        if ("badgeIds" in data && data.badgeIds != undefined) {
          this.badgeIds = data.badgeIds;
        }
        if ("ownershipTimes" in data && data.ownershipTimes != undefined) {
          this.ownershipTimes = data.ownershipTimes;
        }
        if ("allowedCombinations" in data && data.allowedCombinations != undefined) {
          this.allowedCombinations = data.allowedCombinations;
        }
        if ("approvalDetails" in data && data.approvalDetails != undefined) {
          this.approvalDetails = data.approvalDetails;
        }
      }
    }
    get fromMappingId() {
      return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set fromMappingId(value: string) {
      pb_1.Message.setField(this, 4, value);
    }
    get toMappingId() {
      return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
    }
    set toMappingId(value: string) {
      pb_1.Message.setField(this, 5, value);
    }
    get initiatedByMappingId() {
      return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set initiatedByMappingId(value: string) {
      pb_1.Message.setField(this, 6, value);
    }
    get transferTimes() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.UintRange, 7) as dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
    }
    set transferTimes(value: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 7, value);
    }
    get badgeIds() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.UintRange, 8) as dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
    }
    set badgeIds(value: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 8, value);
    }
    get ownershipTimes() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.UintRange, 9) as dependency_4.bitbadges.bitbadgeschain.badges.UintRange[];
    }
    set ownershipTimes(value: dependency_4.bitbadges.bitbadgeschain.badges.UintRange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 9, value);
    }
    get allowedCombinations() {
      return pb_1.Message.getRepeatedWrapperField(this, IsCollectionTransferAllowed, 10) as IsCollectionTransferAllowed[];
    }
    set allowedCombinations(value: IsCollectionTransferAllowed[]) {
      pb_1.Message.setRepeatedWrapperField(this, 10, value);
    }
    get approvalDetails() {
      return pb_1.Message.getRepeatedWrapperField(this, ApprovalDetails, 11) as ApprovalDetails[];
    }
    set approvalDetails(value: ApprovalDetails[]) {
      pb_1.Message.setRepeatedWrapperField(this, 11, value);
    }
    static fromObject(data: {
      fromMappingId?: string;
      toMappingId?: string;
      initiatedByMappingId?: string;
      transferTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
      badgeIds?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
      ownershipTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
      allowedCombinations?: ReturnType<typeof IsCollectionTransferAllowed.prototype.toObject>[];
      approvalDetails?: ReturnType<typeof ApprovalDetails.prototype.toObject>[];
    }): CollectionApprovedTransfer {
      const message = new CollectionApprovedTransfer({});
      if (data.fromMappingId != null) {
        message.fromMappingId = data.fromMappingId;
      }
      if (data.toMappingId != null) {
        message.toMappingId = data.toMappingId;
      }
      if (data.initiatedByMappingId != null) {
        message.initiatedByMappingId = data.initiatedByMappingId;
      }
      if (data.transferTimes != null) {
        message.transferTimes = data.transferTimes.map(item => dependency_4.bitbadges.bitbadgeschain.badges.UintRange.fromObject(item));
      }
      if (data.badgeIds != null) {
        message.badgeIds = data.badgeIds.map(item => dependency_4.bitbadges.bitbadgeschain.badges.UintRange.fromObject(item));
      }
      if (data.ownershipTimes != null) {
        message.ownershipTimes = data.ownershipTimes.map(item => dependency_4.bitbadges.bitbadgeschain.badges.UintRange.fromObject(item));
      }
      if (data.allowedCombinations != null) {
        message.allowedCombinations = data.allowedCombinations.map(item => IsCollectionTransferAllowed.fromObject(item));
      }
      if (data.approvalDetails != null) {
        message.approvalDetails = data.approvalDetails.map(item => ApprovalDetails.fromObject(item));
      }
      return message;
    }
    toObject() {
      const data: {
        fromMappingId?: string;
        toMappingId?: string;
        initiatedByMappingId?: string;
        transferTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
        badgeIds?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
        ownershipTimes?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.UintRange.prototype.toObject>[];
        allowedCombinations?: ReturnType<typeof IsCollectionTransferAllowed.prototype.toObject>[];
        approvalDetails?: ReturnType<typeof ApprovalDetails.prototype.toObject>[];
      } = {};
      if (this.fromMappingId != null) {
        data.fromMappingId = this.fromMappingId;
      }
      if (this.toMappingId != null) {
        data.toMappingId = this.toMappingId;
      }
      if (this.initiatedByMappingId != null) {
        data.initiatedByMappingId = this.initiatedByMappingId;
      }
      if (this.transferTimes != null) {
        data.transferTimes = this.transferTimes.map((item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.toObject());
      }
      if (this.badgeIds != null) {
        data.badgeIds = this.badgeIds.map((item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.toObject());
      }
      if (this.ownershipTimes != null) {
        data.ownershipTimes = this.ownershipTimes.map((item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.toObject());
      }
      if (this.allowedCombinations != null) {
        data.allowedCombinations = this.allowedCombinations.map((item: IsCollectionTransferAllowed) => item.toObject());
      }
      if (this.approvalDetails != null) {
        data.approvalDetails = this.approvalDetails.map((item: ApprovalDetails) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.fromMappingId.length)
        writer.writeString(4, this.fromMappingId);
      if (this.toMappingId.length)
        writer.writeString(5, this.toMappingId);
      if (this.initiatedByMappingId.length)
        writer.writeString(6, this.initiatedByMappingId);
      if (this.transferTimes.length)
        writer.writeRepeatedMessage(7, this.transferTimes, (item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.serialize(writer));
      if (this.badgeIds.length)
        writer.writeRepeatedMessage(8, this.badgeIds, (item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.serialize(writer));
      if (this.ownershipTimes.length)
        writer.writeRepeatedMessage(9, this.ownershipTimes, (item: dependency_4.bitbadges.bitbadgeschain.badges.UintRange) => item.serialize(writer));
      if (this.allowedCombinations.length)
        writer.writeRepeatedMessage(10, this.allowedCombinations, (item: IsCollectionTransferAllowed) => item.serialize(writer));
      if (this.approvalDetails.length)
        writer.writeRepeatedMessage(11, this.approvalDetails, (item: ApprovalDetails) => item.serialize(writer));
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CollectionApprovedTransfer {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CollectionApprovedTransfer();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 4:
            message.fromMappingId = reader.readString();
            break;
          case 5:
            message.toMappingId = reader.readString();
            break;
          case 6:
            message.initiatedByMappingId = reader.readString();
            break;
          case 7:
            reader.readMessage(message.transferTimes, () => pb_1.Message.addToRepeatedWrapperField(message, 7, dependency_4.bitbadges.bitbadgeschain.badges.UintRange.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.UintRange));
            break;
          case 8:
            reader.readMessage(message.badgeIds, () => pb_1.Message.addToRepeatedWrapperField(message, 8, dependency_4.bitbadges.bitbadgeschain.badges.UintRange.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.UintRange));
            break;
          case 9:
            reader.readMessage(message.ownershipTimes, () => pb_1.Message.addToRepeatedWrapperField(message, 9, dependency_4.bitbadges.bitbadgeschain.badges.UintRange.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.UintRange));
            break;
          case 10:
            reader.readMessage(message.allowedCombinations, () => pb_1.Message.addToRepeatedWrapperField(message, 10, IsCollectionTransferAllowed.deserialize(reader), IsCollectionTransferAllowed));
            break;
          case 11:
            reader.readMessage(message.approvalDetails, () => pb_1.Message.addToRepeatedWrapperField(message, 11, ApprovalDetails.deserialize(reader), ApprovalDetails));
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CollectionApprovedTransfer {
      return CollectionApprovedTransfer.deserialize(bytes);
    }
  }
  export class PrecalulationDetails extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      precalculationId?: string;
      approvalLevel?: string;
      approverAddress?: string;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("precalculationId" in data && data.precalculationId != undefined) {
          this.precalculationId = data.precalculationId;
        }
        if ("approvalLevel" in data && data.approvalLevel != undefined) {
          this.approvalLevel = data.approvalLevel;
        }
        if ("approverAddress" in data && data.approverAddress != undefined) {
          this.approverAddress = data.approverAddress;
        }
      }
    }
    get precalculationId() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set precalculationId(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get approvalLevel() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set approvalLevel(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get approverAddress() {
      return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set approverAddress(value: string) {
      pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
      precalculationId?: string;
      approvalLevel?: string;
      approverAddress?: string;
    }): PrecalulationDetails {
      const message = new PrecalulationDetails({});
      if (data.precalculationId != null) {
        message.precalculationId = data.precalculationId;
      }
      if (data.approvalLevel != null) {
        message.approvalLevel = data.approvalLevel;
      }
      if (data.approverAddress != null) {
        message.approverAddress = data.approverAddress;
      }
      return message;
    }
    toObject() {
      const data: {
        precalculationId?: string;
        approvalLevel?: string;
        approverAddress?: string;
      } = {};
      if (this.precalculationId != null) {
        data.precalculationId = this.precalculationId;
      }
      if (this.approvalLevel != null) {
        data.approvalLevel = this.approvalLevel;
      }
      if (this.approverAddress != null) {
        data.approverAddress = this.approverAddress;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.precalculationId.length)
        writer.writeString(1, this.precalculationId);
      if (this.approvalLevel.length)
        writer.writeString(2, this.approvalLevel);
      if (this.approverAddress.length)
        writer.writeString(3, this.approverAddress);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PrecalulationDetails {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PrecalulationDetails();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.precalculationId = reader.readString();
            break;
          case 2:
            message.approvalLevel = reader.readString();
            break;
          case 3:
            message.approverAddress = reader.readString();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): PrecalulationDetails {
      return PrecalulationDetails.deserialize(bytes);
    }
  }
  export class Transfer extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      from?: string;
      toAddresses?: string[];
      balances?: dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
      precalculationDetails?: PrecalulationDetails;
      merkleProofs?: MerkleProof[];
      memo?: string;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3, 5], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("from" in data && data.from != undefined) {
          this.from = data.from;
        }
        if ("toAddresses" in data && data.toAddresses != undefined) {
          this.toAddresses = data.toAddresses;
        }
        if ("balances" in data && data.balances != undefined) {
          this.balances = data.balances;
        }
        if ("precalculationDetails" in data && data.precalculationDetails != undefined) {
          this.precalculationDetails = data.precalculationDetails;
        }
        if ("merkleProofs" in data && data.merkleProofs != undefined) {
          this.merkleProofs = data.merkleProofs;
        }
        if ("memo" in data && data.memo != undefined) {
          this.memo = data.memo;
        }
      }
    }
    get from() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set from(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get toAddresses() {
      return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set toAddresses(value: string[]) {
      pb_1.Message.setField(this, 2, value);
    }
    get balances() {
      return pb_1.Message.getRepeatedWrapperField(this, dependency_4.bitbadges.bitbadgeschain.badges.Balance, 3) as dependency_4.bitbadges.bitbadgeschain.badges.Balance[];
    }
    set balances(value: dependency_4.bitbadges.bitbadgeschain.badges.Balance[]) {
      pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    get precalculationDetails() {
      return pb_1.Message.getWrapperField(this, PrecalulationDetails, 4) as PrecalulationDetails;
    }
    set precalculationDetails(value: PrecalulationDetails) {
      pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_precalculationDetails() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get merkleProofs() {
      return pb_1.Message.getRepeatedWrapperField(this, MerkleProof, 5) as MerkleProof[];
    }
    set merkleProofs(value: MerkleProof[]) {
      pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    get memo() {
      return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set memo(value: string) {
      pb_1.Message.setField(this, 6, value);
    }
    static fromObject(data: {
      from?: string;
      toAddresses?: string[];
      balances?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
      precalculationDetails?: ReturnType<typeof PrecalulationDetails.prototype.toObject>;
      merkleProofs?: ReturnType<typeof MerkleProof.prototype.toObject>[];
      memo?: string;
    }): Transfer {
      const message = new Transfer({});
      if (data.from != null) {
        message.from = data.from;
      }
      if (data.toAddresses != null) {
        message.toAddresses = data.toAddresses;
      }
      if (data.balances != null) {
        message.balances = data.balances.map(item => dependency_4.bitbadges.bitbadgeschain.badges.Balance.fromObject(item));
      }
      if (data.precalculationDetails != null) {
        message.precalculationDetails = PrecalulationDetails.fromObject(data.precalculationDetails);
      }
      if (data.merkleProofs != null) {
        message.merkleProofs = data.merkleProofs.map(item => MerkleProof.fromObject(item));
      }
      if (data.memo != null) {
        message.memo = data.memo;
      }
      return message;
    }
    toObject() {
      const data: {
        from?: string;
        toAddresses?: string[];
        balances?: ReturnType<typeof dependency_4.bitbadges.bitbadgeschain.badges.Balance.prototype.toObject>[];
        precalculationDetails?: ReturnType<typeof PrecalulationDetails.prototype.toObject>;
        merkleProofs?: ReturnType<typeof MerkleProof.prototype.toObject>[];
        memo?: string;
      } = {};
      if (this.from != null) {
        data.from = this.from;
      }
      if (this.toAddresses != null) {
        data.toAddresses = this.toAddresses;
      }
      if (this.balances != null) {
        data.balances = this.balances.map((item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.toObject());
      }
      if (this.precalculationDetails != null) {
        data.precalculationDetails = this.precalculationDetails.toObject();
      }
      if (this.merkleProofs != null) {
        data.merkleProofs = this.merkleProofs.map((item: MerkleProof) => item.toObject());
      }
      if (this.memo != null) {
        data.memo = this.memo;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.from.length)
        writer.writeString(1, this.from);
      if (this.toAddresses.length)
        writer.writeRepeatedString(2, this.toAddresses);
      if (this.balances.length)
        writer.writeRepeatedMessage(3, this.balances, (item: dependency_4.bitbadges.bitbadgeschain.badges.Balance) => item.serialize(writer));
      if (this.has_precalculationDetails)
        writer.writeMessage(4, this.precalculationDetails, () => this.precalculationDetails.serialize(writer));
      if (this.merkleProofs.length)
        writer.writeRepeatedMessage(5, this.merkleProofs, (item: MerkleProof) => item.serialize(writer));
      if (this.memo.length)
        writer.writeString(6, this.memo);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Transfer {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Transfer();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.from = reader.readString();
            break;
          case 2:
            pb_1.Message.addToRepeatedField(message, 2, reader.readString());
            break;
          case 3:
            reader.readMessage(message.balances, () => pb_1.Message.addToRepeatedWrapperField(message, 3, dependency_4.bitbadges.bitbadgeschain.badges.Balance.deserialize(reader), dependency_4.bitbadges.bitbadgeschain.badges.Balance));
            break;
          case 4:
            reader.readMessage(message.precalculationDetails, () => message.precalculationDetails = PrecalulationDetails.deserialize(reader));
            break;
          case 5:
            reader.readMessage(message.merkleProofs, () => pb_1.Message.addToRepeatedWrapperField(message, 5, MerkleProof.deserialize(reader), MerkleProof));
            break;
          case 6:
            message.memo = reader.readString();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Transfer {
      return Transfer.deserialize(bytes);
    }
  }
  export class MerklePathItem extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      aunt?: string;
      onRight?: boolean;
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("aunt" in data && data.aunt != undefined) {
          this.aunt = data.aunt;
        }
        if ("onRight" in data && data.onRight != undefined) {
          this.onRight = data.onRight;
        }
      }
    }
    get aunt() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set aunt(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get onRight() {
      return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set onRight(value: boolean) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
      aunt?: string;
      onRight?: boolean;
    }): MerklePathItem {
      const message = new MerklePathItem({});
      if (data.aunt != null) {
        message.aunt = data.aunt;
      }
      if (data.onRight != null) {
        message.onRight = data.onRight;
      }
      return message;
    }
    toObject() {
      const data: {
        aunt?: string;
        onRight?: boolean;
      } = {};
      if (this.aunt != null) {
        data.aunt = this.aunt;
      }
      if (this.onRight != null) {
        data.onRight = this.onRight;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.aunt.length)
        writer.writeString(1, this.aunt);
      if (this.onRight != false)
        writer.writeBool(2, this.onRight);
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MerklePathItem {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MerklePathItem();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.aunt = reader.readString();
            break;
          case 2:
            message.onRight = reader.readBool();
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MerklePathItem {
      return MerklePathItem.deserialize(bytes);
    }
  }
  export class MerkleProof extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
      leaf?: string;
      aunts?: MerklePathItem[];
    }) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("leaf" in data && data.leaf != undefined) {
          this.leaf = data.leaf;
        }
        if ("aunts" in data && data.aunts != undefined) {
          this.aunts = data.aunts;
        }
      }
    }
    get leaf() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set leaf(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get aunts() {
      return pb_1.Message.getRepeatedWrapperField(this, MerklePathItem, 2) as MerklePathItem[];
    }
    set aunts(value: MerklePathItem[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
      leaf?: string;
      aunts?: ReturnType<typeof MerklePathItem.prototype.toObject>[];
    }): MerkleProof {
      const message = new MerkleProof({});
      if (data.leaf != null) {
        message.leaf = data.leaf;
      }
      if (data.aunts != null) {
        message.aunts = data.aunts.map(item => MerklePathItem.fromObject(item));
      }
      return message;
    }
    toObject() {
      const data: {
        leaf?: string;
        aunts?: ReturnType<typeof MerklePathItem.prototype.toObject>[];
      } = {};
      if (this.leaf != null) {
        data.leaf = this.leaf;
      }
      if (this.aunts != null) {
        data.aunts = this.aunts.map((item: MerklePathItem) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.leaf.length)
        writer.writeString(1, this.leaf);
      if (this.aunts.length)
        writer.writeRepeatedMessage(2, this.aunts, (item: MerklePathItem) => item.serialize(writer));
      if (!w)
        return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MerkleProof {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MerkleProof();
      while (reader.nextField()) {
        if (reader.isEndGroup())
          break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.leaf = reader.readString();
            break;
          case 2:
            reader.readMessage(message.aunts, () => pb_1.Message.addToRepeatedWrapperField(message, 2, MerklePathItem.deserialize(reader), MerklePathItem));
            break;
          default: reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MerkleProof {
      return MerkleProof.deserialize(bytes);
    }
  }
}
