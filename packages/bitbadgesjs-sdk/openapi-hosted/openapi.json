{
  "openapi": "3.1.0",
  "info": {
    "title": "BitBadges API",
    "description": "# Introduction\nThe BitBadges API is a RESTful API that enables developers to interact with the BitBadges blockchain and indexer. This API provides comprehensive access to the BitBadges ecosystem, allowing you to query and interact with digital tokens, collections, accounts, blockchain data, and more.\nFor complete documentation, see the [BitBadges Documentation](https://docs.bitbadges.io/for-developers/bitbadges-api/api)\nand use along with this reference.\n\nNote: The API + documentation is new and may contain bugs. If you find any issues, please let us know via Discord or another contact method (https://bitbadges.io/contact).\n\n# Getting Started\n\n## Authentication\nAll API requests require an API key for authentication. You can obtain your API key from the [BitBadges Developer Portal](https://bitbadges.io/developer).\n\n### API Key Authentication\nInclude your API key in the `x-api-key` header:\n```\nx-api-key: your-api-key-here\n```\n\n<br />\n\n## User Authentication\nMost read-only applications can function with just an API key. However, if you need to access private user data or perform actions on behalf of users, you have two options:\n\n### OAuth 2.0 (Sign In with BitBadges)\nFor performing actions on behalf of other users, use the standard OAuth 2.0 flow via Sign In with BitBadges.\nSee the [Sign In with BitBadges documentation](https://docs.bitbadges.io/for-developers/authenticating-with-bitbadges) for details.\n\nYou will pass the access token in the Authorization header:\n```\nAuthorization: Bearer your-access-token-here\n```\n\n### Password Self-Approve Method\nFor automating actions for your own account:\n1. Set up an approved password sign in in your account settings tab on https://bitbadges.io with desired scopes (e.g. `completeClaims`)\n2. Sign in using:\n```typescript\nconst { message } = await BitBadgesApi.getSignInChallenge(...);\nconst verificationRes = await BitBadgesApi.verifySignIn({\n    message,\n    signature: '', //Empty string\n    password: '...'\n})\n```\n\nNote: This method uses HTTP session cookies. Ensure your requests support credentials (e.g. axios: { withCredentials: true }).\n\n### Scopes\nNote that for proper authentication, you must have the proper scopes set.\n\nSee [https://bitbadges.io/auth/linkgen](https://bitbadges.io/auth/linkgen) for a helper URL generation tool. The scopes will be included in\nthe `scope` parameter of the SIWBB URL or set in your approved sign in settings.\n\nNote that stuff marked as Full Access is typically reserved for the official site. If you think you may need this,\ncontact us.\n\n### Available Scopes\n\n- **Report** (`report`)\n  Report users or collections.\n\n- **Read Profile** (`readProfile`)\n  Read your private profile information. This includes your email, approved sign-in methods, connections, and other private information.\n\n- **Manage Applications** (`manageApplications`)\n  Create, update, and delete applications on behalf of the user.\n\n- **Manage Claims** (`manageClaims`)\n  Create, update, and delete claims on behalf of the user.\n\n- **Manage Developer Apps** (`manageDeveloperApps`)\n  Create, update, and delete developer apps on behalf of the user.\n\n- **Manage Dynamic Stores** (`manageDynamicStores`)\n  Create, update, and delete dynamic stores on behalf of the user.\n\n- **Manage Utility Pages** (`manageUtilityPages`)\n  Create, update, and delete utility pages on behalf of the user.\n\n- **Approve Sign In With BitBadges Requests** (`approveSignInWithBitBadgesRequests`)\n  Sign In with BitBadges on behalf of the user.\n\n- **Read Authentication Codes** (`readAuthenticationCodes`)\n  Read Authentication Codes on behalf of the user.\n\n- **Delete Authentication Codes** (`deleteAuthenticationCodes`)\n  Delete Authentication Codes on behalf of the user.\n\n- **Read Private Claim Data** (`readPrivateClaimData`)\n  Read private claim data on behalf of the user (e.g. codes, passwords, private user lists, etc.).\n\n- **Complete Claims** (`completeClaims`)\n  Complete claims on behalf of the user.\n\n<br />\n\n## SDK Integration\nThe recommended way to interact with the API is through our TypeScript/JavaScript SDK:\n\n```typescript\nimport { BigIntify, BitBadgesAPI } from \"bitbadgesjs-sdk\";\n\n// Initialize the API client\nconst api = new BitBadgesAPI({\n  convertFunction: BigIntify,\n  apiKey: 'your-api-key-here'\n});\n\n// Example: Fetch collections\nconst collections = await api.getCollections({\n  collectionsToFetch: [{\n    collectionId: 1n,\n    metadataToFetch: {\n      tokenIds: [{ start: 1n, end: 10n }]\n    }\n  }]\n});\n```\n\n<br />\n\n# Tiers\nThere are 3 tiers of API keys, each with different rate limits and permissions. See the pricing page for more details: https://bitbadges.io/pricing\n- Free tier\n- Premium tier\n- Enterprise tier\n\nRate limit headers included in responses:\n- `X-RateLimit-Limit`: Total requests allowed per window\n- `X-RateLimit-Remaining`: Remaining requests in current window\n- `X-RateLimit-Reset`: Time until rate limit resets (UTC timestamp)\n\n# Response Formats\n\n## Error Response\n\nAll API errors follow a consistent format:\n\n```typescript\n{\n  // Serialized error object for debugging purposes\n  // Advanced users can use this to debug issues\n  error?: any;\n\n  // UX-friendly error message that can be displayed to the user\n  // Always present if error occurs\n  errorMessage: string;\n\n  // Authentication error flag\n  // Present if the user is not authenticated\n  unauthorized?: boolean;\n}\n```\n\n<br />\n\n## Pagination\nCursor-based pagination is used for list endpoints:\n```typescript\n{\n  items: T[],\n  bookmark: string, // Use this for the next page\n  hasMore: boolean\n}\n```\n\n<br />\n\n# Best Practices\n1. **Rate Limiting**: Implement proper rate limit handling\n2. **Caching**: Cache responses when appropriate\n3. **Error Handling**: Handle API errors gracefully\n4. **Batch Operations**: Use batch endpoints when possible\n\n# Additional Resources\n- [Official Documentation](https://docs.bitbadges.io/for-developers/bitbadges-api/api)\n- [SDK Documentation](https://docs.bitbadges.io/for-developers/bitbadges-sdk/overview)\n- [Developer Portal](https://bitbadges.io/developer)\n- [GitHub SDK Repository](https://github.com/bitbadges/bitbadgesjs)\n- [Quickstarter Repository](https://github.com/bitbadges/bitbadges-quickstart)\n\n# Support\n- [Contact Page](https://bitbadges.io/contact)",
    "version": "0.1",
    "license": {
      "name": "MIT",
      "url": "https://github.com/bitbadges/bitbadgesjs/blob/main/LICENSE"
    },
    "termsOfService": "https://bitbadges.io/policies"
  },
  "servers": [
    {
      "url": "https://api.bitbadges.io/api/v0",
      "description": "Production API Server"
    },
    {
      "url": "https://api.bitbadges.io/testnet/api/v0",
      "description": "Testnet API Server"
    }
  ],
  "security": [
    {
      "apiKey": []
    }
  ],
  "tags": [
    {
      "name": "Accounts",
      "description": "Endpoints for managing user accounts and profiles"
    },
    {
      "name": "Tokens",
      "description": "Endpoints for token and collection operations"
    },
    {
      "name": "Claims",
      "description": "Endpoints for managing claims"
    },
    {
      "name": "Sign In with BitBadges",
      "description": "Authentication and authorization endpoints for Sign In with BitBadges"
    },
    {
      "name": "Transactions",
      "description": "Endpoints for submitting and simulating blockchain transactions"
    },
    {
      "name": "Applications",
      "description": "Endpoints for managing applications (points, tiers, quests)"
    },
    {
      "name": "Plugins",
      "description": "Endpoints for the plugins for claims"
    },
    {
      "name": "Dynamic Stores",
      "description": "Endpoints for managing off-chain dynamic data stores"
    },
    {
      "name": "On-Chain Dynamic Stores",
      "description": "Endpoints for querying on-chain dynamic stores (stored on the blockchain)"
    },
    {
      "name": "Utility Pages",
      "description": "Endpoints for managing utility pages"
    },
    {
      "name": "Miscellaneous"
    },
    {
      "name": "Assets",
      "description": "Endpoints for asset pair operations, liquidity pools, and swap analytics"
    }
  ],
  "paths": {
    "/user": {
      "get": {
        "operationId": "getAccount",
        "summary": "Get Account",
        "description": "Retrieves an account by address or username.\n\n```tsx\nconst res = await BitBadgesApi.getAccount({ address: '...', username: '...' });\nconsole.log(res);\n```\n\nFor more specific views, you can use the other routes.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAccountPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAccountSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getaccount)**\n\n## Authentication Details\n- **Public Data**: Available with API key only\n  - Basic profile information\n  - Etc\n\n- **Private Data** (requires user authentication):\n  - Notification preferences\n  - Stored Social connections\n  - Etc\n\nScopes\n- `readProfile` - Required for private profile information like notification preferences, social connections, etc.\n\nCouple Notes:\n- **[Native Chain Algorithm](https://docs.bitbadges.io/for-developers/bitbadges-api/concepts/native-chain-algorithm)**\n\nNote: The `views` and corresponding fields like `tokensCollected`, etc will be blank with this simple\nGET but are provided in the response for compatibility with the SDK. To actually fetch these views, use the POST\nbatch route or the individual view routes.\n",
        "tags": [
          "Accounts"
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetAccountSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "address",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/NativeAddress"
            }
          },
          {
            "in": "query",
            "name": "username",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ]
      }
    },
    "/users": {
      "post": {
        "operationId": "getAccounts",
        "summary": "Get Accounts - Batch",
        "description": "Retrieves accounts and accompanying details. This route is all-inclusive and uses a view-based approach to fetch specific data about the account. See more in the tutorial below.\n\n```tsx\nconst accountsRes = await BitBadgesApi.getAccounts({\n  accountsToFetch: [\n    {\n      //example\n      address: 'bb1...',\n      viewsToFetch: [\n        {\n          viewType: 'tokensCollected',\n          viewId: 'tokensCollected',\n          bookmark: '',\n        },\n      ],\n    },\n  ],\n})\nconst account = accountsRes.accounts[0]\n```\n\n## Authentication Details\n- **Public Data**: Available with API key only\n  - Basic profile information\n  - Public balances\n  - Public activity\n  - Etc\n\n- **Private Data** (requires user authentication):\n  - Notification preferences\n  - Private Attestations\n  - Private activity, etc\n  - Etc\n\nScopes\n- `readProfile` - Required for private profile information like notification preferences, social connections, etc.\n- `readAuthenticationCodes` - Required if fetching private authentication codes\n\nDocumentation References / Tutorials:\n- **[Managing Views](https://docs.bitbadges.io/for-developers/bitbadges-api/tutorials/managing-views)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAccountsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAccountsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getaccounts)**\n",
        "tags": [
          "Accounts"
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetAccountsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetAccountsPayload"
              }
            }
          }
        }
      }
    },
    "/collection/{collectionId}": {
      "get": {
        "operationId": "getCollection",
        "summary": "Get Collection",
        "tags": [
          "Tokens"
        ],
        "description": "Gets a specific collection.\n\n```tsx\nawait BitBadgesApi.getCollection(\"123\", { ... });\n```\n\nSDK Links:\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollection)**\n\nNote: The `views` and corresponding fields like `owners`, `approvalTrackers`, etc will be blank with this simple\nGET but are provided in the response for compatibility with the SDK. To actually fetch these views, use the POST\nbatch route or the individual view routes.",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "collectionId",
            "in": "path",
            "description": "Collection ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/collection/{collectionId}/{tokenId}/metadata": {
      "get": {
        "operationId": "getTokenMetadata",
        "summary": "Get Token Metadata",
        "tags": [
          "Tokens"
        ],
        "description": "Gets current metadata for a specific token in a collection.\n\n```tsx\nawait BitBadgesApi.getTokenMetadata(\"123\", \"1\");\n```\n\nSDK Links:\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTokenMetadataSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#gettokenMetadata)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetTokenMetadataSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "collectionId",
            "in": "path",
            "description": "Collection ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tokenId",
            "in": "path",
            "description": "Token ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/collections": {
      "post": {
        "operationId": "getCollectionsBatch",
        "summary": "Get Collections - Batch",
        "tags": [
          "Tokens"
        ],
        "description": "Retrieves collections and associated details. This route is all-inclusive and uses a view-based approach to fetch specific data about collections, including metadata, balances, owners, and more.\n\n```tsx\nconst res = await BitBadgesApi.getCollections({\n  collectionsToFetch: [\n    {\n      collectionId: 1n,\n      metadataToFetch: {\n        tokenIds: [{ start: 1n, end: 10n }],\n      },\n      fetchTotalAndMintBalances: true,\n      viewsToFetch: [\n        {\n          viewType: 'owners',\n          viewId: 'owners',\n          bookmark: '',\n        },\n      ],\n    },\n  ],\n})\n\nconst collection = res.collections[0]\n```\n\nScopes:\n- `readPrivateClaimData` - Required if fetching private claim data (must also be the manager)\n\nDocumentation References / Tutorials:\n- **[Managing Views](https://docs.bitbadges.io/for-developers/bitbadges-api/tutorials/managing-views)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollections)**\n\nNote: This route has lots of legacy features that are planned to be deprecated. For any views, we recommend\nusing the other GET routes.\n",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetCollectionsPayload"
              }
            }
          }
        }
      }
    },
    "/collection/{collectionId}/balance/{address}/{tokenId}": {
      "get": {
        "operationId": "getBalanceByAddressSpecificToken",
        "summary": "Get Balance By Address - Specific Token",
        "description": "Retrieves the balance of a specific token for a specific address at the current time.\n\n**Note:** This endpoint fetches balances from the BitBadges standard only. If you need core x/bank or IBC balances (including BitBadges tokens wrapped to x/bank format), please use the [blockchain API](https://lcd.bitbadges.io/#/).\n\nFor more advanced queries returning the whole balance document, please use the POST `/collection/{collectionId}/balance/{address}` endpoint.\n\n```tsx\nconst res = await BitBadgesApi.getBalanceByAddressSpecificToken(collectionId, address, tokenId);\nconsole.log(res);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetBalanceByAddressSpecificTokenPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetBalanceByAddressSpecificTokenSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getbalancebyaddressspecificbadge)**\n\nAlternative Flow: Note that you can also set up a claim that checks token ownership and check the success per user of that claim as well\n",
        "tags": [
          "Tokens"
        ],
        "parameters": [
          {
            "name": "collectionId",
            "in": "path",
            "description": "The ID of the collection.",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "The address for which the balance is to be retrieved. Can be \"Total\" for the circulating supply.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tokenId",
            "in": "path",
            "description": "The ID for which the balance is to be retrieved.",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetBalanceByAddressSpecificTokenSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ]
      }
    },
    "/collection/{collectionId}/balance/{address}": {
      "get": {
        "operationId": "getBalanceByAddress",
        "tags": [
          "Tokens"
        ],
        "summary": "Get Balances By Address",
        "description": "Retrieves the balances of a specific address for a collection.\n\n**Note:** This endpoint fetches balances from the BitBadges standard only. If you need core x/bank or IBC balances (including BitBadges tokens wrapped to x/bank format), please use the [blockchain API](https://lcd.bitbadges.io/#/).\n\n```tsx\nconst res = await BitBadgesApi.getBalanceByAddress(collectionId, address, { ...options });\nconsole.log(res);\n```\n\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetBalanceByAddressPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetBalanceByAddressSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getbalancebyaddress)**\n\nScopes:\n- `readPrivateClaimData` - Required if fetching private claim data (user-level approvals)\n\nAlternative Flow: Note that you can also set up a claim that checks token ownership and check the success per user of that claim as well\n",
        "parameters": [
          {
            "name": "collectionId",
            "in": "path",
            "description": "The ID of the collection.",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "The address for which the balance is to be retrieved. Can be \"Total\" for the circulating supply.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "fetchPrivateParams",
            "required": false,
            "schema": {
              "description": "If true, we will fetch private parameters for any claims / approvals. Must be creator.\n\nThis is only applicable to incoming / outgoing approvals with claims.",
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "forceful",
            "required": false,
            "schema": {
              "description": "If true, we will forcefully fetch the balance even if it is already cached. Only applicable to non-indexed / on-demand collections.",
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetBalanceByAddressSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/claim/{claimId}": {
      "get": {
        "operationId": "getClaim",
        "summary": "Get Claim",
        "tags": [
          "Claims"
        ],
        "description": "Gets a claim by specific ID.\n\n```tsx\nawait BitBadgesApi.getClaim(\"claim123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getclaim)**\n\nScopes:\n  - `readPrivateClaimData` - Required if fetching private claim data (also must be manager of claim)",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetClaimSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "claimId",
            "in": "path",
            "description": "Claim ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "fetchPrivateParams",
            "required": false,
            "schema": {
              "description": "Fetch private parameters for the claim. Only applicable if you are the creator / manager of the claim.",
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "fetchAllClaimedUsers",
            "required": false,
            "schema": {
              "description": "Fetch all claimed users for the claim.  If true, you will be able to find all { [bitbadgesAddress]: [...zeroIndexedClaimNumbers] }\non the numUses plugin's publicState.",
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "privateStatesToFetch",
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "description": "The private state instance IDs to fetch. By default, we do not fetch any private states.",
              "type": "array"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/claims/success/{claimId}/{address}": {
      "get": {
        "operationId": "checkClaimSuccess",
        "summary": "Check Claim Successes By User",
        "description": "Checks if a claim has been successfully completed.\n\nThis returns a success count based on how many times the user has completed the claim.\n\nFor on-demand claims, this will return 1 if the user has completed the claim. For indexed claims, this will return the number of times the user has completed the claim.\n\nNote that this will not work if the claim hides its state.\n\n```tsx\nconst res = await BitBadgesApi.checkClaimSuccess(claimId, address);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCheckClaimSuccessPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCheckClaimSuccessSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#checkclaimsuccess)**\n",
        "tags": [
          "Claims"
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCheckClaimSuccessSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "claimId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/developerApp/{clientId}": {
      "get": {
        "operationId": "getDeveloperApp",
        "summary": "Get OAuth App",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Gets a developer app by specific ID.\n\n```tsx\nawait BitBadgesApi.getDeveloperApp(\"clientId123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDeveloperAppPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDeveloperAppSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getdeveloperapp)**\n\nScopes:\n  - `manageDeveloperApps` - Required to return the client secret (plus being owner). Else, it will just be the app metadata",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetDeveloperAppSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "clientId",
            "in": "path",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/developerApps": {
      "post": {
        "operationId": "createDeveloperApp",
        "summary": "Create OAuth App",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Creates a new OAuth app.\n\n```tsx\nawait BitBadgesApi.createDeveloperApp(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateDeveloperAppPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateDeveloperAppSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#createdeveloperapp)**\n\nScopes:\n  - `manageDeveloperApps` - Required to create a new app",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCreateDeveloperAppSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": null,
              "$ref": "#/components/schemas/iCreateDeveloperAppPayload"
            }
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      },
      "put": {
        "operationId": "updateDeveloperApp",
        "summary": "Update OAuth App",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Updates an existing OAuth app.\n\n```tsx\nawait BitBadgesApi.updateDeveloperApp(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateDeveloperAppPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateDeveloperAppSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#updatedeveloperapp)**\n\nScopes:\n  - `manageDeveloperApps` - Required to update an app",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iUpdateDeveloperAppSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "clientId",
            "in": "path",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": null,
              "$ref": "#/components/schemas/iUpdateDeveloperAppPayload"
            }
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      },
      "delete": {
        "operationId": "deleteDeveloperApp",
        "summary": "Delete OAuth App",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Deletes an existing OAuth app.\n\n```tsx\nawait BitBadgesApi.deleteDeveloperApp(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteDeveloperAppPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteDeveloperAppSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#deletedeveloperapp)**\n\nScopes:\n  - `manageDeveloperApps` - Required to delete an app",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iDeleteDeveloperAppSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "clientId",
            "in": "path",
            "description": "Client ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": null,
              "$ref": "#/components/schemas/iDeleteDeveloperAppPayload"
            }
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/plugin/{pluginId}": {
      "get": {
        "operationId": "getPlugin",
        "summary": "Get Plugin",
        "tags": [
          "Plugins"
        ],
        "description": "Gets a plugin by specific ID.\n\n```tsx\nawait BitBadgesApi.getPlugin(\"plugin123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPluginPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPluginSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getplugin)**\n\nScopes:\n- Full Access: Required for private plugins",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetPluginSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "pluginId",
            "in": "path",
            "description": "Plugin ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/utilityPage/{utilityPageId}": {
      "get": {
        "operationId": "getUtilityPage",
        "summary": "Get Utility Page",
        "tags": [
          "Utility Pages"
        ],
        "description": "Gets a utility page by specific ID.\n\n```tsx\nawait BitBadgesApi.getUtilityPage(\"utilityPage123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetUtilityPagePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetUtilityPageSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getutilitylisting)**\n\nScopes:\n  - `manageUtilityPages` - Required and must have view permissions for private listings",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetUtilityPageSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "utilityPageId",
            "in": "path",
            "description": "Utility listing ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/dynamicStore/{dynamicStoreId}": {
      "get": {
        "operationId": "getDynamicDataStore",
        "summary": "Get Dynamic Data Store",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Gets a dynamic data store by specific ID.\n\n```tsx\nawait BitBadgesApi.getDynamicDataStore(\"dynamicStore123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataStorePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataStoreSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getdynamicDataStore)**\n\nScopes:\n  - `manageDynamicDataStores` - Required and must be owner. Alternatively, you can specify the dataSecret.",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetDynamicDataStoreSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "dynamicStoreId",
            "in": "path",
            "description": "Dynamic data store ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "dataSecret",
            "required": false,
            "schema": {
              "description": "The data secret to fetch. Only needed if you are not signed in as creator. Not applicable to public stores",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/dynamicStore/{dynamicStoreId}/value": {
      "get": {
        "operationId": "getDynamicDataStoreValue",
        "summary": "Get Dynamic Data Store Value",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Gets a value from a dynamic data store by specific ID and key.\n\n```tsx\nawait BitBadgesApi.getDynamicDataStoreValue(\"dynamicStore123\", { key: \"key123\", ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataStoreValuePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataStoreValueSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getdynamicDataStoreValue)**\n\nScopes:\n  - `manageDynamicDataStores` - Required and must be owner. You can also specify the dataSecret.",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetDynamicDataStoreValueSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "dynamicStoreId",
            "in": "path",
            "description": "Dynamic data store ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "key",
            "required": true,
            "schema": {
              "description": "The key to fetch.",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "dataSecret",
            "required": false,
            "schema": {
              "description": "The data secret to fetch. Only needed if you are not signed in as creator. Not applicable to public stores",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "lookupType",
            "required": false,
            "schema": {
              "enum": [
                "id",
                "username"
              ],
              "description": "The lookup type to fetch (if you need to specify).",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/dynamicStore/{dynamicStoreId}/values": {
      "get": {
        "operationId": "getDynamicDataStoreValuesPaginated",
        "summary": "Get Dynamic Data Store Values Paginated",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Gets a paginated list of values from a dynamic data store by specific ID.\n\n```tsx\nawait BitBadgesApi.getDynamicDataStoreValuesPaginated(\"dynamicStore123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataStoreValuesPaginatedPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataStoreValuesPaginatedSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getdynamicDataStoreValuesPaginated)**\n\nScopes:\n  - `manageDynamicDataStores` - Required and must be owner.",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetDynamicDataStoreValuesPaginatedSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "dynamicStoreId",
            "in": "path",
            "description": "Dynamic data store ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "dataSecret",
            "required": false,
            "schema": {
              "description": "The data secret to fetch. Only needed if you are not signed in as creator. Not applicable to public stores",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "The pagination bookmark to start from",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "lookupType",
            "required": false,
            "schema": {
              "enum": [
                "id",
                "username"
              ],
              "description": "The lookup type to fetch (if you need to specify).",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/dynamicStores": {
      "post": {
        "operationId": "createDynamicDataStore",
        "summary": "Create Dynamic Data Store",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Creates a new dynamic data store.\n\n```tsx\nawait BitBadgesApi.createDynamicDataStore(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateDynamicDataStorePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateDynamicDataStoreSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#createdynamicDataStore)**\n\nScopes:\n  - `manageDynamicDataStores` - Required and must be owner.",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCreateDynamicDataStoreSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iCreateDynamicDataStorePayload"
              }
            }
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      },
      "put": {
        "operationId": "updateDynamicDataStore",
        "summary": "Update Dynamic Data Store",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Updates a dynamic data store.\n\n```tsx\nawait BitBadgesApi.updateDynamicDataStore(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateDynamicDataStorePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateDynamicDataStoreSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#updatedynamicDataStore)**\n\nScopes:\n  - `manageDynamicDataStores` - Required and must be owner.",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iUpdateDynamicDataStoreSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "dynamicStoreId",
            "in": "path",
            "description": "Dynamic data store ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iUpdateDynamicDataStorePayload"
              }
            }
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      },
      "delete": {
        "operationId": "deleteDynamicDataStore",
        "summary": "Delete Dynamic Data Store",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Deletes a dynamic data store.\n\n```tsx\nawait BitBadgesApi.deleteDynamicDataStore(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteDynamicDataStorePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteDynamicDataStoreSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#deletedyndatastore)**\n\nScopes:\n  - `manageDynamicDataStores` - Required and must be owner.",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iDeleteDynamicDataStoreSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "dynamicStoreId",
            "in": "path",
            "description": "Dynamic data store ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iDeleteDynamicDataStorePayload"
              }
            }
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/application/{applicationId}": {
      "get": {
        "operationId": "getApplication",
        "summary": "Get Application",
        "tags": [
          "Applications"
        ],
        "description": "Gets an application by specific ID.\n\n```tsx\nawait BitBadgesApi.getApplication(\"application123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetApplicationPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetApplicationSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getapplication)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetApplicationSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "applicationId",
            "in": "path",
            "description": "Application ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/status": {
      "get": {
        "operationId": "getStatus",
        "summary": "Get Status",
        "description": "Gets the current status details about the blockchain / indexer (gas, block height, etc).\n```tsx\nconst res = await BitBadgesApi.getStatus();\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetStatusPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetStatusSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getstatus)**\n",
        "tags": [
          "Miscellanous"
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetStatusSuccessResponse"
                }
              }
            },
            "description": "Returns the current status of the blockchain / indexer"
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "withOutOfSyncCheck",
            "required": false,
            "schema": {
              "description": "If true, we will check if the indexer is out of sync with the blockchain.",
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "chain",
            "required": false,
            "schema": {
              "enum": [
                "Thorchain",
                "BitBadges"
              ],
              "description": "Chain to check? Defaults to BitBadges poller.",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/collection/{collectionId}/{tokenId}/owners": {
      "get": {
        "operationId": "getOwners",
        "summary": "Get Token Owners",
        "tags": [
          "Tokens"
        ],
        "description": "Retrieves the owners in a paginated format for a specific token in a collection.\nReturns a list of addresses and their corresponding balances for the specified token ID.\n\n```tsx\nconst res = await BitBadgesApi.getOwners(\n  collectionId,\n  tokenId,\n  {\n    bookmark: '...'\n  }\n);\n```\n\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOwnersPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOwnersSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getownersforbadge)**\n",
        "parameters": [
          {
            "name": "collectionId",
            "in": "path",
            "description": "The numeric collection ID.",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "tokenId",
            "in": "path",
            "description": "The numeric token ID to retrieve owners for.",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "The pagination bookmark for where to start the request. Bookmarks are obtained via the previous response. \"\" for first request.",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "sortBy",
            "required": false,
            "schema": {
              "description": "Sort by amount descending.",
              "enum": [
                "amount"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetOwnersSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/collection/{collectionId}/{tokenId}/activity": {
      "get": {
        "operationId": "getTokenActivity",
        "summary": "Get Token Activity",
        "description": "Retrieves the activity in a paginated format for a specific token in a collection.\n\n```tsx\nconst res = await BitBadgesApi.getTokenActivity(\n  collectionId,\n  tokenId,\n  {\n    bookmark: '...'\n  }\n);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTokenActivityPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTokenActivitySuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getbadgeactivity)**\n",
        "tags": [
          "Tokens"
        ],
        "parameters": [
          {
            "name": "collectionId",
            "in": "path",
            "description": "The ID of the collection.",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "tokenId",
            "in": "path",
            "description": "The ID for which activity is to be retrieved.",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "An optional bookmark for pagination. Bookmarks are obtained via the previous response. \"\" for first request.",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bitbadgesAddress",
            "required": false,
            "schema": {
              "description": "Specific address to filter by. If not present, all activity will be returned.",
              "type": "string",
              "examples": [
                "bb1..."
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetTokenActivitySuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/collection/{collectionId}/refresh": {
      "post": {
        "operationId": "refreshMetadata",
        "summary": "Refresh Metadata",
        "tags": [
          "Tokens"
        ],
        "description": "Triggers a metadata refresh for a specific collection. BitBadges API uses a refresh queue system for fetching anything off-chain.\nThis will refetch any details for the collection (such as metadata, balances if applicable, approval details, etc).\n\nNote it will reject if recently refreshed to prevent abuse.\n\n```tsx\nconst res = await BitBadgesApi.refreshMetadata(collectionId, { ...options });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iRefreshMetadataPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iRefreshMetadataSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#refreshmetadata)**\n",
        "parameters": [
          {
            "name": "collectionId",
            "in": "path",
            "description": "The ID of the collection to trigger metadata refresh.",
            "required": true,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iRefreshMetadataPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iRefreshMetadataSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": true
      }
    },
    "/claims/complete/{claimId}/{address}": {
      "post": {
        "operationId": "completeClaim",
        "summary": "Complete Claim",
        "tags": [
          "Claims"
        ],
        "description": "Completes a claim for a specific address. This triggers a complete claim request to be sent to the queue.\nNote, this route returning a success code does not mean the claim has been completed. You will need to\nfetch its status via the attempt ID.\n\nIf you want to simulate the claim first, you can use the simulate claim endpoint.\n\n_expectedVersion is required and must match the version of the claim. If you want to override this check,\nspecify -1.\n\nThe rest of the body should look like:\n```typescript\n{\n  _expectedVersion: 1,\n  [pluginInstanceId1]: { ..bodyForPluginInstanceId1 },\n  [pluginInstanceId2]: { ..bodyForPluginInstanceId2 },\n}\n```\n\n```tsx\nconst res = await BitBadgesApi.completeClaim(claimId, address, { _expectedVersion: 1, ...body });\nconsole.log(res.claimAttemptId);\n\n//Sleep 2 seconds\n\nconst res = await BitBadgesApi.getClaimAttemptStatus(res.claimAttemptId);\nconsole.log(res) // { success: true }\n```\n\nDocumentation References / Tutorials:\n- **[Completing Claims](https://docs.bitbadges.io/for-developers/claim-builder/auto-complete-claims-w-bitbadges-api)**\n- **[All About BitBadges Claims](https://docs.bitbadges.io/for-developers/claim-builder)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCompleteClaimPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCompleteClaimSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#completeclaim)**\n\nScopes:\n  - `completeClaims` - Required if completing claims on behalf of a user and requires sign-in\n",
        "parameters": [
          {
            "name": "claimId",
            "in": "path",
            "description": "The ID of the claim.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "The address of the user making the claim.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iCompleteClaimPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCompleteClaimSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ]
      }
    },
    "/claims/simulate/{claimId}/{address}": {
      "post": {
        "operationId": "simulateClaim",
        "summary": "Simulate Claim",
        "tags": [
          "Claims"
        ],
        "description": "Simulates a claim for a user. This will check if the claim is valid and that all criteria is satisfied. This returns a fake ID for compatibility with certain integrations.\nA successful response means simulation passed. This is instant and does not use the queue.\n\nNote: There may be cases where the simulation passes but the claim fails. This may happen if state changes\nbetween the simulation and the claim. It is always best practice to simulate first, but do not rely on the simulation\nresponse for the final result.\n\n```tsx\nconst res = await BitBadgesApi.simulateClaim(claimId, address, { ...body });\n```\n\n_expectedVersion is required and must match the version of the claim. If you want to override this check,\nspecify -1.\n\nThe rest of the body should look like:\n```typescript\n{\n  _expectedVersion: 1,\n  _specificInstanceIds: [pluginInstanceId1, pluginInstanceId2], //Optional: simulate only specific instances\n  [pluginInstanceId1]: { ..bodyForPluginInstanceId1 },\n  [pluginInstanceId2]: { ..bodyForPluginInstanceId2 },\n}\n```\n\nDocumentation References / Tutorials:\n- **[Completing Claims](https://docs.bitbadges.io/for-developers/claim-builder/auto-complete-claims-w-bitbadges-api)**\n- **[All About BitBadges Claims](https://docs.bitbadges.io/for-developers/claim-builder)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSimulateClaimPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSimulateClaimSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#simulateclaim)**\n\nScopes:\n  - `completeClaims` - Required if completing claims on behalf of a user and requires sign-in",
        "parameters": [
          {
            "name": "claimId",
            "in": "path",
            "description": "The ID of the claim.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "The address of the user making the claim.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iSimulateClaimPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iSimulateClaimSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ]
      }
    },
    "/claims/reserved/{claimId}/{address}": {
      "post": {
        "operationId": "getReservedCodes",
        "summary": "Get Reserved Claim Codes",
        "tags": [
          "Claims"
        ],
        "description": "Retrieves the reserved codes for a claim.\n\nFor on-chain claims / approvals, we use a code reservation system where the claim code is to be used in the eventual blockchain transaction.\nThis is used to bridge the gap between the off-chain claim and on-chain approval / transfer.\n\n```tsx\nconst res = await BitBadgesApi.getReservedCodes(claimId, address);\n```\n\nDocumentation References / Tutorials:\n- **[Completing Claims](https://docs.bitbadges.io/for-developers/claim-builder/auto-complete-claims-w-bitbadges-api)**\n- **[All About BitBadges Claims](https://docs.bitbadges.io/for-developers/claim-builder)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetReservedClaimCodesPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetReservedClaimCodesSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getReservedCodes)**\n\nScopes:\n  - `completeClaims` - Required",
        "parameters": [
          {
            "name": "claimId",
            "in": "path",
            "description": "The ID of the claim.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "The address of the user making the claim.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetReservedClaimCodesSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetReservedClaimCodesPayload"
              }
            }
          }
        }
      }
    },
    "/claims/status/{claimAttemptId}": {
      "get": {
        "operationId": "getClaimAttemptStatus",
        "tags": [
          "Claims"
        ],
        "summary": "Get Claim Attempt Status",
        "description": "Retrieves the status of a claim attempt by the ID received when submitting.\n\n```tsx\nconst res = await BitBadgesApi.getClaimAttemptStatus(claimAttemptId);\n```\n\nDocumentation References / Tutorials:\n- **[Completing Claims](https://docs.bitbadges.io/for-developers/claim-builder/auto-complete-claims-w-bitbadges-api)**\n- **[All About BitBadges Claims](https://docs.bitbadges.io/for-developers/claim-builder)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimAttemptStatusPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimAttemptStatusSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getclaimattemptstatus)**",
        "parameters": [
          {
            "name": "claimAttemptId",
            "in": "path",
            "description": "The transaction ID of the claim attempt.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetClaimAttemptStatusSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/broadcast": {
      "post": {
        "operationId": "broadcastTx",
        "tags": [
          "Transactions"
        ],
        "summary": "Broadcast Transaction",
        "description": "Broadcasts a transaction to the blockchain. This will broadcast the transaction to the blockchain\nvia the BitBadges blockchain node.\n\n```tsx\nconst res = await BitBadgesApi.broadcastTx(...);\n```\n\nDocumentation References / Tutorials:\n- **[Create, Generate, and Sign Txs](https://docs.bitbadges.io/for-developers/create-and-broadcast-txs)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/types/iBroadcastTxPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iBroadcastTxSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#broadcasttx)**",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/iBroadcastTxPayload"
                  },
                  {
                    "type": "string"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iBroadcastTxSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/simulate": {
      "post": {
        "operationId": "simulateTx",
        "summary": "Simulate Transaction",
        "description": "Simulates a transaction on the blockchain. This will simulate the transaction on the blockchain\nvia the BitBadges blockchain node.\n\n```tsx\nconst res = await BitBadgesApi.simulateTx(...);\n```\n\nDocumentation References / Tutorials:\n- **[Create, Generate, and Sign Txs](https://docs.bitbadges.io/for-developers/create-and-broadcast-txs)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/types/iSimulateTxPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSimulateTxSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#simulatetx)**",
        "tags": [
          "Transactions"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/iSimulateTxPayload"
                  },
                  {
                    "type": "string"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iSimulateTxSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/siwbb/token": {
      "post": {
        "operationId": "exchangeSIWBBAuthorizationCode",
        "summary": "Exchange SIWBB Code",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Exchange either a refresh token or OAuth authorization code for an access token.\n\nIMPORTANT: Keep your client secret safe and secure.\n\nDocumentation References / Tutorials:\n- **[API Authorization](https://docs.bitbadges.io/for-developers/sign-in-with-bitbadges)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iExchangeSIWBBAuthorizationCodePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iExchangeSIWBBAuthorizationCodeSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#exchangesiwbbauthorizationcode)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iExchangeSIWBBAuthorizationCodeSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iExchangeSIWBBAuthorizationCodePayload"
              }
            }
          }
        }
      }
    },
    "/siwbb/token/revoke": {
      "post": {
        "operationId": "revokeOauthAuthorization",
        "summary": "Revoke Authorization",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Revokes the authorization. The token can either be an access token or a refresh token.\nThis endpoint revokes all tokens associated with the procided token (thus revoking the entire authorization).\nThis can be called by the user or the authorized application.\n\n```tsx\nawait BitBadgesApi.revokeOauthAuthorization({ token });\n```\n\n\nDocumentation References / Tutorials:\n- **[API Authorization](https://docs.bitbadges.io/for-developers/sign-in-with-bitbadges)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iOauthRevokePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iOauthRevokeSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#revokeoauthauthorization)**",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iOauthRevokePayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iOauthRevokeSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ]
      }
    },
    "/siwbbRequest/rotate": {
      "post": {
        "operationId": "rotateSIWBBRequest",
        "summary": "Rotate SIWBB Request",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Rotates a Sign In with BitBadges request. This is typically used to rotate a QR code to a new value.\n\n```tsx\nconst res = await BitBadgesApi.rotateSIWBBRequest(...);\n```\n\nDocumentation References / Tutorials:\n- **[Sign In with BitBadges](https://docs.bitbadges.io/for-developers/authenticating-with-bitbadges)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iRotateSIWBBRequestPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iRotateSIWBBRequestSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#rotatesiwbbrequest)**\n\nScopes:\n  - `approveSignInWithBitBadgesRequests` - Required",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iRotateSIWBBRequestPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iRotateSIWBBRequestSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ]
      }
    },
    "/siwbbRequest": {
      "delete": {
        "operationId": "deleteSIWBBRequest",
        "summary": "Delete SIWBB Request",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Deletes an authentication code from the user's account.\n\n```tsx\nconst res = await BitBadgesApi.deleteSIWBBRequest(...);\n```\n\nDocumentation References / Tutorials:\n- **[Sign In with BitBadges](https://docs.bitbadges.io/for-developers/authenticating-with-bitbadges)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteSIWBBRequestPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteSIWBBRequestSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#deletesiwbbrequest)**\n\nScopes:\n  - `deleteAuthenticationCodes` - Required",
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iDeleteSIWBBRequestPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iDeleteSIWBBRequestSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ]
      },
      "post": {
        "operationId": "createSIWBBRequest",
        "summary": "Create SIWBB Request",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Creates an authentication code. This is used for the Sign In wtih BitBadges flow.\n\nNote: This is typically not recommended to be called directly. Instead, direct the user to use the frontend authorization flow.\n\n```tsx\nconst res = await BitBadgesApi.createSIWBBRequest(...);\n```\n\nDocumentation References / Tutorials:\n- **[Sign In with BitBadges](https://docs.bitbadges.io/for-developers/authenticating-with-bitbadges)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateSIWBBRequestPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateSIWBBRequestSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#createsiwbbrequest)**\n\nScopes:\n  - `approveSignInWithBitBadgesRequests` - Required",
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iCreateSIWBBRequestPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCreateSIWBBRequestSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ]
      }
    },
    "/developerApps/siwbbRequests": {
      "get": {
        "operationId": "getSIWBBRequestsForDeveloperApp",
        "summary": "Get SIWBB Requests For Developer App",
        "tags": [
          "Sign In with BitBadges"
        ],
        "description": "Gets all saved docs for the Sign In with BitBadges flow for a specific app. This is useful, for example,\nif you are authenticating in-person and want to pre-fetch all authentication details\nto avoid doing it at verification time.\n\nThis will return the actual authentication details, not just the codes. You will still have to exchange\nthe code for the access token / confirmations.\n\n```tsx\nconst res = await BitBadgesApi.getSIWBBRequestsForDeveloperApp(...);\n```\n\nDocumentation References / Tutorials:\n- **[Sign In with BitBadges](https://docs.bitbadges.io/for-developers/authenticating-with-bitbadges)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetSIWBBRequestsForDeveloperAppPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetSIWBBRequestsForDeveloperAppSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getsiwbbrequestsfordeveloperapp)**\n\nScopes:\n  - `manageDeveloperApps` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetSIWBBRequestsForDeveloperAppSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "The bookmark for pagination.",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "clientId",
            "required": true,
            "schema": {
              "description": "The client ID to fetch for",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ]
      }
    },
    "/collection/{collectionId}/refreshStatus": {
      "get": {
        "operationId": "getRefreshStatus",
        "summary": "Get Refresh Status",
        "tags": [
          "Tokens"
        ],
        "description": "Gets the refresh status for a collection. Used to track if any errors occur during a refresh, or if it is in the queue or not.\n\n```tsx\nconst res = await BitBadgesApi.getRefreshStatus(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetRefreshStatusPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetRefreshStatusSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getrefreshstatus)**",
        "parameters": [
          {
            "name": "collectionId",
            "in": "path",
            "description": "The collection ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iRefreshStatusSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": [],
            "userIsManager": []
          }
        ]
      }
    },
    "/maps/{mapId}": {
      "get": {
        "operationId": "getMap",
        "summary": "Get Map",
        "tags": [
          "Maps and Protocols"
        ],
        "description": "Gets the core details of a map.\n\nFor getting actual values, use the getMapValues endpoint(s).\n\n```tsx\nconst res = await BitBadgesApi.getMap(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetMapPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetMapSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getmap)**",
        "parameters": [
          {
            "name": "mapId",
            "in": "path",
            "description": "The map ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetMapSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/maps": {
      "post": {
        "operationId": "getMaps",
        "summary": "Get Maps - Batch",
        "tags": [
          "Maps and Protocols"
        ],
        "description": "Gets map data. Maps are created and stored on-chain. They are key-value objects which can have certain properties\nlike restricting who sets which values, expected formatting, and more.\n\nFor getting actual values, use the getMapValues endpoint.\n\n```tsx\nconst res = await BitBadgesApi.getMaps(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetMapsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetMapsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getmaps)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetMapsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetMapsPayload"
              }
            }
          }
        }
      }
    },
    "/mapValues": {
      "post": {
        "operationId": "getMapValues",
        "summary": "Get Map Values - Batch",
        "tags": [
          "Maps and Protocols"
        ],
        "description": "Gets map values for a collection.\n\n```tsx\nconst res = await BitBadgesApi.getMapValues(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetMapValuesPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetMapValuesSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getmapvalues)**",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetMapValuesPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetMapValuesSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/mapValue/{mapId}/{key}": {
      "get": {
        "operationId": "getMapValue",
        "summary": "Get Map Value",
        "tags": [
          "Maps and Protocols"
        ],
        "description": "Gets a map value.\n\n```tsx\nconst res = await BitBadgesApi.getMapValue(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetMapValuePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetMapValueSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getmapvalue)**",
        "parameters": [
          {
            "name": "mapId",
            "in": "path",
            "description": "The map ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "description": "The key to get the value for",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetMapValueSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/claims/search": {
      "get": {
        "operationId": "searchClaims",
        "summary": "Search Claims",
        "tags": [
          "Claims"
        ],
        "description": "Search through the signed in user's claims they have created / are managing.\n\n```tsx\nconst res = await BitBadgesApi.searchClaims(...);\n```\n\nDocumentation References / Tutorials:\n- **[Completing Claims](https://docs.bitbadges.io/for-developers/claim-builder/auto-complete-claims-w-bitbadges-api)**\n- **[All About BitBadges Claims](https://docs.bitbadges.io/for-developers/claim-builder)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchClaimsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchClaimsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#searchclaims)**\n\nScopes:\n  - `readPrivateClaimData` - Required for fetching private claim data",
        "parameters": [
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "Bookmark to start from. Obtained from previous request. Leave blank to start from the beginning. Only applicable when no additional criteria is specified.",
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "fetchPrivateParams",
            "required": false,
            "schema": {
              "description": "Fetch private parameters for the claim. Only applicable if you are the creator / manager of the claim. Otherwise, it will be the public read-only view.",
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "searchValue",
            "required": false,
            "schema": {
              "description": "If provided, we will only return claims with names that regex match the search value.",
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iSearchClaimsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ]
      }
    },
    "/claims/fetch": {
      "post": {
        "operationId": "getClaims",
        "summary": "Get Claims - Batch",
        "tags": [
          "Claims"
        ],
        "description": "Retrieve claims by ID(s). Certain state is not made available by default for scalability reasons and must\nbe requested explicitly.\n\nTo fetch private parameters and state, you must be the manager of the claim, signed in, and request it.\n\n```tsx\nconst res = await BitBadgesApi.getClaims({\n  claimsToFetch: [\n    {\n      claimId: '123',\n      fetchPrivateParams: true,\n      privateStatesToFetch: [instanceId1, instanceId2],\n    },\n  ],\n});\n```\n\nDocumentation References / Tutorials:\n- **[Completing Claims](https://docs.bitbadges.io/for-developers/claim-builder/auto-complete-claims-w-bitbadges-api)**\n- **[All About BitBadges Claims](https://docs.bitbadges.io/for-developers/claim-builder)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimsPayloadV1)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getclaims)**\n\nScopes:\n  - `readPrivateClaimData` - Required if fetching private claim data",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetClaimsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ],
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetClaimsPayloadV1"
              }
            }
          }
        }
      }
    },
    "/claims": {
      "post": {
        "operationId": "createClaim",
        "summary": "Create Claim",
        "tags": [
          "Claims"
        ],
        "description": "Creates a new claim.\n\nNote: Creating claims via the API is often overkill. Consider doing this in-site, using a plugin approach or another method first.\nYou may also opt to leave the creation in-site but update claims via the API instead.\n\nThere are a few categories of claims:\n- Standalone (default) - Not attached to anything\n- Test claims - Used for frontend claim tester\n- Linked to on-chain approvals (user or collection level) - This is advanced. If you need this, please reach out to us. Updates are fine, but creation uses an advanced processs that is undocumented currently.\n\n```tsx\nconst res = await BitBadgesApi.createClaims(...);\n```\n\nDocumentation References / Tutorials:\n- **[Completing Claims](https://docs.bitbadges.io/for-developers/claim-builder/auto-complete-claims-w-bitbadges-api)**\n- **[All About BitBadges Claims](https://docs.bitbadges.io/for-developers/claim-builder)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateClaimPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateClaimSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#createclaims)**\n\nTip: You can see the claim JSONs in-site. Click the info circle button > JSON tab. Use the claim tester, build your claim, and see how it works behind the scenes.\n\nScopes:\n  - `manageClaims` - Required",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iCreateClaimPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCreateClaimSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ]
      },
      "put": {
        "operationId": "updateClaim",
        "summary": "Update Claim",
        "tags": [
          "Claims"
        ],
        "description": "Updates an existing claim.\n\nNote: Updating claims via the API is often overkill. Consider doing this in-site, using a plugin approach or another method first.\n\nThere are a few categories of claims:\n- Standalone (default) - Not attached to anything\n- Test claims - Used for frontend claim tester\n- Linked to on-chain approvals (user or collection level) - Specify the valid collectionId. Note: This is advanced. Please reach out if you need this.\n\n```tsx\nconst res = await BitBadgesApi.updateClaims(...);\n```\n\nDocumentation References / Tutorials:\n- **[Completing Claims](https://docs.bitbadges.io/for-developers/claim-builder/auto-complete-claims-w-bitbadges-api)**\n- **[All About BitBadges Claims](https://docs.bitbadges.io/for-developers/claim-builder)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateClaimPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateClaimSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#updateclaims)**\n\nTip: You can see the claim JSONs in-site. Click the info circle button > JSON tab. Use the claim tester, build your claim, and see how it works behind the scenes.\n\nScopes:\n  - `manageClaims` - Required\n  - `manageAddressLists` - Required for updating link listed claims",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iUpdateClaimPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iUpdateClaimSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ]
      },
      "delete": {
        "operationId": "deleteClaim",
        "summary": "Delete Claim",
        "tags": [
          "Claims"
        ],
        "description": "Deletes a claim. Creating and maintaining claims are typically recommended\nto be done through the site, not the API, because they require special configuration.\n\n```tsx\nconst res = await BitBadgesApi.deleteClaims(...);\n```\n\nDocumentation References / Tutorials:\n- **[Completing Claims](https://docs.bitbadges.io/for-developers/claim-builder/auto-complete-claims-w-bitbadges-api)**\n- **[All About BitBadges Claims](https://docs.bitbadges.io/for-developers/claim-builder)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteClaimPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteClaimSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#deleteclaims)**\n\nScopes:\n  - `manageClaims` - Required",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iDeleteClaimPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iDeleteClaimSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "401": {
            "$ref": "#/components/responses/UnauthorizedResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ]
      }
    },
    "/codes": {
      "get": {
        "operationId": "generateCode",
        "summary": "Get Code (Codes Plugin)",
        "description": "Generates a unique code based on a seed and a zero-based index. This is used for the Codes plugin with claims.\n\nDocumentation References / Tutorials:\n- **[Codes Plugin](https://docs.bitbadges.io/for-developers/claim-builder/universal-approach-claim-codes)**\n",
        "tags": [
          "Claims"
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "string",
                      "description": "The generated code"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "seedCode",
            "in": "query",
            "description": "The seed used to generate the code",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idx",
            "in": "query",
            "description": "The index of the code to generate",
            "required": true,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/claims/{claimId}/attempts": {
      "get": {
        "operationId": "getClaimAttempts",
        "summary": "Get Claim Attempts",
        "tags": [
          "Claims"
        ],
        "description": "Retrieves the attempts for a claim in a paginated format. If you are the manager and authenticated, you\ncan also request failed attempts and view the errors.\n\n```tsx\nconst res = await BitBadgesApi.getClaimAttempts(claimId, {\n  address: \"\",\n  bookmark: \"\",\n  includeErrors: true\n});\n```\n\nDocumentation References / Tutorials:\n- **[Getting Claims](https://docs.bitbadges.io/for-developers/bitbadges-api/tutorials/getting-claims)**\n- **[Managing Claims](https://docs.bitbadges.io/for-developers/bitbadges-api/tutorials/managing-claims)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimAttemptsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimAttemptsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getclaimattempts)**\n\nScopes:\n  - `readPrivateClaimData` - Required if fetching errors",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetClaimAttemptsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "claimId",
            "in": "path",
            "description": "The ID of the claim",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "The bookmark to start from.",
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "includeErrors",
            "required": false,
            "schema": {
              "description": "Whether to include errors or not.",
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "address",
            "required": false,
            "schema": {
              "description": "The specific address to fetch claims for. If blank, we fetch most recent claims.",
              "$ref": "#/components/schemas/NativeAddress"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "includeRequestBinAttemptData",
            "required": false,
            "schema": {
              "description": "Include the cached payload data for requestBin plugin. Must be claim creator to view.\n\nYou can also use the individual GET route to fetch this data.",
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ]
      }
    },
    "/claims/gatedContent/{claimId}": {
      "get": {
        "operationId": "getGatedContentForClaim",
        "summary": "Get Gated Content for Claim",
        "tags": [
          "Claims"
        ],
        "description": "If claims implement the rewards tab with in-site delivery, there may be gated URLs or content that is only\naccessible to users who have completed the claim. This endpoint allows you to retrieve the gated content for a claim\nif you are authenticated and meet the claim's gated content requirements.\n\n```typescript\nconst res = await BitBadgesApi.getGatedContentForClaim(claimId);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetGatedContentForClaimPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetGatedContentForClaimSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getgatedcontentforclaim)**\n\nScopes:\n  - `completeClaims` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetGatedContentForClaimSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "claimId",
            "in": "path",
            "description": "The ID of the claim",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ]
      }
    },
    "/storeActions/single": {
      "post": {
        "operationId": "performStoreActionSingleWithBodyAuth",
        "summary": "Perform Single Store Action (Body Auth)",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Performs a single action on a dynamic store using body authentication.\n\nFor more information on this route, see the Dynamic Stores > Manage tab in the developer portal.\n\n```tsx\nawait BitBadgesApi.performStoreAction(...);\n```\n\nDocumentation References / Tutorials:\n- **[Dynamic Stores](https://docs.bitbadges.io/for-developers/claim-builder/dynamic-stores)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iPerformStoreActionPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iPerformStoreActionSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#performstoreaction)**\n\nScopes:\n  - `manageDynamicStores` - Required if you do not specify the data secret",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iPerformStoreActionSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userIsOwner": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iPerformStoreActionSingleWithBodyAuthPayload"
              }
            }
          }
        }
      }
    },
    "/storeActions/batch": {
      "post": {
        "operationId": "performStoreActionBatchWithBodyAuth",
        "summary": "Perform Batch Store Actions (Body Auth)",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Performs multiple actions on a dynamic store using body authentication.\n\nFor more information on this route, see the Dynamic Stores > Manage tab in the developer portal.\n\n```tsx\nawait BitBadgesApi.performBatchStoreAction(...);\n```\n\nDocumentation References / Tutorials:\n- **[Dynamic Stores](https://docs.bitbadges.io/for-developers/claim-builder/dynamic-stores)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iPerformStoreActionPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iPerformStoreActionSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#performstoreaction)**\n\nScopes:\n  - `manageDynamicStores` - Required if you do not specify the data secret",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iBatchStoreActionSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userIsOwner": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iPerformStoreActionBatchWithBodyAuthPayload"
              }
            }
          }
        }
      }
    },
    "/dynamicStores/fetch": {
      "post": {
        "operationId": "getDynamicDataStores",
        "summary": "Fetch Dynamic Data Stores - Batch",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Fetches dynamic stores by ID(s).\n\n```tsx\nawait BitBadgesApi.getDynamicDataStores(...);\n```\n\nDocumentation References / Tutorials:\n- **[Dynamic Stores](https://docs.bitbadges.io/for-developers/claim-builder/dynamic-stores)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataStoresPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataStoresSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getdynamicdatastores)**\n\nScopes:\n- `manageDynamicStores` - Required (or specify the valid data secret)",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetDynamicDataStoresSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userIsOwner": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetDynamicDataStoresPayload"
              }
            }
          }
        }
      }
    },
    "/dynamicStores/search": {
      "get": {
        "operationId": "searchDynamicDataStores",
        "summary": "Search Dynamic Data Stores For User",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Searches for dynamic stores based on the provided criteria. Currently, this only gets the signed in user's dynamic stores.\n\n```tsx\nawait BitBadgesApi.searchDynamicDataStores(...);\n```\n\nDocumentation References / Tutorials:\n- **[Dynamic Stores](https://docs.bitbadges.io/for-developers/claim-builder/dynamic-stores)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchDynamicDataStoresPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchDynamicDataStoresSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#searchdynamicdatastores)**\n\nScopes:\n- `manageDynamicStores` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iSearchDynamicDataStoresSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "The pagination bookmark to start from",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userIsOwner": []
          }
        ],
        "x-internal": false
      }
    },
    "/dynamicStores/activity": {
      "get": {
        "operationId": "getDynamicDataActivity",
        "summary": "Get Dynamic Data Activity",
        "tags": [
          "Dynamic Stores"
        ],
        "description": "Fetches activity history for dynamic stores.\n\n```tsx\nawait BitBadgesApi.getDynamicDataActivity(...);\n```\n\nDocumentation References / Tutorials:\n- **[Dynamic Stores](https://docs.bitbadges.io/for-developers/claim-builder/dynamic-stores)**\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataActivityPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetDynamicDataActivitySuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getdynamicdataactivity)**\n\nScopes:\n- `manageDynamicStores` - Required (or specify the valid data secret)",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetDynamicDataActivitySuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "dynamicDataId",
            "required": true,
            "schema": {
              "description": "The dynamic data ID to fetch activity for",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "The pagination bookmark to start from",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "dataSecret",
            "required": false,
            "schema": {
              "description": "The data secret to fetch activity for. Needed if you are not signed in as creator. Not applicable to public stores",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ],
        "x-internal": false
      }
    },
    "/applications/search": {
      "get": {
        "operationId": "searchApplications",
        "summary": "Search Applications",
        "tags": [
          "Applications"
        ],
        "description": "Searches for applications based on the provided criteria. Currently,\nthis only gets the signed in user's applications.\n\n```tsx\nawait BitBadgesApi.searchApplications(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchApplicationsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchApplicationsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#searchapplications)**\n\nScopes:\n- `manageApplications` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iSearchApplicationsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "The search value to search for",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/applications/fetch": {
      "post": {
        "operationId": "getApplications",
        "summary": "Get Applications - Batch",
        "tags": [
          "Applications"
        ],
        "description": "Fetches applications based on the provided criteria.\n\n```tsx\nawait BitBadgesApi.getApplications(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetApplicationsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetApplicationsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getapplications)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetApplicationsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetApplicationsPayload"
              }
            }
          }
        }
      }
    },
    "/applications": {
      "post": {
        "operationId": "createApplication",
        "summary": "Create Application",
        "tags": [
          "Applications"
        ],
        "description": "Creates an application.\n\n```tsx\nawait BitBadgesApi.createApplication(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateApplicationPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateApplicationSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#createapplication)**\n\nScopes:\n- `manageApplications` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCreateApplicationSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userIsOwner": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iCreateApplicationPayload"
              }
            }
          }
        }
      },
      "put": {
        "operationId": "updateApplication",
        "summary": "Update Application",
        "tags": [
          "Applications"
        ],
        "description": "Updates an application.\n\n```tsx\nawait BitBadgesApi.updateApplication(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateApplicationPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateApplicationSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#updateapplication)**\n\nScopes:\n- `manageApplications` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iUpdateApplicationSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userIsOwner": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iUpdateApplicationPayload"
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "deleteApplication",
        "summary": "Delete Application",
        "tags": [
          "Applications"
        ],
        "description": "Deletes an application.\n\n```tsx\nawait BitBadgesApi.deleteApplication(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteApplicationPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteApplicationSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#deleteapplication)**\n\nScopes:\n- `manageApplications` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iDeleteApplicationSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userIsOwner": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iDeleteApplicationPayload"
              }
            }
          }
        }
      }
    },
    "/applications/points": {
      "post": {
        "operationId": "calculatePoints",
        "summary": "Calculate Points",
        "tags": [
          "Applications"
        ],
        "description": "Calculates points for an application, page, and user.\n\nNote: We use a heavy caching system, so you may not see the results immediately and may be rejected if\nrecently calculated.\n\n```tsx\nawait BitBadgesApi.calculatePoints(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCalculatePointsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCalculatePointsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#calculatepoints)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCalculatePointsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iCalculatePointsPayload"
              }
            }
          }
        }
      }
    },
    "/applications/points/activity": {
      "get": {
        "operationId": "getPointsActivity",
        "summary": "Get Points Activity",
        "tags": [
          "Applications"
        ],
        "description": "Fetches points activity for an application.\n\n```tsx\nawait BitBadgesApi.getPointsActivity(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPointsActivityPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPointsActivitySuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getpointsactivity)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetPointsActivitySuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "applicationId",
            "required": true,
            "schema": {
              "description": "The application ID to get points activity for",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "pageId",
            "required": true,
            "schema": {
              "description": "The page ID to get points activity for",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "The pagination bookmark to start from",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "address",
            "required": false,
            "schema": {
              "description": "The specific address to get points activity for",
              "$ref": "#/components/schemas/NativeAddress"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/plugins/fetch": {
      "post": {
        "operationId": "getPlugins",
        "summary": "Get Plugins - Batch",
        "tags": [
          "Plugins"
        ],
        "description": "Fetches plugins based on the provided criteria.\n\n```tsx\nawait BitBadgesApi.getPlugins(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPluginsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPluginSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getplugins)**\n\nScopes:\n- Full Access - Required for private plugins",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetPluginSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ],
        "x-internal": false,
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetPluginsPayload"
              }
            }
          }
        }
      }
    },
    "/plugins/search": {
      "get": {
        "operationId": "searchPlugins",
        "summary": "Search Plugins",
        "tags": [
          "Plugins"
        ],
        "description": "Searches for plugins based on the provided criteria.\n\n```tsx\nawait BitBadgesApi.searchPlugins(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchPluginsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchPluginsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#searchplugins)**\n\nScopes:\n- Full Access - Required for fetching your created plugins / private plugins",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iSearchPluginsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "pluginsForSignedInUser",
            "required": false,
            "schema": {
              "description": "If true, we will fetch all plugins for the authenticated user (with plugin secrets).\n\nThis will include plugins created by the signed in user and also those where they are explicitly approved / invited.",
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "Bookmark for pagination of the plugins (obtained from a previous call to this endpoint).",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "searchValue",
            "required": false,
            "schema": {
              "description": "Search value",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "locale",
            "required": false,
            "schema": {
              "description": "Locale to restrict results to. By default, we assume 'en'. This is not applicable if you specify createdPluginsOnly, speciifc pluginIds, or an invite code.",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ],
        "x-internal": false
      }
    },
    "/utilityPages/fetch": {
      "post": {
        "operationId": "getUtilityPages",
        "summary": "Get Utility Pages - Batch",
        "tags": [
          "Utility Pages"
        ],
        "description": "Fetches utility pages based on the provided criteria.\n\nRequires authentication for private listings.\n\n```tsx\nawait BitBadgesApi.getUtilityPages(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetUtilityPagesPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetUtilityPagesSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getutilitylistings)**\n\nScopes:\n- `manageUtilityPages` - Required for private listings",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetUtilityPagesSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userMaybeSignedIn": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetUtilityPagesPayload"
              }
            }
          }
        }
      }
    },
    "/utilityPages/search": {
      "get": {
        "operationId": "searchUtilityPages",
        "summary": "Search Utility Pages",
        "tags": [
          "Utility Pages"
        ],
        "description": "Searches for utility pages based on the provided criteria. Currently,\nthis only gets the signed in user's utility pages.\n\n```tsx\n  await BitBadgesApi.searchUtilityPages(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchUtilityPagesPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchUtilityPagesSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#searchutilitylistings)**\n\nScopes:\n- `manageUtilityPages` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iSearchUtilityPagesSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "description": "The pagination bookmark to start from",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ],
        "x-internal": false
      }
    },
    "/utilityPages": {
      "post": {
        "operationId": "createUtilityPage",
        "summary": "Create Utility Page",
        "tags": [
          "Utility Pages"
        ],
        "description": "Creates a new utility page. This is also available in the developer portal.\n\n```tsx\nawait BitBadgesApi.createUtilityPage(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateUtilityPagePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCreateUtilityPageSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#createutilitylisting)**\n\nScopes:\n- `manageUtilityPages` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCreateUtilityPageSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iCreateUtilityPagePayload"
              }
            }
          }
        }
      },
      "put": {
        "operationId": "updateUtilityPage",
        "summary": "Update Utility Page",
        "tags": [
          "Utility Pages"
        ],
        "description": "Updates an existing utility page. This is also available in the developer portal.\n\n```tsx\nawait BitBadgesApi.updateUtilityPage(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateUtilityPagePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iUpdateUtilityPageSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#updateutilitylisting)**\n\nScopes:\n- `manageUtilityPages` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iUpdateUtilityPageSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iUpdateUtilityPagePayload"
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "deleteUtilityPage",
        "summary": "Delete Utility Page",
        "tags": [
          "Utility Pages"
        ],
        "description": "Deletes a utility page. This is also available in the developer portal.\n\n```tsx\nawait BitBadgesApi.deleteUtilityPage(...);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteUtilityPagePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iDeleteUtilityPageSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#deleteutilitylisting)**\n\nScopes:\n- `manageUtilityPages` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iDeleteUtilityPageSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": [],
            "userSignedIn": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iDeleteUtilityPagePayload"
              }
            }
          }
        }
      }
    },
    "/auth/status": {
      "post": {
        "operationId": "checkSignInStatus",
        "summary": "Check Sign In Status",
        "description": "Checks if a user is currently signed in and returns their authentication status.\n\n```tsx\nconst res = await BitBadgesApi.checkIfSignedIn(...);\nconsole.log(res.signedIn);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCheckSignInStatusPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iCheckSignInStatusSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#checkifsignedin)**\n",
        "tags": [
          "Sign In with BitBadges"
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved authentication status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iCheckSignInStatusSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iCheckSignInStatusPayload"
              }
            }
          }
        },
        "security": [
          {
            "userMaybeSignedIn": []
          }
        ],
        "x-internal": false
      }
    },
    "/account/{address}/requests/siwbb": {
      "get": {
        "operationId": "getSiwbbRequestsForUser",
        "summary": "Get SIWBB Requests For User",
        "tags": [
          "Accounts"
        ],
        "description": "Gets Sign-In with BitBadges (SIWBB) requests for a user.\n\n```tsx\nawait BitBadgesApi.getSiwbbRequestsForUser({ address: \"bb1...\" });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetSiwbbRequestsForUserPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetSiwbbRequestsForUserSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getsiwbbrequestsforuser)**\n\nScopes:\n  - `readAuthenticationCodes` - Required",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetSiwbbRequestsForUserSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "Account address",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/account/{address}/activity/tokens": {
      "get": {
        "operationId": "getTransferActivityForUser",
        "summary": "Get Transfer Activity For User",
        "tags": [
          "Accounts"
        ],
        "description": "Gets transfer activity for a specific user.\n\n```tsx\nawait BitBadgesApi.getTransferActivityForUser({ address: \"bb1...\" });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTransferActivityForUserPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTransferActivityForUserSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#gettransferactivityforuser)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetTransferActivityForUserSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "Account address",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/account/{address}/tokens": {
      "get": {
        "operationId": "GetTokensViewForUser",
        "summary": "Get Tokens For User",
        "tags": [
          "Accounts"
        ],
        "description": "Gets tokens for a specific user. Specify the viewType to determine what\ntokens to retrieve. Default is 'collected'.\n\n```tsx\nawait BitBadgesApi.getTokensViewForUser(address, { viewType: \"collected\" });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTokensViewForUserPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTokensViewForUserSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getbadgesviewforuser)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetTokensViewForUserSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "Account address",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "collectionId",
            "required": false,
            "schema": {
              "description": "Optional collection ID to filter by",
              "$ref": "#/components/schemas/CollectionId"
            }
          },
          {
            "in": "query",
            "name": "viewType",
            "required": false,
            "schema": {
              "enum": [
                "collected",
                "managing",
                "created"
              ],
              "description": "The view type to search for. Default is 'collected'\n\n- 'collected' will return the tokens the user has a balance of\n- 'managing' will return the tokens the user is managing\n- 'created' will return the tokens the user has created",
              "type": "string",
              "examples": [
                "viewKey"
              ]
            }
          },
          {
            "in": "query",
            "name": "standard",
            "required": false,
            "schema": {
              "description": "The standard to filter by for the view.",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/account/{address}/activity/claims": {
      "get": {
        "operationId": "getClaimActivityForUser",
        "summary": "Get Claim Activity For User",
        "tags": [
          "Accounts"
        ],
        "description": "Gets claim activity for a specific user. Specify the viewType to determine what\nclaim activity to retrieve.\n\nMost claim activity will be public, but if the state is hidden, then only the\nmanager of the claim and you should be able to see the activity.\n\n```tsx\nawait BitBadgesApi.getClaimActivityForUser(address, { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimActivityForUserPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetClaimActivityForUserSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getclaimactivityforuser)**\n\nScopes:\n  - `completeClaims` - Required if fetching all claim activity.",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetClaimActivityForUserSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "Account address",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "viewType",
            "required": false,
            "schema": {
              "enum": [
                "all",
                "public"
              ],
              "description": "The view type to search for. Default is 'public'\n\n- 'all' will return all claim activity even private (must have permission to view private activity)\n- 'public' will only return public claim activity",
              "type": "string",
              "examples": [
                "viewKey"
              ]
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/account/{address}/activity/points": {
      "get": {
        "operationId": "getPointsActivityForUser",
        "summary": "Get Points Activity For User",
        "tags": [
          "Accounts"
        ],
        "description": "Gets points activity for a specific user.\n\n```tsx\nawait BitBadgesApi.getPointsActivityForUser({ address: \"bb1...\" });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPointsActivityForUserPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPointsActivityForUserSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getpointsactivityforuser)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetPointsActivityForUserSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "Account address",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/collection/{collectionId}/owners": {
      "get": {
        "operationId": "getCollectionOwners",
        "summary": "Get Collection Owners",
        "tags": [
          "Tokens"
        ],
        "description": "Gets owners for a specific collection.\n\n```tsx\nawait BitBadgesApi.getCollectionOwners(\"123\");\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionOwnersPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionOwnersSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollectionowners)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionOwnersSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "collectionId",
            "in": "path",
            "description": "Collection ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/collection/{collectionId}/activity": {
      "get": {
        "operationId": "getCollectionTransferActivity",
        "summary": "Get Collection Transfer Activity",
        "tags": [
          "Tokens"
        ],
        "description": "Gets transfer activity for a specific collection.\n\n```tsx\nawait BitBadgesApi.getCollectionTransferActivity(\"123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionTransferActivityPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionTransferActivitySuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollectiontransferactivity)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionTransferActivitySuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "collectionId",
            "in": "path",
            "description": "Collection ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "address",
            "required": false,
            "schema": {
              "description": "Optional address to filter activity by",
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/collection/{collectionId}/challengeTrackers": {
      "get": {
        "operationId": "getCollectionChallengeTrackers",
        "summary": "Get Collection Challenge Trackers",
        "tags": [
          "Tokens"
        ],
        "description": "Gets challenge trackers for a specific collection.\n\n```tsx\nawait BitBadgesApi.getCollectionChallengeTrackers(\"123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionChallengeTrackersPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionChallengeTrackersSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollectionchallengetrackers)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionChallengeTrackersSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "collectionId",
            "in": "path",
            "description": "Collection ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/collection/{collectionId}/amountTrackers": {
      "get": {
        "operationId": "getCollectionAmountTrackers",
        "summary": "Get Collection Amount Trackers",
        "tags": [
          "Tokens"
        ],
        "description": "Gets amount trackers for a specific collection.\n\n```tsx\nawait BitBadgesApi.getCollectionAmountTrackers(\"123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionAmountTrackersPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionAmountTrackersSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollectionamounttrackers)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionAmountTrackersSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "collectionId",
            "in": "path",
            "description": "Collection ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/v0/collection/amountTracker": {
      "get": {
        "operationId": "getCollectionAmountTrackerById",
        "summary": "Get Collection Amount Tracker By ID",
        "tags": [
          "Tokens"
        ],
        "description": "Gets an amount tracker by ID for a collection.\n\n```tsx\nawait BitBadgesApi.getCollectionAmountTrackerById({ ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iAmountTrackerIdDetails)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionAmountTrackerByIdSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollectionamounttrackerbyid)**",
        "parameters": [
          {
            "in": "query",
            "name": "collectionId",
            "required": true,
            "schema": {
              "description": "The collection ID for the approval.",
              "$ref": "#/components/schemas/CollectionId"
            }
          },
          {
            "in": "query",
            "name": "approvalId",
            "required": true,
            "schema": {
              "description": "The approval ID",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "amountTrackerId",
            "required": true,
            "schema": {
              "description": "The amount tracker ID of the approval.",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "approvalLevel",
            "required": true,
            "schema": {
              "description": "The approval level of the approval \"collection\", \"incoming\", or \"outgoing\".",
              "type": "string",
              "examples": [
                "collection",
                "incoming",
                "outgoing"
              ]
            }
          },
          {
            "in": "query",
            "name": "approverAddress",
            "required": true,
            "schema": {
              "description": "The address of the approval to check.",
              "$ref": "#/components/schemas/BitBadgesAddress"
            }
          },
          {
            "in": "query",
            "name": "trackerType",
            "required": true,
            "schema": {
              "description": "The type of tracker to check \"overall\", \"to\", \"from\", or \"initiatedBy\".",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "approvedAddress",
            "required": true,
            "schema": {
              "description": "The address to check for the approval.",
              "$ref": "#/components/schemas/BitBadgesAddress"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionAmountTrackerByIdSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/v0/collection/challengeTracker": {
      "get": {
        "operationId": "getCollectionChallengeTrackerById",
        "summary": "Get Collection Challenge Tracker By ID",
        "tags": [
          "Tokens"
        ],
        "description": "Gets a challenge tracker by ID for a collection.\n\n```tsx\nawait BitBadgesApi.getCollectionChallengeTrackerById({ ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iChallengeTrackerIdDetails)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionChallengeTrackerByIdSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollectionchallengetrackerbyid)**",
        "parameters": [
          {
            "in": "query",
            "name": "collectionId",
            "required": true,
            "schema": {
              "description": "The collection ID",
              "$ref": "#/components/schemas/CollectionId"
            }
          },
          {
            "in": "query",
            "name": "approvalId",
            "required": true,
            "schema": {
              "description": "The approval ID",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "challengeTrackerId",
            "required": true,
            "schema": {
              "description": "The challenge ID",
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "approvalLevel",
            "required": true,
            "schema": {
              "enum": [
                "collection",
                "incoming",
                "outgoing",
                ""
              ],
              "description": "The challenge level (i.e. \"collection\", \"incoming\", \"outgoing\")",
              "type": "string",
              "examples": [
                "collection",
                "incoming",
                "outgoing"
              ]
            }
          },
          {
            "in": "query",
            "name": "approverAddress",
            "required": true,
            "schema": {
              "description": "The approver address (leave blank if approvalLevel = \"collection\")",
              "$ref": "#/components/schemas/BitBadgesAddress"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionChallengeTrackerByIdSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ]
      }
    },
    "/collection/{collectionId}/listings": {
      "get": {
        "operationId": "getCollectionListings",
        "summary": "Get Collection Listings",
        "tags": [
          "Tokens"
        ],
        "description": "Gets listings for a specific collection.\n\n```tsx\nawait BitBadgesApi.getCollectionListings(\"123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionListingsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionListingsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollectionlistings)**",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionListingsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "collectionId",
            "in": "path",
            "description": "Collection ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "oldestFirst",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "tokenId",
            "required": false,
            "schema": {
              "description": "Optional token ID to filter listings by",
              "$ref": "#/components/schemas/NumberType"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/collection/{collectionId}/claims": {
      "get": {
        "operationId": "getCollectionClaims",
        "summary": "Get Collection Claims",
        "tags": [
          "Tokens"
        ],
        "description": "Gets claims for a specific collection.\n\n```tsx\nawait BitBadgesApi.getCollectionClaims(\"123\", { ... });\n```\n\nSDK Links:\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetCollectionClaimsSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getcollectionclaims)**\n\nScopes:\n  - `readPrivateClaimData` - Required if fetching private claim data (also must be manager of collection)\n\nNote: For fetching more advanced information like private claim data, you can do so with the get claim routes. Use the IDs from these responses.",
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetCollectionClaimsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "collectionId",
            "in": "path",
            "description": "Collection ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/v0/requestBin/attemptData/{claimId}/{claimAttemptId}": {
      "get": {
        "operationId": "getAttemptDataFromRequestBin",
        "summary": "Get Attempt Data (Request Bin)",
        "tags": [
          "Claims"
        ],
        "description": "Gets the attempt data for a specific claim attempt from the requestBin plugin.\n\nPre-Req: Your claim must be setup with a \"requestBin\" plugin. On the site, it will be titled\n\"Collect User Inputs\". If there is none, this will fail.\n\n```tsx\nawait BitBadgesApi.getAttemptDataFromRequestBin(\"claim123\", \"attempt123\", { ... });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAttemptDataFromRequestBinPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAttemptDataFromRequestBinSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getattemptdatafromrequestbin)**\n\nScopes:\n  - `readPrivateClaimData` - Required and must be the manager",
        "parameters": [
          {
            "name": "claimId",
            "in": "path",
            "description": "Claim ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "claimAttemptId",
            "in": "path",
            "description": "Claim attempt ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "instanceId",
            "required": false,
            "schema": {
              "description": "The instance ID of the request bin plugin.\n\nOnly needed if there are duplicates. Else, we default to first instance found.",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetAttemptDataFromRequestBinSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/pools": {
      "get": {
        "operationId": "getAllPools",
        "summary": "Get All Pools",
        "description": "Retrieves all available liquidity pools.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAllPoolsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAllPoolsSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "sortBy",
            "required": false,
            "schema": {
              "enum": [
                "liquidity",
                "volume",
                "dailyVolume",
                "weeklyVolume",
                "monthlyVolume",
                "allTimeVolume",
                "lastLiquidityUpdate",
                "lastVolumeUpdate"
              ],
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "sortOrder",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetAllPoolsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/pools/byDenom": {
      "get": {
        "operationId": "getPoolInfosByDenom",
        "summary": "Get Pool Infos by Denom",
        "description": "Retrieves pool information filtered by denomination.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPoolInfosByDenomPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPoolInfosByDenomSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "denom",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetPoolInfosByDenomSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/pools/byAssets": {
      "get": {
        "operationId": "getPoolInfosByAssets",
        "summary": "Get Pool Infos by Assets",
        "description": "Retrieves pool information filtered by specific assets.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPoolInfosByAssetsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPoolInfosByAssetsSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "asset1",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "asset2",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetPoolInfosByAssetsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/pools/{poolId}": {
      "get": {
        "operationId": "getPoolInfoById",
        "summary": "Get Pool Info by ID",
        "description": "Retrieves detailed information for a specific pool by its ID.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPoolInfoByIdPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetPoolInfoByIdSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "poolId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "poolId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetPoolInfoByIdSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/swaps/estimate": {
      "post": {
        "operationId": "estimateSwap",
        "summary": "Estimate Swap",
        "description": "Estimates the output amount for a swap operation.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iEstimateSwapPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iEstimateSwapSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iEstimateSwapPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iEstimateSwapSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/assetPairs": {
      "get": {
        "operationId": "getAssetPairs",
        "summary": "Get Asset Pairs",
        "description": "Retrieves all available asset pairs.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAssetPairsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetAssetPairsSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "sortBy",
            "required": false,
            "schema": {
              "enum": [
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d",
                "price"
              ],
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "sortDirection",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetAssetPairsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/assetPairs/topGainers": {
      "get": {
        "operationId": "getTopGainers",
        "summary": "Get Top Gainers",
        "description": "Retrieves asset pairs with the highest price gains.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTopGainersPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTopGainersSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetTopGainersSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/assetPairs/topLosers": {
      "get": {
        "operationId": "getTopLosers",
        "summary": "Get Top Losers",
        "description": "Retrieves asset pairs with the highest price losses.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTopLosersPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetTopLosersSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetTopLosersSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/assetPairs/highestVolume": {
      "get": {
        "operationId": "getHighestVolume",
        "summary": "Get Highest Volume",
        "description": "Retrieves asset pairs with the highest trading volume.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetHighestVolumePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetHighestVolumeSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetHighestVolumeSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/assetPairs/priceSorted": {
      "get": {
        "operationId": "getByPrice",
        "summary": "Get by Price",
        "description": "Retrieves asset pairs sorted by price.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetByPricePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetByPriceSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "sortDirection",
            "required": false,
            "schema": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetByPriceSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/assetPairs/weeklyTopGainers": {
      "get": {
        "operationId": "getWeeklyTopGainers",
        "summary": "Get Weekly Top Gainers",
        "description": "Retrieves asset pairs with the highest weekly price gains.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetWeeklyTopGainersPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetWeeklyTopGainersSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetWeeklyTopGainersSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/assetPairs/weeklyTopLosers": {
      "get": {
        "operationId": "getWeeklyTopLosers",
        "summary": "Get Weekly Top Losers",
        "description": "Retrieves asset pairs with the highest weekly price losses.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetWeeklyTopLosersPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetWeeklyTopLosersSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetWeeklyTopLosersSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/assetPairs/search": {
      "get": {
        "operationId": "searchAssetPairsByText",
        "summary": "Search Asset Pairs by Text",
        "description": "Searches asset pairs by text query.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchAssetPairsByTextPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iSearchAssetPairsByTextSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iSearchAssetPairsByTextSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/api/{version}/assetPairs/byDenoms": {
      "post": {
        "operationId": "getByDenoms",
        "summary": "Get Asset Pairs by Denoms",
        "description": "Retrieves asset pairs filtered by specific denominations.\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetByDenomsPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetByDenomsSuccessResponse)**\n",
        "tags": [
          "Assets"
        ],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/iGetByDenomsPayload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetByDenomsSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/swapActivities": {
      "get": {
        "operationId": "getSwapActivities",
        "summary": "Get Swap Activities",
        "tags": [
          "Assets"
        ],
        "description": "Retrieves swap activities with pagination. Returns the latest swap activities sorted by block height descending.\n\n```tsx\nconst res = await BitBadgesApi.getSwapActivities({ bookmark: '', limit: 25 });\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetSwapActivitiesPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetSwapActivitiesSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getswapactivities)**\n",
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "bookmark",
            "in": "query",
            "description": "Pagination bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return (1-100)",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetSwapActivitiesSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/onChainDynamicStore/{storeId}": {
      "get": {
        "operationId": "getOnChainDynamicStore",
        "summary": "Get On-Chain Dynamic Store",
        "tags": [
          "On-Chain Dynamic Stores"
        ],
        "description": "Retrieves an on-chain dynamic store by its ID. On-chain dynamic stores are key-value stores stored on the blockchain.\n\n```tsx\nconst res = await BitBadgesApi.getOnChainDynamicStore(storeId);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOnChainDynamicStorePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOnChainDynamicStoreSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getonchaindynamicstore)**\n",
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "storeId",
            "in": "path",
            "description": "Store ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetOnChainDynamicStoreSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/onChainDynamicStores/by-creator/{address}": {
      "get": {
        "operationId": "getOnChainDynamicStoresByCreator",
        "summary": "Get On-Chain Dynamic Stores by Creator",
        "tags": [
          "On-Chain Dynamic Stores"
        ],
        "description": "Retrieves all on-chain dynamic stores created by a specific address.\n\n```tsx\nconst res = await BitBadgesApi.getOnChainDynamicStoresByCreator(address);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOnChainDynamicStoresByCreatorPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOnChainDynamicStoresByCreatorSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getonchaindynamicstoresbycreator)**\n",
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "Creator address",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetOnChainDynamicStoresByCreatorSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/onChainDynamicStore/{storeId}/value/{address}": {
      "get": {
        "operationId": "getOnChainDynamicStoreValue",
        "summary": "Get On-Chain Dynamic Store Value",
        "tags": [
          "On-Chain Dynamic Stores"
        ],
        "description": "Retrieves the value for a specific address in an on-chain dynamic store. Returns the store's default value if no specific value is set for the address.\n\n```tsx\nconst res = await BitBadgesApi.getOnChainDynamicStoreValue(storeId, address);\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOnChainDynamicStoreValuePayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOnChainDynamicStoreValueSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getonchaindynamicstorevalue)**\n",
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "storeId",
            "in": "path",
            "description": "Store ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "address",
            "in": "path",
            "description": "Address to get value for",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetOnChainDynamicStoreValueSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    },
    "/onChainDynamicStore/{storeId}/values": {
      "get": {
        "operationId": "getOnChainDynamicStoreValuesPaginated",
        "summary": "Get On-Chain Dynamic Store Values (Paginated)",
        "tags": [
          "On-Chain Dynamic Stores"
        ],
        "description": "Retrieves a paginated list of all values in an on-chain dynamic store.\n\n```tsx\nconst res = await BitBadgesApi.getOnChainDynamicStoreValuesPaginated(storeId, {\n  bookmark: '',\n  limit: 25\n});\n```\n\nSDK Links:\n- **[Request Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOnChainDynamicStoreValuesPaginatedPayload)**\n- **[Response Type](https://bitbadges.github.io/bitbadgesjs/interfaces/iGetOnChainDynamicStoreValuesPaginatedSuccessResponse)**\n- **[SDK API Function](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html#getonchaindynamicstorevaluespaginated)**\n",
        "parameters": [
          {
            "name": "x-api-key",
            "in": "header",
            "description": "BitBadges API Key for authentication",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "storeId",
            "in": "path",
            "description": "Store ID",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "bookmark",
            "in": "query",
            "description": "Pagination bookmark",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return (1-100)",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/iGetOnChainDynamicStoreValuesPaginatedSuccessResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestResponse"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerErrorResponse"
          }
        },
        "security": [
          {
            "apiKey": []
          }
        ],
        "x-internal": false
      }
    }
  },
  "components": {
    "responses": {
      "ErrorResponse": {
        "description": "An error response",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        }
      },
      "BadRequestResponse": {
        "description": "Bad Request - Invalid configuration or request",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        }
      },
      "UnauthorizedResponse": {
        "description": "Unauthorized - Does not meet authentication requirements. This can be due to an invalid API key, CORS origin, or session cookie.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        }
      },
      "InternalServerErrorResponse": {
        "description": "Internal Server Error",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        }
      }
    },
    "securitySchemes": {
      "apiKey": {
        "type": "apiKey",
        "in": "header",
        "name": "x-api-key",
        "description": "Requires a BitBadges API key. This is true for all requests.",
        "x-type": "string"
      },
      "frontendOnly": {
        "type": "apiKey",
        "in": "header",
        "name": "Origin",
        "description": "Can only be called by the official BitBadges frontend. Not for developer use."
      },
      "userSignedIn": {
        "type": "http",
        "scheme": "cookie",
        "description": "User must be signed in with correct OAuth scopes with a valid session and correct OAuth scopes. This can be done with OAuth 2.0 or an approved sign in."
      },
      "userMaybeSignedIn": {
        "type": "http",
        "scheme": "cookie",
        "description": "User must be signed in with correct OAuth scopes for certain requests that fetch sensitive information, but certain requests can be made without being signed in. This can be done with OAuth 2.0 or an approved sign in."
      },
      "userIsManager": {
        "type": "http",
        "scheme": "cookie",
        "description": "User must be signed in with correct OAuth scopes and be the manager of the requested collection."
      },
      "userIsOwner": {
        "type": "http",
        "scheme": "cookie",
        "description": "User must be signed in with correct OAuth scopes and must be the owner of the requested object."
      }
    },
    "schemas": {
      "SupportedChain": {
        "enum": [
          "Cosmos",
          "Unknown"
        ],
        "type": "string"
      },
      "AssetDetails": {
        "properties": {
          "chain": {
            "type": "string"
          },
          "collectionId": {
            "type": "string"
          },
          "assetIds": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/UintRange"
                }
              ]
            },
            "type": "array"
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/UintRange"
            },
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "mustOwnAmounts": {
            "$ref": "#/components/schemas/UintRange"
          },
          "additionalCriteria": {
            "type": "string"
          },
          "ownershipPartyCheck": {
            "type": "string"
          }
        },
        "required": [
          "chain",
          "collectionId",
          "assetIds",
          "ownershipTimes",
          "mustOwnAmounts"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "AndGroup": {
        "properties": {
          "$and": {
            "items": {
              "$ref": "#/components/schemas/AssetConditionGroup"
            },
            "type": "array"
          }
        },
        "required": [
          "$and"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "OrGroup": {
        "properties": {
          "$or": {
            "items": {
              "$ref": "#/components/schemas/AssetConditionGroup"
            },
            "type": "array"
          }
        },
        "required": [
          "$or"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "AssetConditionGroup": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/AndGroup"
          },
          {
            "$ref": "#/components/schemas/OrGroup"
          },
          {
            "$ref": "#/components/schemas/OwnershipRequirements"
          }
        ],
        "examples": [
          {
            "$and": [
              {
                "assets": [
                  {
                    "chain": "BitBadges",
                    "collectionId": "1",
                    "assetIds": [
                      {
                        "start": "1",
                        "end": "1"
                      }
                    ],
                    "mustOwnAmounts": {
                      "start": "1",
                      "end": "1"
                    },
                    "ownershipTimes": []
                  }
                ]
              }
            ]
          }
        ]
      },
      "OwnershipRequirements": {
        "properties": {
          "assets": {
            "items": {
              "$ref": "#/components/schemas/AssetDetails"
            },
            "type": "array"
          },
          "options": {
            "properties": {
              "numMatchesForVerification": {
                "$ref": "#/components/schemas/NumberType"
              }
            },
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "assets"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "ChallengeParams": {
        "properties": {
          "domain": {
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "statement": {
            "type": "string"
          },
          "address": {
            "type": "string"
          },
          "uri": {
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "nonce": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "chainId": {
            "type": "string"
          },
          "issuedAt": {
            "type": "string",
            "examples": [
              "2022-01-01T00:00:00Z"
            ]
          },
          "expirationDate": {
            "type": "string",
            "examples": [
              "2022-01-01T00:00:00Z"
            ]
          },
          "notBefore": {
            "type": "string",
            "examples": [
              "2022-01-01T00:00:00Z"
            ]
          },
          "resources": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "examples": [
              [
                "Full Access: Full access to all features."
              ]
            ]
          },
          "assetOwnershipRequirements": {
            "examples": [
              {
                "assets": [
                  {
                    "chain": "BitBadges",
                    "collectionId": "1",
                    "assetIds": [
                      {
                        "start": "1",
                        "end": "1"
                      }
                    ],
                    "mustOwnAmounts": {
                      "start": "1",
                      "end": "1"
                    },
                    "ownershipTimes": []
                  }
                ]
              }
            ],
            "$ref": "#/components/schemas/AssetConditionGroup"
          }
        },
        "required": [
          "domain",
          "statement",
          "address",
          "uri",
          "nonce"
        ],
        "additionalProperties": false,
        "description": "Interface for EIP-4361 Challenge - Sign in With Ethereum\n\nFor more information and documentation, view the EIP proposal.\n\nWe extend it to support assets.",
        "type": "object"
      },
      "VerifyChallengeOptions": {
        "properties": {
          "expectedChallengeParams": {
            "properties": {
              "domain": {
                "type": "string",
                "examples": [
                  "https://example.com",
                  "ipfs://Qm..."
                ]
              },
              "statement": {
                "type": "string"
              },
              "address": {
                "type": "string"
              },
              "uri": {
                "type": "string",
                "examples": [
                  "https://example.com",
                  "ipfs://Qm..."
                ]
              },
              "nonce": {
                "type": "string"
              },
              "version": {
                "type": "string"
              },
              "chainId": {
                "type": "string"
              },
              "issuedAt": {
                "type": "string",
                "examples": [
                  "2022-01-01T00:00:00Z"
                ]
              },
              "expirationDate": {
                "type": "string",
                "examples": [
                  "2022-01-01T00:00:00Z"
                ]
              },
              "notBefore": {
                "type": "string",
                "examples": [
                  "2022-01-01T00:00:00Z"
                ]
              },
              "resources": {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "examples": [
                  [
                    "Full Access: Full access to all features."
                  ]
                ]
              },
              "assetOwnershipRequirements": {
                "$ref": "#/components/schemas/AssetConditionGroup",
                "examples": [
                  {
                    "assets": [
                      {
                        "chain": "BitBadges",
                        "collectionId": "1",
                        "assetIds": [
                          {
                            "start": "1",
                            "end": "1"
                          }
                        ],
                        "mustOwnAmounts": {
                          "start": "1",
                          "end": "1"
                        },
                        "ownershipTimes": []
                      }
                    ]
                  }
                ]
              }
            },
            "additionalProperties": false,
            "description": "Optionally define the expected details to check. If the challenge was edited and the details\ndo not match, the challenge will fail verification.",
            "type": "object"
          },
          "beforeVerification": {
            "description": "Optional function to call before verification. This is useful to verify the challenge is\nvalid before proceeding with verification.\n\nNote you can use expectedChallengeParams to verify values equal as expected.\n\nThis function is useful if you need to implement custom logic other than strict equality).\nFor example, assert that only one of assets A, B, or C are defined and not all three."
          },
          "balancesSnapshot": {
            "description": "For verification of assets, instead of dynamically fetching the assets, you can specify a snapshot of the assets.\n\nThis is useful if you have a snapshot, balances will not change, or you are verifying in an offline manner.",
            "type": "object"
          },
          "skipTimestampVerification": {
            "description": "If true, we do not check timestamps (expirationDate / notBefore). This is useful if you are verifying a challenge that is expected to be verified at a future time.",
            "type": "boolean"
          },
          "skipAssetVerification": {
            "description": "If true, we do not check asset ownership. This is useful if you are verifying a challenge that is expected to be verified at a future time.",
            "type": "boolean"
          },
          "earliestIssuedAt": {
            "description": "The earliest issued At ISO date string that is valid. For example, if you want to verify a challenge that was issued within the last minute, you can specify this to be 1 minute ago.",
            "type": "string",
            "examples": [
              "2022-01-01T00:00:00Z"
            ]
          },
          "issuedAtTimeWindowMs": {
            "description": "If set, we will verify the issuedAt is within this amount of ms ago (i.e. issuedAt >= Date.now() - issuedAtTimeWindowMs)",
            "type": "number"
          },
          "skipSignatureVerification": {
            "description": "If true, we do not check the signature. You can pass in an undefined ChainDriver",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "description": "Options that can be specified when calling verifyChallenge()",
        "type": "object"
      },
      "iLiquidityPoolInfoVolume": {
        "properties": {
          "daily": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "weekly": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "monthly": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "allTime": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          }
        },
        "required": [
          "daily",
          "weekly",
          "monthly",
          "allTime"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iLiquidityPoolInfoDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "poolId": {
            "type": "string"
          },
          "collectionId": {
            "type": "string"
          },
          "address": {
            "type": "string"
          },
          "allAssetDenoms": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "asset1": {
            "type": "string"
          },
          "asset2": {
            "type": "string"
          },
          "poolParams": {
            "properties": {
              "swapFee": {
                "type": "string"
              },
              "exitFee": {
                "type": "string"
              }
            },
            "required": [
              "swapFee",
              "exitFee"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "volume": {
            "$ref": "#/components/schemas/iLiquidityPoolInfoVolume"
          },
          "lastVolumeUpdate": {
            "type": "number"
          },
          "liquidity": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "lastLiquidityUpdate": {
            "type": "number"
          },
          "totalShares": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "_docId",
          "poolId",
          "collectionId",
          "address",
          "allAssetDenoms",
          "asset1",
          "asset2",
          "volume",
          "lastVolumeUpdate",
          "liquidity",
          "lastLiquidityUpdate",
          "totalShares"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iAssetPriceHistoryDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "asset": {
            "type": "string"
          },
          "price": {
            "type": "number"
          },
          "timestamp": {
            "$ref": "#/components/schemas/NumberType"
          },
          "totalLiquidity": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "timeframe": {
            "type": "string"
          },
          "high": {
            "type": "number"
          },
          "low": {
            "type": "number"
          },
          "open": {
            "type": "number"
          }
        },
        "required": [
          "_docId",
          "asset",
          "price",
          "timestamp",
          "totalLiquidity"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iGetAllPoolsPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "sortBy": {
            "enum": [
              "liquidity",
              "volume",
              "dailyVolume",
              "weeklyVolume",
              "monthlyVolume",
              "allTimeVolume",
              "lastLiquidityUpdate",
              "lastVolumeUpdate"
            ],
            "type": "string"
          },
          "sortOrder": {
            "enum": [
              "asc",
              "desc"
            ],
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetAllPoolsSuccessResponse": {
        "properties": {
          "pools": {
            "items": {},
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "pools",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPoolInfosByDenomPayload": {
        "properties": {
          "denom": {
            "type": "string"
          }
        },
        "required": [
          "denom"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPoolInfosByDenomSuccessResponse": {
        "properties": {
          "pools": {
            "items": {},
            "type": "array"
          },
          "denom": {
            "type": "string"
          },
          "count": {
            "type": "number"
          }
        },
        "required": [
          "pools",
          "denom",
          "count"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPoolInfosByAssetsPayload": {
        "properties": {
          "asset1": {
            "type": "string"
          },
          "asset2": {
            "type": "string"
          }
        },
        "required": [
          "asset1"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPoolInfosByAssetsSuccessResponse": {
        "properties": {
          "pools": {
            "items": {},
            "type": "array"
          },
          "asset1": {
            "type": "string"
          },
          "asset2": {
            "type": "string"
          },
          "count": {
            "type": "number"
          }
        },
        "required": [
          "pools",
          "asset1",
          "count"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPoolInfoByIdPayload": {
        "properties": {
          "poolId": {
            "type": "string"
          }
        },
        "required": [
          "poolId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPoolInfoByIdSuccessResponse": {
        "properties": {
          "success": {
            "type": "boolean"
          },
          "poolInfo": {}
        },
        "required": [
          "success",
          "poolInfo"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iEstimateSwapPayload": {
        "properties": {
          "tokenIn": {
            "description": "The token in to swap. Formats accepted: \"amount:1,denom:ubadge\" or \"1ubadge\"",
            "type": "string"
          },
          "tokenInChainId": {
            "description": "Optional chain ID for the token in. Defaults to \"bitbadges-1\" if not provided.",
            "type": "string"
          },
          "tokenOutDenom": {
            "description": "The token out denom to swap to.",
            "type": "string"
          },
          "tokenOutChainId": {
            "description": "Optional chain ID for the token out. Defaults to \"bitbadges-1\" if not provided.",
            "type": "string"
          },
          "chainIdsToAddresses": {
            "description": "Mapping of chain IDs to addresses.\nOnly supports \"bitbadges-1\" (bech32 bb prefixed address for Cosmos-based chains) and \"1\" (EVM-based chains with a standard 0x address)\n\nWe will generate any other chain addresses from these addresses."
          },
          "chainIdsToAffiliates": {
            "description": "Optional mapping of chain IDs to affiliate fee recipients.\nStructure: { [chainId]: { affiliates: Array<{ address: string; basis_points_fee: string }> } }"
          },
          "slippageTolerancePercent": {
            "description": "Slippage tolerance as a percentage (0-100). Can be a string or number.",
            "$ref": "#/components/schemas/NumberType"
          },
          "forcefulRecheckCompliance": {
            "description": "Forcefully recheck compliance and avoid cache (5 minutes)",
            "type": "boolean"
          }
        },
        "required": [
          "tokenIn",
          "tokenOutDenom",
          "chainIdsToAddresses",
          "slippageTolerancePercent"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iEstimateSwapSuccessResponse": {
        "properties": {
          "success": {
            "description": "Whether the swap estimation was successful.",
            "type": "boolean"
          },
          "estimate": {
            "properties": {
              "tokenOutAmount": {
                "description": "The estimated amount of tokens that will be received (token out).",
                "type": "string"
              },
              "tokenInAmount": {
                "description": "The amount of tokens being swapped in (token in).",
                "type": "string"
              },
              "skipGoMsgs": {
                "items": {
                  "$ref": "#/components/schemas/SkipGoMessage"
                },
                "description": "Messages for multi-chain routing.\nContains either a multi-chain message (for Cosmos chains) or an EVM transaction (for EVM chains).\nThese messages are used to execute the swap across different chains if needed.",
                "type": "array"
              },
              "assetPath": {
                "items": {
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "chainId": {
                      "type": "string"
                    },
                    "how": {
                      "enum": [
                        "genesis",
                        "swap",
                        "transfer"
                      ],
                      "type": "string"
                    }
                  },
                  "required": [
                    "denom",
                    "chainId",
                    "how"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "description": "The path the asset takes through different chains and operations to complete the swap.\nEach step in the path indicates the denom, chain ID, and how the asset moves (genesis, swap, or transfer).",
                "type": "array"
              },
              "doesSwap": {
                "description": "Whether an actual swap operation occurs (true) or if it's just a transfer.",
                "type": "boolean"
              },
              "lowLiquidityWarning": {
                "description": "Warning flag indicating if the liquidity pool has low liquidity, which may affect swap execution.",
                "type": "boolean"
              },
              "complianceNotPassedWarning": {
                "description": "Warning flag indicating if compliance checks did not pass for this swap. This means swap is likely to fail on BitBadges pool swap with compliance checks.",
                "type": "boolean"
              },
              "complianceErrorMessage": {
                "description": "Detailed error message if compliance checks failed.",
                "type": "string"
              },
              "estimatedTime": {
                "description": "Estimated time in seconds for the swap to complete (if available).",
                "type": "number"
              },
              "fallbackAsset": {
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "chainId": {
                    "type": "string"
                  }
                },
                "required": [
                  "denom",
                  "chainId"
                ],
                "additionalProperties": false,
                "description": "Fallback asset if swap is not possible.",
                "type": "object"
              },
              "autoRedirectedToWETH": {
                "description": "Whether the swap was automatically redirected to WETH. BitBadges only supports single-tx operations. Bridges return WETH. Then, another unwrap tx is required (which we do not handle).",
                "type": "boolean"
              },
              "rerouted": {
                "description": "Whether the swap was vs standard estimate (internal use)",
                "type": "boolean"
              }
            },
            "required": [
              "tokenOutAmount",
              "tokenInAmount",
              "skipGoMsgs",
              "assetPath",
              "doesSwap"
            ],
            "additionalProperties": false,
            "description": "Detailed estimation information for the swap.",
            "type": "object"
          }
        },
        "required": [
          "success",
          "estimate"
        ],
        "additionalProperties": false,
        "description": "Response interface for a successful swap estimation.\nContains the estimated swap details including amounts, routing path, and any warnings.",
        "type": "object"
      },
      "iGetAssetPairsPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "sortBy": {
            "enum": [
              "volume24h",
              "volume7d",
              "percentageChange24h",
              "percentageChange7d",
              "price"
            ],
            "type": "string"
          },
          "sortDirection": {
            "enum": [
              "asc",
              "desc"
            ],
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetAssetPairsSuccessResponse": {
        "properties": {
          "assetPairs": {
            "items": {
              "properties": {
                "_id": {
                  "type": "string"
                },
                "_docId": {
                  "type": "string"
                },
                "asset": {
                  "type": "string"
                },
                "price": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "lastUpdated": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "totalLiquidity": {
                  "items": {},
                  "type": "array"
                },
                "volume24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "volume7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "info": {
                  "title": "info"
                }
              },
              "required": [
                "_docId",
                "asset",
                "price",
                "lastUpdated",
                "totalLiquidity",
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "assetPairs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTopGainersPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTopGainersSuccessResponse": {
        "properties": {
          "assetPairs": {
            "items": {
              "properties": {
                "_id": {
                  "type": "string"
                },
                "_docId": {
                  "type": "string"
                },
                "asset": {
                  "type": "string"
                },
                "price": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "lastUpdated": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "totalLiquidity": {
                  "items": {},
                  "type": "array"
                },
                "volume24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "volume7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "info": {
                  "title": "info"
                }
              },
              "required": [
                "_docId",
                "asset",
                "price",
                "lastUpdated",
                "totalLiquidity",
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "assetPairs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTopLosersPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTopLosersSuccessResponse": {
        "properties": {
          "assetPairs": {
            "items": {
              "properties": {
                "_id": {
                  "type": "string"
                },
                "_docId": {
                  "type": "string"
                },
                "asset": {
                  "type": "string"
                },
                "price": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "lastUpdated": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "totalLiquidity": {
                  "items": {},
                  "type": "array"
                },
                "volume24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "volume7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "info": {
                  "title": "info"
                }
              },
              "required": [
                "_docId",
                "asset",
                "price",
                "lastUpdated",
                "totalLiquidity",
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "assetPairs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetHighestVolumePayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetHighestVolumeSuccessResponse": {
        "properties": {
          "assetPairs": {
            "items": {
              "properties": {
                "_id": {
                  "type": "string"
                },
                "_docId": {
                  "type": "string"
                },
                "asset": {
                  "type": "string"
                },
                "price": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "lastUpdated": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "totalLiquidity": {
                  "items": {},
                  "type": "array"
                },
                "volume24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "volume7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "info": {
                  "title": "info"
                }
              },
              "required": [
                "_docId",
                "asset",
                "price",
                "lastUpdated",
                "totalLiquidity",
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "assetPairs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetByPricePayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "sortDirection": {
            "enum": [
              "asc",
              "desc"
            ],
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetByPriceSuccessResponse": {
        "properties": {
          "assetPairs": {
            "items": {
              "properties": {
                "_id": {
                  "type": "string"
                },
                "_docId": {
                  "type": "string"
                },
                "asset": {
                  "type": "string"
                },
                "price": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "lastUpdated": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "totalLiquidity": {
                  "items": {},
                  "type": "array"
                },
                "volume24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "volume7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "info": {
                  "title": "info"
                }
              },
              "required": [
                "_docId",
                "asset",
                "price",
                "lastUpdated",
                "totalLiquidity",
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "assetPairs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetWeeklyTopGainersPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetWeeklyTopGainersSuccessResponse": {
        "properties": {
          "assetPairs": {
            "items": {
              "properties": {
                "_id": {
                  "type": "string"
                },
                "_docId": {
                  "type": "string"
                },
                "asset": {
                  "type": "string"
                },
                "price": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "lastUpdated": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "totalLiquidity": {
                  "items": {},
                  "type": "array"
                },
                "volume24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "volume7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "info": {
                  "title": "info"
                }
              },
              "required": [
                "_docId",
                "asset",
                "price",
                "lastUpdated",
                "totalLiquidity",
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "assetPairs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetWeeklyTopLosersPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetWeeklyTopLosersSuccessResponse": {
        "properties": {
          "assetPairs": {
            "items": {
              "properties": {
                "_id": {
                  "type": "string"
                },
                "_docId": {
                  "type": "string"
                },
                "asset": {
                  "type": "string"
                },
                "price": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "lastUpdated": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "totalLiquidity": {
                  "items": {},
                  "type": "array"
                },
                "volume24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "volume7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "info": {
                  "title": "info"
                }
              },
              "required": [
                "_docId",
                "asset",
                "price",
                "lastUpdated",
                "totalLiquidity",
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "assetPairs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchAssetPairsByTextPayload": {
        "properties": {
          "query": {
            "type": "string"
          }
        },
        "required": [
          "query"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchAssetPairsByTextSuccessResponse": {
        "properties": {
          "assetPairs": {
            "items": {
              "properties": {
                "_id": {
                  "type": "string"
                },
                "_docId": {
                  "type": "string"
                },
                "asset": {
                  "type": "string"
                },
                "price": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "lastUpdated": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "totalLiquidity": {
                  "items": {},
                  "type": "array"
                },
                "volume24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "volume7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "info": {
                  "title": "info"
                }
              },
              "required": [
                "_docId",
                "asset",
                "price",
                "lastUpdated",
                "totalLiquidity",
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "assetPairs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetByDenomsPayload": {
        "properties": {
          "denoms": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "denoms"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetByDenomsSuccessResponse": {
        "properties": {
          "assetPairs": {
            "items": {
              "properties": {
                "_id": {
                  "type": "string"
                },
                "_docId": {
                  "type": "string"
                },
                "asset": {
                  "type": "string"
                },
                "price": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "lastUpdated": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "totalLiquidity": {
                  "items": {},
                  "type": "array"
                },
                "volume24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "volume7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange24h": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "percentageChange7d": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "info": {
                  "title": "info"
                }
              },
              "required": [
                "_docId",
                "asset",
                "price",
                "lastUpdated",
                "totalLiquidity",
                "volume24h",
                "volume7d",
                "percentageChange24h",
                "percentageChange7d"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "assetPairs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iWrappedCosmosAssetMetadataDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "collectionId": {
            "type": "string"
          },
          "baseDenom": {
            "type": "string"
          },
          "symbol": {
            "type": "string"
          },
          "decimals": {
            "$ref": "#/components/schemas/NumberType"
          },
          "metadata": {
            "$ref": "#/components/schemas/iMetadata"
          }
        },
        "required": [
          "_docId",
          "collectionId",
          "baseDenom",
          "symbol",
          "decimals",
          "metadata"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iSwapAmountInRoute": {
        "properties": {
          "poolId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenOutDenom": {
            "type": "string"
          }
        },
        "required": [
          "poolId",
          "tokenOutDenom"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSwapAmountOutRoute": {
        "properties": {
          "poolId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenInDenom": {
            "type": "string"
          }
        },
        "required": [
          "poolId",
          "tokenInDenom"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAffiliate": {
        "properties": {
          "basisPointsFee": {
            "description": "basis_points_fee is the fee in basis points (1/10000, e.g., 100 = 1%)",
            "type": "string"
          },
          "address": {
            "description": "address is the affiliate recipient address",
            "type": "string"
          }
        },
        "required": [
          "basisPointsFee",
          "address"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgJoinPool": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "poolId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "shareOutAmount": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenInMaxs": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          }
        },
        "required": [
          "sender",
          "poolId",
          "shareOutAmount",
          "tokenInMaxs"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgJoinPoolResponse": {
        "properties": {
          "shareOutAmount": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenIn": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          }
        },
        "required": [
          "shareOutAmount",
          "tokenIn"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgExitPool": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "poolId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "shareInAmount": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenOutMins": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          }
        },
        "required": [
          "sender",
          "poolId",
          "shareInAmount",
          "tokenOutMins"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgExitPoolResponse": {
        "properties": {
          "tokenOut": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          }
        },
        "required": [
          "tokenOut"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSwapExactAmountIn": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "routes": {
            "items": {
              "$ref": "#/components/schemas/iSwapAmountInRoute"
            },
            "type": "array"
          },
          "tokenIn": {
            "$ref": "#/components/schemas/iCosmosCoin"
          },
          "tokenOutMinAmount": {
            "$ref": "#/components/schemas/NumberType"
          },
          "affiliates": {
            "items": {
              "$ref": "#/components/schemas/iAffiliate"
            },
            "type": "array"
          }
        },
        "required": [
          "sender",
          "routes",
          "tokenIn",
          "tokenOutMinAmount",
          "affiliates"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSwapExactAmountInResponse": {
        "properties": {
          "tokenOutAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "tokenOutAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iIBCTransferInfo": {
        "properties": {
          "sourceChannel": {
            "type": "string"
          },
          "receiver": {
            "type": "string"
          },
          "memo": {
            "type": "string"
          },
          "timeoutTimestamp": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "sourceChannel",
          "receiver",
          "memo",
          "timeoutTimestamp"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSwapExactAmountInWithIBCTransfer": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "routes": {
            "items": {
              "$ref": "#/components/schemas/iSwapAmountInRoute"
            },
            "type": "array"
          },
          "tokenIn": {
            "$ref": "#/components/schemas/iCosmosCoin"
          },
          "tokenOutMinAmount": {
            "$ref": "#/components/schemas/NumberType"
          },
          "ibcTransferInfo": {
            "$ref": "#/components/schemas/iIBCTransferInfo"
          },
          "affiliates": {
            "items": {
              "$ref": "#/components/schemas/iAffiliate"
            },
            "description": "affiliates are fee recipients that receive fees calculated from token_out_min_amount",
            "type": "array"
          }
        },
        "required": [
          "sender",
          "routes",
          "tokenIn",
          "tokenOutMinAmount",
          "ibcTransferInfo",
          "affiliates"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSwapExactAmountInWithIBCTransferResponse": {
        "properties": {
          "tokenOutAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "tokenOutAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSwapExactAmountOut": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "routes": {
            "items": {
              "$ref": "#/components/schemas/iSwapAmountOutRoute"
            },
            "type": "array"
          },
          "tokenInMaxAmount": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenOut": {
            "$ref": "#/components/schemas/iCosmosCoin"
          }
        },
        "required": [
          "sender",
          "routes",
          "tokenInMaxAmount",
          "tokenOut"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSwapExactAmountOutResponse": {
        "properties": {
          "tokenInAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "tokenInAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgJoinSwapExternAmountIn": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "poolId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenIn": {
            "$ref": "#/components/schemas/iCosmosCoin"
          },
          "shareOutMinAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "sender",
          "poolId",
          "tokenIn",
          "shareOutMinAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgJoinSwapExternAmountInResponse": {
        "properties": {
          "shareOutAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "shareOutAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgJoinSwapShareAmountOut": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "poolId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenInDenom": {
            "type": "string"
          },
          "shareOutAmount": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenInMaxAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "sender",
          "poolId",
          "tokenInDenom",
          "shareOutAmount",
          "tokenInMaxAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgJoinSwapShareAmountOutResponse": {
        "properties": {
          "tokenInAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "tokenInAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgExitSwapShareAmountIn": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "poolId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenOutDenom": {
            "type": "string"
          },
          "shareInAmount": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenOutMinAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "sender",
          "poolId",
          "tokenOutDenom",
          "shareInAmount",
          "tokenOutMinAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgExitSwapShareAmountInResponse": {
        "properties": {
          "tokenOutAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "tokenOutAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgExitSwapExternAmountOut": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "poolId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenOut": {
            "$ref": "#/components/schemas/iCosmosCoin"
          },
          "shareInMaxAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "sender",
          "poolId",
          "tokenOut",
          "shareInMaxAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgExitSwapExternAmountOutResponse": {
        "properties": {
          "shareInAmount": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "shareInAmount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgCreateBalancerPool": {
        "properties": {
          "sender": {
            "type": "string"
          },
          "poolParams": {
            "$ref": "#/components/schemas/iPoolParams"
          },
          "poolAssets": {
            "items": {
              "$ref": "#/components/schemas/iPoolAsset"
            },
            "type": "array"
          }
        },
        "required": [
          "sender",
          "poolParams",
          "poolAssets"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgCreateBalancerPoolResponse": {
        "properties": {
          "poolId": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "poolId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPoolParams": {
        "properties": {
          "swapFee": {
            "type": "string"
          },
          "exitFee": {
            "type": "string"
          }
        },
        "required": [
          "swapFee",
          "exitFee"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPoolAsset": {
        "properties": {
          "token": {
            "$ref": "#/components/schemas/iCosmosCoin"
          },
          "weight": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "token",
          "weight"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPool": {
        "properties": {
          "address": {
            "type": "string"
          },
          "id": {
            "$ref": "#/components/schemas/NumberType"
          },
          "poolParams": {
            "$ref": "#/components/schemas/iPoolParams"
          },
          "totalShares": {
            "$ref": "#/components/schemas/iCosmosCoin"
          },
          "poolAssets": {
            "items": {
              "$ref": "#/components/schemas/iPoolAsset"
            },
            "type": "array"
          },
          "totalWeight": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "address",
          "id",
          "poolParams",
          "totalShares",
          "poolAssets",
          "totalWeight"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "Doc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          }
        },
        "required": [
          "_docId"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "ErrorResponse": {
        "properties": {
          "error": {
            "description": "Serialized error object for debugging purposes. Technical users can use this to debug issues.",
            "type": "string"
          },
          "errorMessage": {
            "description": "UX-friendly error message that can be displayed to the user. Always present if error.",
            "type": "string"
          },
          "unauthorized": {
            "description": "Authentication error. Present if the user is not authenticated.",
            "type": "boolean"
          }
        },
        "required": [
          "errorMessage"
        ],
        "additionalProperties": false,
        "description": "If an error occurs, the response will be an ErrorResponse.\n\n400 - Bad Request (e.g. invalid request body)\n401 - Unauthorized\n500 - Internal Server Error",
        "type": "object"
      },
      "iBitBadgesApi": {
        "properties": {
          "apiUrl": {
            "type": "string"
          },
          "apiKey": {
            "type": "string"
          },
          "convertFunction": {},
          "appendedHeaders": {}
        },
        "required": [
          "convertFunction"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "PaginationInfo": {
        "properties": {
          "bookmark": {
            "description": "The bookmark for the next page of results. Obtained from previous response.",
            "type": "string"
          },
          "hasMore": {
            "description": "Whether there are more results to fetch.",
            "type": "boolean"
          }
        },
        "required": [
          "bookmark",
          "hasMore"
        ],
        "additionalProperties": false,
        "description": "Type for pagination information.",
        "type": "object"
      },
      "iGetConnectedAccountsSuccessResponse": {
        "properties": {
          "accounts": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "object": {
                  "type": "string"
                },
                "business_type": {
                  "type": "string"
                },
                "created": {
                  "type": "number"
                },
                "default_currency": {
                  "type": "string"
                },
                "email": {
                  "type": "string"
                },
                "type": {
                  "type": "string"
                },
                "payouts_enabled": {
                  "type": "boolean"
                },
                "display_name": {
                  "type": "string"
                }
              },
              "required": [
                "id",
                "object",
                "business_type",
                "created",
                "default_currency",
                "email",
                "type",
                "payouts_enabled",
                "display_name"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "accounts"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteConnectedAccountSuccessResponse": {
        "properties": {
          "deleted": {
            "type": "boolean"
          }
        },
        "required": [
          "deleted"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "ErrorDoc": {
        "properties": {
          "_docId": {
            "type": "string"
          },
          "_id": {
            "type": "string"
          },
          "error": {
            "type": "string"
          },
          "function": {
            "type": "string"
          }
        },
        "required": [
          "_docId",
          "error",
          "function"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "OAuthScopeDetails": {
        "properties": {
          "scopeName": {
            "description": "The name of the scope. Note: For this, we use the capitalized version of the scope name with spaces.\n\nFor example, \"completeClaims\" becomes \"Complete Claims\"",
            "type": "string"
          },
          "options": {
            "description": "The options for the scope. Currently, this is not used.",
            "type": "object"
          }
        },
        "required": [
          "scopeName"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "UNIXMilliTimestamp": {
        "description": "Numeric timestamp - value is equal to the milliseconds since the UNIX epoch.",
        "$ref": "#/components/schemas/NumberType",
        "examples": [
          "1713301889"
        ]
      },
      "BitBadgesAddress": {
        "description": "All supported addresses map to a Bech32 BitBadges address which is used by the BitBadges blockchain behind the scenes.\nFor conversion, see the BitBadges documentation. If this type is used, we must always convert to a BitBadges address before using it.",
        "type": "string",
        "examples": [
          "bb1..."
        ]
      },
      "SiwbbMessage": {
        "description": "SiwbbMessage is the sign-in challenge strint to be signed by the user. It extends EIP 4361 Sign-In with Ethereum\nand adds additional fields for cross-chain compatibility and native asset ownership verification.\n\nFor example, 'https://bitbadges.io wants you to sign in with your Ethereum address ...'",
        "type": "string",
        "examples": [
          "https://bitbadges.io wants you to sign in...."
        ]
      },
      "NativeAddress": {
        "description": "A native address is an address that is native to the user's chain.\nFor now, we only support Cosmos / BitBadges 'bb1...' addresses.",
        "type": "string",
        "examples": [
          "bb1..."
        ]
      },
      "iSocialConnections": {
        "properties": {
          "discord": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "discriminator": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "twitter": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "google": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "github": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "twitch": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "strava": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "reddit": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "meetup": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "bluesky": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "mailchimp": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "facebook": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "googleCalendar": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "youtube": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "linkedIn": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "shopify": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "telegram": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "farcaster": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "slack": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              },
              "lastUpdated": {
                "$ref": "#/components/schemas/UNIXMilliTimestamp"
              }
            },
            "required": [
              "username",
              "id",
              "lastUpdated"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "additionalProperties": false,
        "description": "Social connections are tracked for each user to provide an enhanced experience.\nThese are kept private from other users or sites using the API.\nCurrently, there is no use for these, but they may be used in the future.",
        "type": "object"
      },
      "iNotificationPreferences": {
        "properties": {
          "email": {
            "description": "The email to receive push notifications.",
            "type": "string"
          },
          "discord": {
            "properties": {
              "id": {
                "type": "string"
              },
              "username": {
                "type": "string"
              },
              "discriminator": {
                "type": "string"
              },
              "token": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "username",
              "discriminator",
              "token"
            ],
            "additionalProperties": false,
            "description": "The Discord ID to receive push notifications.",
            "type": "object"
          },
          "emailVerification": {
            "description": "The verification status of the email.",
            "$ref": "#/components/schemas/iEmailVerificationStatus"
          },
          "preferences": {
            "properties": {
              "transferActivity": {
                "type": "boolean"
              },
              "claimActivity": {
                "type": "boolean"
              },
              "ignoreIfInitiator": {
                "type": "boolean"
              },
              "signInAlertsEnabled": {
                "type": "boolean"
              }
            },
            "additionalProperties": false,
            "description": "The preferences for the notifications. What type of notifications does the user want to receive?",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "description": "Details about the user's push notification preferences.",
        "type": "object"
      },
      "iEmailVerificationStatus": {
        "properties": {
          "verified": {
            "description": "Whether or not the email has been verified.",
            "type": "boolean"
          },
          "verifiedAt": {
            "description": "Verified at timestamp.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "token": {
            "description": "The email verification token. This is used for verification and unsubscription.",
            "type": "string"
          },
          "expiry": {
            "description": "The expiry of the token for verification purposes.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "antiPhishingCode": {
            "description": "A unique code that we will send with all emails to verify that BitBadges is the one sending the email.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "description": "The verification status of the user's email.",
        "type": "object"
      },
      "iActivityDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "timestamp": {
            "description": "The timestamp of the activity.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "block": {
            "description": "The block number of the activity.",
            "$ref": "#/components/schemas/NumberType"
          },
          "_notificationsHandled": {
            "description": "Whether or not the notifications have been handled by the indexer or not.",
            "type": "boolean"
          },
          "private": {
            "description": "Only for private purposes?",
            "type": "boolean"
          }
        },
        "required": [
          "_docId",
          "timestamp",
          "block"
        ],
        "additionalProperties": false,
        "description": "The base document interface for all acitivity types.\nBondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iReviewDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "timestamp": {
            "description": "The timestamp of the activity.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "block": {
            "description": "The block number of the activity.",
            "$ref": "#/components/schemas/NumberType"
          },
          "_notificationsHandled": {
            "description": "Whether or not the notifications have been handled by the indexer or not.",
            "type": "boolean"
          },
          "private": {
            "description": "Only for private purposes?",
            "type": "boolean"
          },
          "review": {
            "description": "The review text (max 2048 characters).",
            "type": "string"
          },
          "stars": {
            "description": "The number of stars given (1-5).",
            "$ref": "#/components/schemas/NumberType"
          },
          "from": {
            "description": "The user who gave the review.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The collection ID of the collection that was reviewed. Only applicable to collection reviews.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "reviewedAddress": {
            "description": "The BitBadges address of the user who the review is for. Only applicable to user reviews.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "_docId",
          "timestamp",
          "block",
          "review",
          "stars",
          "from"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iCoinTransferItem": {
        "properties": {
          "from": {
            "description": "The type of the coin transfer.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "to": {
            "description": "The type of the coin transfer.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "amount": {
            "description": "The amount of the coin transfer.",
            "$ref": "#/components/schemas/NumberType"
          },
          "denom": {
            "description": "The denom of the coin transfer.",
            "type": "string"
          },
          "isProtocolFee": {
            "description": "Is protocol fee?",
            "type": "boolean"
          }
        },
        "required": [
          "from",
          "to",
          "amount",
          "denom",
          "isProtocolFee"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iTransferActivityDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "timestamp": {
            "description": "The timestamp of the activity.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "block": {
            "description": "The block number of the activity.",
            "$ref": "#/components/schemas/NumberType"
          },
          "_notificationsHandled": {
            "description": "Whether or not the notifications have been handled by the indexer or not.",
            "type": "boolean"
          },
          "private": {
            "description": "Only for private purposes?",
            "type": "boolean"
          },
          "to": {
            "items": {
              "$ref": "#/components/schemas/BitBadgesAddress"
            },
            "description": "The list of recipients.",
            "type": "array"
          },
          "from": {
            "description": "The sender of the tokens.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "balances": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "The list of balances and token IDs that were transferred.",
            "type": "array"
          },
          "collectionId": {
            "description": "The collection ID for the tokens that was transferred.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "memo": {
            "description": "The memo of the transfer.",
            "type": "string"
          },
          "precalculateBalancesFromApproval": {
            "description": "Which approval to use to precalculate the balances?",
            "$ref": "#/components/schemas/iPrecalculateBalancesFromApprovalDetails"
          },
          "prioritizedApprovals": {
            "items": {
              "$ref": "#/components/schemas/iApprovalIdentifierDetails"
            },
            "description": "The prioritized approvals of the transfer. This is used to check certain approvals before others to ensure intended behavior.",
            "type": "array"
          },
          "initiatedBy": {
            "description": "The user who initiated the transfer transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "txHash": {
            "description": "The transaction hash of the activity.",
            "type": "string",
            "examples": [
              "CE22D7..."
            ]
          },
          "precalculationOptions": {
            "description": "Precalculation options",
            "$ref": "#/components/schemas/iPrecalculationOptions"
          },
          "coinTransfers": {
            "items": {
              "$ref": "#/components/schemas/iCoinTransferItem"
            },
            "description": "Coin transfers details",
            "type": "array"
          },
          "approvalsUsed": {
            "items": {
              "$ref": "#/components/schemas/iApprovalIdentifierDetails"
            },
            "description": "Approvals used for the transfer",
            "type": "array"
          },
          "tokenId": {
            "description": "The token ID for the transfer",
            "$ref": "#/components/schemas/NumberType"
          },
          "price": {
            "description": "The price of the transfer",
            "$ref": "#/components/schemas/NumberType"
          },
          "volume": {
            "description": "The volume of the transfer",
            "$ref": "#/components/schemas/NumberType"
          },
          "denom": {
            "description": "The denomination of the transfer",
            "type": "string"
          }
        },
        "required": [
          "_docId",
          "timestamp",
          "block",
          "to",
          "from",
          "balances",
          "collectionId",
          "initiatedBy"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iClaimActivityDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "timestamp": {
            "description": "The timestamp of the activity.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "block": {
            "description": "The block number of the activity.",
            "$ref": "#/components/schemas/NumberType"
          },
          "_notificationsHandled": {
            "description": "Whether or not the notifications have been handled by the indexer or not.",
            "type": "boolean"
          },
          "private": {
            "description": "Only for private purposes?",
            "type": "boolean"
          },
          "success": {
            "description": "Whether the claim attempt was successful or not",
            "type": "boolean"
          },
          "claimId": {
            "description": "The claim ID of the claim attempt",
            "type": "string"
          },
          "claimAttemptId": {
            "description": "The claim attempt ID of the claim attempt",
            "type": "string"
          },
          "bitbadgesAddress": {
            "description": "The BitBadges address of the user who attempted the claim",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "claimType": {
            "enum": [
              "standalone",
              "collection",
              "list"
            ],
            "description": "The claim type of the claim attempt",
            "type": "string"
          }
        },
        "required": [
          "_docId",
          "timestamp",
          "block",
          "success",
          "claimId",
          "claimAttemptId",
          "bitbadgesAddress"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iPointsActivityDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "timestamp": {
            "description": "The timestamp of the activity.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "block": {
            "description": "The block number of the activity.",
            "$ref": "#/components/schemas/NumberType"
          },
          "_notificationsHandled": {
            "description": "Whether or not the notifications have been handled by the indexer or not.",
            "type": "boolean"
          },
          "private": {
            "description": "Only for private purposes?",
            "type": "boolean"
          },
          "bitbadgesAddress": {
            "description": "The BitBadges address of the user who earned the points",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "oldPoints": {
            "description": "The amount of points before the activity",
            "$ref": "#/components/schemas/NumberType"
          },
          "newPoints": {
            "description": "The amount of points after the activity",
            "$ref": "#/components/schemas/NumberType"
          },
          "applicationId": {
            "description": "The application ID of the points activity",
            "type": "string"
          },
          "pageId": {
            "description": "The page ID of the points activity",
            "type": "string"
          }
        },
        "required": [
          "_docId",
          "timestamp",
          "block",
          "bitbadgesAddress",
          "oldPoints",
          "newPoints",
          "applicationId",
          "pageId"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iBaseStats": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "overallVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The overall volume of the collection",
            "type": "array"
          },
          "dailyVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The daily volume of the collection",
            "type": "array"
          },
          "weeklyVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The weekly volume of the collection",
            "type": "array"
          },
          "monthlyVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The monthly volume of the collection",
            "type": "array"
          },
          "yearlyVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The yearly volume of the collection",
            "type": "array"
          },
          "lastUpdatedAt": {
            "description": "Last set timestamp",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "_docId",
          "overallVolume",
          "dailyVolume",
          "weeklyVolume",
          "monthlyVolume",
          "yearlyVolume",
          "lastUpdatedAt"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iCollectionStatsDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "overallVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The overall volume of the collection",
            "type": "array"
          },
          "dailyVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The daily volume of the collection",
            "type": "array"
          },
          "weeklyVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The weekly volume of the collection",
            "type": "array"
          },
          "monthlyVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The monthly volume of the collection",
            "type": "array"
          },
          "yearlyVolume": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The yearly volume of the collection",
            "type": "array"
          },
          "lastUpdatedAt": {
            "description": "Last set timestamp",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "floorPrices": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "Floor price of the collection",
            "type": "array"
          },
          "uniqueOwners": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "Number of unique owners by time",
            "type": "array"
          },
          "floorPriceHistory": {
            "items": {
              "$ref": "#/components/schemas/iFloorPriceHistory"
            },
            "description": "Floor price history",
            "type": "array"
          },
          "payoutRewards": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The payout reward",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "overallVolume",
          "dailyVolume",
          "weeklyVolume",
          "monthlyVolume",
          "yearlyVolume",
          "lastUpdatedAt",
          "collectionId",
          "uniqueOwners"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iFloorPriceHistory": {
        "properties": {
          "floorPrice": {
            "description": "The floor price",
            "$ref": "#/components/schemas/iCosmosCoin"
          },
          "updatedAt": {
            "description": "Updated at tiemstamp",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "updatedAt"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iTokenFloorPriceDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "tokenId": {
            "description": "The token ID",
            "$ref": "#/components/schemas/NumberType"
          },
          "floorPrices": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The floor price",
            "type": "array"
          },
          "floorPriceHistory": {
            "items": {
              "$ref": "#/components/schemas/iFloorPriceHistory"
            },
            "description": "Floor price history",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "collectionId",
          "tokenId"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iApprovalItemDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "approvalId": {
            "description": "The approval ID",
            "type": "string"
          },
          "approvalLevel": {
            "enum": [
              "incoming",
              "outgoing"
            ],
            "description": "The approval level",
            "type": "string",
            "examples": [
              "collection",
              "incoming",
              "outgoing"
            ]
          },
          "approverAddress": {
            "description": "The approver address",
            "type": "string"
          },
          "approvalType": {
            "description": "The approval type",
            "type": "string"
          },
          "used": {
            "description": "Explicitly marked as used or expired",
            "type": "boolean"
          },
          "sufficientBalances": {
            "description": "Owner has sufficient balances",
            "type": "boolean"
          },
          "price": {
            "description": "The price of the listing",
            "$ref": "#/components/schemas/NumberType"
          },
          "isActive": {
            "description": "Is active currently",
            "type": "boolean"
          },
          "tokenId": {
            "description": "The token ID",
            "$ref": "#/components/schemas/NumberType"
          },
          "approval": {
            "description": "Approval itself",
            "$ref": "#/components/schemas/iCollectionApproval"
          },
          "deletedAt": {
            "description": "Deleted at timestamp",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "nextCheckTime": {
            "description": "Next check time",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "numTransfersLeft": {
            "description": "Number of transfers left",
            "$ref": "#/components/schemas/NumberType"
          },
          "denom": {
            "description": "Denom",
            "type": "string"
          }
        },
        "required": [
          "_docId",
          "collectionId",
          "approvalId",
          "approvalLevel",
          "approverAddress",
          "approvalType",
          "approval"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iCollectionDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "collectionMetadata": {
            "description": "The collection metadata",
            "$ref": "#/components/schemas/iCollectionMetadata"
          },
          "tokenMetadata": {
            "items": {
              "$ref": "#/components/schemas/iTokenMetadata"
            },
            "description": "The token metadata",
            "type": "array"
          },
          "customData": {
            "description": "The custom data",
            "type": "string"
          },
          "manager": {
            "description": "The manager",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionApprovals": {
            "items": {
              "$ref": "#/components/schemas/iCollectionApproval"
            },
            "description": "The collection approved transfers timeline",
            "type": "array"
          },
          "standards": {
            "items": {
              "type": "string"
            },
            "description": "The standards",
            "type": "array"
          },
          "isArchived": {
            "description": "The is archived flag",
            "type": "boolean"
          },
          "createdBy": {
            "description": "The BitBadges address of the user who created this collection",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "createdBlock": {
            "description": "The block number when this collection was created",
            "$ref": "#/components/schemas/NumberType"
          },
          "createdTimestamp": {
            "description": "The timestamp when this collection was created (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "updateHistory": {
            "items": {
              "$ref": "#/components/schemas/iUpdateHistory"
            },
            "description": "The update history of this collection",
            "type": "array"
          },
          "validTokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "Valid token IDs for the collection",
            "type": "array"
          },
          "mintEscrowAddress": {
            "description": "Mint escrow address",
            "type": "string"
          },
          "cosmosCoinWrapperPaths": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoinWrapperPath"
            },
            "description": "The IBC wrapper paths for the collection",
            "type": "array"
          },
          "aliasPaths": {
            "items": {
              "$ref": "#/components/schemas/iAliasPath"
            },
            "description": "The alias (non-wrapping) paths for the collection",
            "type": "array"
          },
          "invariants": {
            "description": "Collection-level invariants that cannot be broken. These are set upon genesis and cannot be modified.",
            "$ref": "#/components/schemas/iCollectionInvariants"
          }
        },
        "required": [
          "_docId",
          "collectionId",
          "collectionMetadata",
          "tokenMetadata",
          "customData",
          "manager",
          "collectionApprovals",
          "standards",
          "isArchived",
          "createdBy",
          "createdBlock",
          "createdTimestamp",
          "updateHistory",
          "validTokenIds",
          "mintEscrowAddress",
          "cosmosCoinWrapperPaths",
          "aliasPaths",
          "invariants"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iCosmosCoinWrapperPath": {
        "properties": {
          "address": {
            "type": "string"
          },
          "denom": {
            "type": "string"
          },
          "conversion": {
            "$ref": "#/components/schemas/iConversionWithoutDenom"
          },
          "symbol": {
            "type": "string"
          },
          "denomUnits": {
            "items": {
              "$ref": "#/components/schemas/iDenomUnit"
            },
            "type": "array"
          },
          "allowOverrideWithAnyValidToken": {
            "type": "boolean"
          },
          "metadata": {
            "description": "The metadata for this wrapper path.",
            "$ref": "#/components/schemas/iPathMetadata"
          }
        },
        "required": [
          "address",
          "denom",
          "conversion",
          "symbol",
          "denomUnits",
          "allowOverrideWithAnyValidToken",
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPoolInfo": {
        "properties": {
          "poolId": {
            "type": "string"
          },
          "address": {
            "type": "string"
          },
          "allAssetDenoms": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "poolParams": {
            "properties": {
              "swapFee": {
                "type": "string"
              },
              "exitFee": {
                "type": "string"
              }
            },
            "required": [
              "swapFee",
              "exitFee"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "volume": {
            "$ref": "#/components/schemas/iPoolInfoVolume"
          },
          "lastVolumeUpdate": {
            "type": "number"
          },
          "liquidity": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "lastLiquidityUpdate": {
            "type": "number"
          }
        },
        "required": [
          "poolId",
          "address",
          "allAssetDenoms",
          "volume",
          "lastVolumeUpdate",
          "liquidity",
          "lastLiquidityUpdate"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAssetInfoDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "asset": {
            "type": "string"
          },
          "symbol": {
            "type": "string"
          },
          "price": {
            "type": "number"
          },
          "lastUpdated": {
            "$ref": "#/components/schemas/NumberType"
          },
          "totalLiquidity": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "volume24h": {
            "type": "number"
          },
          "volume7d": {
            "type": "number"
          },
          "percentageChange24h": {
            "type": "number"
          },
          "percentageChange7d": {
            "type": "number"
          },
          "recentPriceTrend": {
            "properties": {
              "pricePoints": {
                "items": {
                  "properties": {
                    "price": {
                      "type": "number"
                    },
                    "timestamp": {
                      "$ref": "#/components/schemas/NumberType"
                    }
                  },
                  "required": [
                    "price",
                    "timestamp"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "description": "Array of price data points with timestamps",
                "type": "array"
              }
            },
            "required": [
              "pricePoints"
            ],
            "additionalProperties": false,
            "description": "Recent price trend data points for charting (last 7 days)",
            "type": "object"
          },
          "verified": {
            "description": "Whether this asset is verified",
            "type": "boolean"
          },
          "calculationType": {
            "description": "Calculation type for the asset",
            "type": "string"
          }
        },
        "required": [
          "_docId",
          "asset",
          "symbol",
          "price",
          "lastUpdated",
          "totalLiquidity",
          "volume24h",
          "volume7d",
          "percentageChange24h",
          "percentageChange7d"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iAliasPath": {
        "properties": {
          "denom": {
            "type": "string"
          },
          "conversion": {
            "$ref": "#/components/schemas/iConversionWithoutDenom"
          },
          "symbol": {
            "type": "string"
          },
          "denomUnits": {
            "items": {
              "$ref": "#/components/schemas/iDenomUnit"
            },
            "type": "array"
          },
          "metadata": {
            "description": "The metadata for this alias path.",
            "$ref": "#/components/schemas/iPathMetadata"
          }
        },
        "required": [
          "denom",
          "conversion",
          "symbol",
          "denomUnits",
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPoolInfoVolume": {
        "properties": {
          "daily": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "weekly": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "monthly": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          },
          "allTime": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "type": "array"
          }
        },
        "required": [
          "daily",
          "weekly",
          "monthly",
          "allTime"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAccountDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "publicKey": {
            "description": "The public key of the account",
            "type": "string",
            "examples": [
              "AksB.... (base64)"
            ]
          },
          "accountNumber": {
            "description": "The account number of the account. This is the account number registered on the BitBadges blockchain.",
            "$ref": "#/components/schemas/NumberType"
          },
          "pubKeyType": {
            "description": "The public key type of the account",
            "type": "string"
          },
          "bitbadgesAddress": {
            "description": "The BitBadges address of the account",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "sequence": {
            "description": "The sequence of the account. This is the nonce for the blockchain for this account",
            "$ref": "#/components/schemas/NumberType"
          },
          "balances": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The BADGE balance of the account and other sdk.coin balances",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "publicKey",
          "accountNumber",
          "pubKeyType",
          "bitbadgesAddress"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iCustomPage": {
        "properties": {
          "title": {
            "description": "The title of the custom page",
            "type": "string"
          },
          "description": {
            "description": "The description of the custom page",
            "type": "string",
            "examples": [
              "Brief description."
            ]
          },
          "items": {
            "items": {
              "$ref": "#/components/schemas/iBatchTokenDetails"
            },
            "description": "The token IDs to display on the custom page",
            "type": "array"
          }
        },
        "required": [
          "title",
          "description",
          "items"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iProfileDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "fetchedProfile": {
            "enum": [
              "full",
              "partial"
            ],
            "description": "Whether we have already fetched the profile or not",
            "type": "string"
          },
          "seenActivity": {
            "description": "The timestamp of the last activity seen for this account (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "createdAt": {
            "description": "The timestamp of when this account was created (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "discord": {
            "description": "The Discord username of the account",
            "type": "string"
          },
          "twitter": {
            "description": "The Twitter username of the account",
            "type": "string"
          },
          "github": {
            "description": "The GitHub username of the account",
            "type": "string"
          },
          "telegram": {
            "description": "The Telegram username of the account",
            "type": "string"
          },
          "readme": {
            "description": "The readme of the account",
            "type": "string"
          },
          "affiliateCode": {
            "description": "Affiliate code",
            "type": "string"
          },
          "hiddenTokens": {
            "items": {
              "$ref": "#/components/schemas/iBatchTokenDetails"
            },
            "description": "The hidden badges of the account",
            "type": "array"
          },
          "profilePicUrl": {
            "description": "The profile picture URL of the account",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "bannerImage": {
            "description": "The banner image URL of the account",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "username": {
            "description": "The username of the account",
            "type": "string"
          },
          "latestSignedInChain": {
            "description": "The latest chain the user signed in with",
            "$ref": "#/components/schemas/SupportedChain"
          },
          "notifications": {
            "description": "The notifications of the account",
            "$ref": "#/components/schemas/iNotificationPreferences"
          },
          "socialConnections": {
            "description": "Social connections stored for the account",
            "$ref": "#/components/schemas/iSocialConnections"
          },
          "publicSocialConnections": {
            "description": "Public social connections stored for the account",
            "$ref": "#/components/schemas/iSocialConnections"
          }
        },
        "required": [
          "_docId"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iQueueDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "uri": {
            "description": "The URI of the metadata to be fetched. If {id} is present, it will be replaced with each individual ID in tokenIds",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "collectionId": {
            "description": "The collection ID of the metadata to be fetched",
            "$ref": "#/components/schemas/CollectionId"
          },
          "loadBalanceId": {
            "description": "The load balance ID of the metadata to be fetched. Only the node with the same load balance ID will fetch this metadata",
            "$ref": "#/components/schemas/NumberType"
          },
          "refreshRequestTime": {
            "description": "The timestamp of when this metadata was requested to be refreshed (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "numRetries": {
            "description": "The number of times this metadata has been tried to be fetched but failed",
            "$ref": "#/components/schemas/NumberType"
          },
          "lastFetchedAt": {
            "description": "The timestamp of when this metadata was last fetched (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "error": {
            "description": "The error message if this metadata failed to be fetched",
            "type": "string"
          },
          "deletedAt": {
            "description": "The timestamp of when this document was deleted (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "nextFetchTime": {
            "description": "The timestamp of when this document should be fetched next (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "pending": {
            "description": "Whether this document is pending to be fetched or not",
            "type": "boolean"
          },
          "emailMessage": {
            "type": "string"
          },
          "recipientAddress": {
            "type": "string"
          },
          "activityDocId": {
            "type": "string"
          },
          "notificationType": {
            "description": "Type of the doc / purpose",
            "type": "string"
          },
          "initiatedBy": {
            "description": "The BitBadges address of the user who initiated this fetch",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "actionConfig": {
            "description": "For use for post-claim actions"
          },
          "claimInfo": {
            "properties": {
              "session": {},
              "body": {},
              "claimId": {
                "type": "string"
              },
              "bitbadgesAddress": {
                "$ref": "#/components/schemas/BitBadgesAddress",
                "examples": [
                  "bb1..."
                ]
              },
              "ip": {
                "type": "string"
              }
            },
            "required": [
              "session",
              "body",
              "claimId",
              "bitbadgesAddress",
              "ip"
            ],
            "additionalProperties": {},
            "description": "For use for claim completion",
            "type": "object"
          },
          "faucetInfo": {
            "properties": {
              "txHash": {
                "type": "string",
                "examples": [
                  "CE22D7..."
                ]
              },
              "amount": {
                "$ref": "#/components/schemas/NumberType"
              },
              "recipient": {
                "$ref": "#/components/schemas/BitBadgesAddress"
              },
              "denom": {
                "type": "string"
              }
            },
            "required": [
              "txHash",
              "amount",
              "recipient",
              "denom"
            ],
            "additionalProperties": false,
            "description": "For use for airdrops",
            "type": "object"
          }
        },
        "required": [
          "_docId",
          "uri",
          "collectionId",
          "loadBalanceId",
          "refreshRequestTime",
          "numRetries"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iIndexerStatus": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/iStatusDoc"
          }
        },
        "required": [
          "status"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iTransactionEntry": {
        "properties": {
          "amount": {
            "description": "The amount of the transaction",
            "$ref": "#/components/schemas/NumberType"
          },
          "limit": {
            "description": "The gas limit of the transaction",
            "$ref": "#/components/schemas/NumberType"
          },
          "timestamp": {
            "description": "The timestamp when the transaction occurred (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "amount",
          "limit",
          "timestamp"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iLatestBlockStatus": {
        "properties": {
          "height": {
            "description": "The height of the latest block",
            "$ref": "#/components/schemas/NumberType"
          },
          "txIndex": {
            "description": "The transaction index of the latest block",
            "$ref": "#/components/schemas/NumberType"
          },
          "timestamp": {
            "description": "The timestamp of the latest block (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "height",
          "txIndex",
          "timestamp"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iStatusDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "block": {
            "description": "The latest synced block status (i.e. height, txIndex, timestamp)",
            "$ref": "#/components/schemas/iLatestBlockStatus"
          },
          "nextCollectionId": {
            "description": "The next collection ID to be used",
            "$ref": "#/components/schemas/NumberType"
          },
          "gasPrice": {
            "description": "The current gas price based on the average of recent transactions",
            "type": "number"
          },
          "lastXTxs": {
            "items": {
              "$ref": "#/components/schemas/iTransactionEntry"
            },
            "description": "The last X transactions with timestamps for dynamic reset functionality",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "block",
          "nextCollectionId",
          "gasPrice"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iAddressListDoc": {
        "properties": {
          "listId": {
            "description": "The ID of the address list.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "addresses": {
            "items": {
              "type": "string"
            },
            "description": "The addresses of the address list. If this is a tracker list, the addresses are the tracker IDs.",
            "type": "array"
          },
          "whitelist": {
            "description": "Whether or not to include ONLY the addresses or include all EXCEPT the addresses.",
            "type": "boolean"
          },
          "uri": {
            "description": "The URI where to fetch the address list metadata from.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Arbitrary custom data that can be stored. Leave blank for no custom data.",
            "type": "string"
          },
          "createdBy": {
            "description": "The address that created the address list. Handled internally.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "managedBy": {
            "description": "The BitBadges address of the user who is currently managing this",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "updateHistory": {
            "items": {
              "$ref": "#/components/schemas/iUpdateHistory"
            },
            "description": "The update history of this list",
            "type": "array"
          },
          "createdBlock": {
            "description": "The block number when this list was created",
            "$ref": "#/components/schemas/NumberType"
          },
          "lastUpdated": {
            "description": "The timestamp of when this list was last updated (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "nsfw": {
            "properties": {
              "reason": {
                "type": "string"
              }
            },
            "required": [
              "reason"
            ],
            "additionalProperties": false,
            "description": "The NSFW reason if this list is NSFW",
            "type": "object"
          },
          "reported": {
            "properties": {
              "reason": {
                "type": "string"
              }
            },
            "required": [
              "reason"
            ],
            "additionalProperties": false,
            "description": "The reported reason if this list is reported",
            "type": "object"
          }
        },
        "required": [
          "listId",
          "addresses",
          "whitelist",
          "uri",
          "customData",
          "_docId",
          "managedBy",
          "updateHistory",
          "createdBlock",
          "lastUpdated"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iBalanceDoc": {
        "properties": {
          "balances": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "The user's balances.",
            "type": "array"
          },
          "incomingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserIncomingApproval"
            },
            "description": "The user's incoming approvals.",
            "type": "array"
          },
          "outgoingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserOutgoingApproval"
            },
            "description": "The user's outgoing approvals.",
            "type": "array"
          },
          "userPermissions": {
            "description": "The user's permissions.",
            "$ref": "#/components/schemas/iUserPermissions"
          },
          "autoApproveSelfInitiatedOutgoingTransfers": {
            "description": "Whether the user's self-initiated outgoing transfers are auto-approved. If not, they must be explicitly approved using the outgoing approvals.",
            "type": "boolean"
          },
          "autoApproveSelfInitiatedIncomingTransfers": {
            "description": "Whether the user's self-initiated incoming transfers are auto-approved. If not, they must be explicitly approved using the incoming approvals.",
            "type": "boolean"
          },
          "autoApproveAllIncomingTransfers": {
            "description": "Whether the user's all incoming transfers are auto-approved. If not, they must be explicitly approved using the incoming approvals.",
            "type": "boolean"
          },
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "bitbadgesAddress": {
            "description": "The BitBadges address of the user",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "updateHistory": {
            "items": {
              "$ref": "#/components/schemas/iUpdateHistory"
            },
            "description": "The update history of this balance",
            "type": "array"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "description": "Optional tags for this balance",
            "type": "array"
          }
        },
        "required": [
          "balances",
          "incomingApprovals",
          "outgoingApprovals",
          "userPermissions",
          "autoApproveSelfInitiatedOutgoingTransfers",
          "autoApproveSelfInitiatedIncomingTransfers",
          "autoApproveAllIncomingTransfers",
          "_docId",
          "collectionId",
          "bitbadgesAddress",
          "updateHistory"
        ],
        "additionalProperties": false,
        "description": "\nThis stores everythign about a user's balances for a specific collection ID.\nThis includes their balances, incoming approvals, outgoing approvals, and permissions.\n\nBondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iPointsDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "address": {
            "description": "The address to calculate points for",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "points": {
            "description": "The points for the address",
            "$ref": "#/components/schemas/NumberType"
          },
          "lastCalculatedAt": {
            "description": "The timestamp of when the points were last calculated (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "applicationId": {
            "description": "The application ID",
            "type": "string"
          },
          "pageId": {
            "description": "The page ID",
            "type": "string"
          },
          "claimSuccessCounts": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "Claim success counts. These were the claim success counts calculated for this points calculation.",
            "type": "object"
          }
        },
        "required": [
          "_docId",
          "address",
          "points",
          "lastCalculatedAt",
          "applicationId",
          "pageId"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "ClaimIntegrationPluginType": {
        "type": "string"
      },
      "JsonBodyInputWithValue": {
        "properties": {
          "key": {
            "type": "string"
          },
          "label": {
            "type": "string"
          },
          "type": {
            "type": "string"
          },
          "value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "headerField": {
            "type": "boolean"
          }
        },
        "required": [
          "key",
          "label",
          "type",
          "value"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "JsonBodyInputSchema": {
        "properties": {
          "key": {
            "type": "string"
          },
          "label": {
            "type": "string"
          },
          "type": {
            "type": "string"
          },
          "hyperlink": {
            "properties": {
              "url": {
                "type": "string"
              },
              "showAsGenericView": {
                "type": "boolean"
              }
            },
            "required": [
              "url"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "helper": {
            "type": "string"
          },
          "headerField": {
            "type": "boolean"
          },
          "required": {
            "type": "boolean"
          },
          "hideFromDetailsDisplay": {
            "description": "Note only applicable for public parameters input schemas",
            "type": "boolean"
          },
          "defaultValue": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "options": {
            "items": {
              "properties": {
                "label": {
                  "type": "string"
                },
                "value": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    }
                  ]
                }
              },
              "required": [
                "label",
                "value"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "arrayField": {
            "type": "boolean"
          }
        },
        "required": [
          "key",
          "label",
          "type"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "any": null,
      "IntegrationPluginParams": {
        "properties": {
          "instanceId": {
            "description": "The ID of the plugin instance. This is a unique identifier for referencing this instance of the plugin within this claim\n(e.g. differentiate between duplicates of the same plugin type).\n\nThis is different from the pluginId, which is a unique identifier for the plugin itself. All instances of the same plugin\nwill have the same pluginId.",
            "type": "string"
          },
          "pluginId": {
            "description": "The ID of the plugin (e.g. \"numUses\"). This is the reusable plugin ID.\nDo not use this as a unique identifier for the plugin instance as there could be duplicate pluginIds. Use instanceId instead.",
            "$ref": "#/components/schemas/NumberType"
          },
          "version": {
            "description": "The version of the plugin",
            "type": "string"
          },
          "publicParams": {
            "description": "The parameters of the plugin that are visible to the public. These are custom per plugin type."
          },
          "privateParams": {
            "description": "The parameters of the plugin that are not visible to the public. These are custom per plugin type."
          },
          "metadata": {
            "properties": {
              "name": {
                "type": "string",
                "examples": [
                  "Name"
                ]
              },
              "description": {
                "type": "string",
                "examples": [
                  "Brief description."
                ]
              },
              "image": {
                "type": "string",
                "examples": [
                  "https://example.com/image.png",
                  "ipfs://Qm..."
                ]
              }
            },
            "required": [
              "name",
              "description"
            ],
            "additionalProperties": false,
            "description": "Custom display metadata for the plugin. This will override the default metadata for the plugin.",
            "type": "object"
          }
        },
        "required": [
          "instanceId",
          "pluginId",
          "version",
          "publicParams",
          "privateParams"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "IntegrationPluginDetails": {
        "properties": {
          "instanceId": {
            "description": "The ID of the plugin instance. This is a unique identifier for referencing this instance of the plugin within this claim\n(e.g. differentiate between duplicates of the same plugin type).\n\nThis is different from the pluginId, which is a unique identifier for the plugin itself. All instances of the same plugin\nwill have the same pluginId.",
            "type": "string"
          },
          "pluginId": {
            "description": "The ID of the plugin (e.g. \"numUses\"). This is the reusable plugin ID.\nDo not use this as a unique identifier for the plugin instance as there could be duplicate pluginIds. Use instanceId instead.",
            "$ref": "#/components/schemas/NumberType"
          },
          "version": {
            "description": "The version of the plugin",
            "type": "string"
          },
          "publicParams": {
            "description": "The parameters of the plugin that are visible to the public. These are custom per plugin type."
          },
          "privateParams": {
            "description": "The parameters of the plugin that are not visible to the public. These are custom per plugin type."
          },
          "metadata": {
            "properties": {
              "name": {
                "type": "string",
                "examples": [
                  "Name"
                ]
              },
              "description": {
                "type": "string",
                "examples": [
                  "Brief description."
                ]
              },
              "image": {
                "type": "string",
                "examples": [
                  "https://example.com/image.png",
                  "ipfs://Qm..."
                ]
              }
            },
            "required": [
              "name",
              "description"
            ],
            "additionalProperties": false,
            "description": "Custom display metadata for the plugin. This will override the default metadata for the plugin.",
            "type": "object"
          },
          "publicState": {
            "description": "The current state of the plugin. This is returned by BitBadges for information purposes. This is altered to not reveal sensitive information."
          },
          "privateState": {
            "description": "The private state of the plugin. This is the exact state used by BitBadges behind the scenes."
          }
        },
        "required": [
          "instanceId",
          "pluginId",
          "version",
          "publicParams",
          "privateParams",
          "publicState"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "IntegrationPluginDetailsUpdate": {
        "properties": {
          "instanceId": {
            "description": "The ID of the plugin instance. This is a unique identifier for referencing this instance of the plugin within this claim\n(e.g. differentiate between duplicates of the same plugin type).\n\nThis is different from the pluginId, which is a unique identifier for the plugin itself. All instances of the same plugin\nwill have the same pluginId.",
            "type": "string"
          },
          "pluginId": {
            "description": "The ID of the plugin (e.g. \"numUses\"). This is the reusable plugin ID.\nDo not use this as a unique identifier for the plugin instance as there could be duplicate pluginIds. Use instanceId instead.",
            "$ref": "#/components/schemas/NumberType"
          },
          "version": {
            "description": "The version of the plugin",
            "type": "string"
          },
          "publicParams": {
            "description": "The parameters of the plugin that are visible to the public. These are custom per plugin type."
          },
          "privateParams": {
            "description": "The parameters of the plugin that are not visible to the public. These are custom per plugin type."
          },
          "metadata": {
            "properties": {
              "name": {
                "type": "string",
                "examples": [
                  "Name"
                ]
              },
              "description": {
                "type": "string",
                "examples": [
                  "Brief description."
                ]
              },
              "image": {
                "type": "string",
                "examples": [
                  "https://example.com/image.png",
                  "ipfs://Qm..."
                ]
              }
            },
            "required": [
              "name",
              "description"
            ],
            "additionalProperties": false,
            "description": "Custom display metadata for the plugin. This will override the default metadata for the plugin.",
            "type": "object"
          },
          "resetState": {
            "description": "If resetState = true, we will reset the state of the plugin back to default. If false, we will keep the current state. Incompatible with newState.",
            "type": "boolean"
          },
          "newState": {
            "description": "If newState is present, we will set the state to the new state. Incompatible with resetState. Can be used alongside onlyUpdateProvidedNewState.\nBy default, we will overwrite the whole state. If onlyUpdateProvidedNewState is true, we will only update the specific provided fields.\n\nWarning: This is an advanced feature and should be used with caution. Misconfiguring this can lead to unexpected behavior of this plugin.\n\nNote: Each plugin may have different state schemas. Please refer to the documentation of the plugin you are updating for more information."
          },
          "onlyUpdateProvidedNewState": {
            "description": "If true, we will only update the specific fields provided in newState. If falsy, we will overwrite the whole state with newState.\n\nOnly applicable if newState is present.\n\nNote that we do this on a recursive level. If you have nested objects, we will only update the specific fields provided for those nested objects\nand leave all else as-is.",
            "type": "boolean"
          }
        },
        "required": [
          "instanceId",
          "pluginId",
          "version",
          "publicParams",
          "privateParams"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "ManagePluginRequest": {
        "$ref": "#/components/schemas/IntegrationPluginDetailsUpdate"
      },
      "CreateClaimRequest": {
        "properties": {
          "claimId": {
            "description": "Unique claim ID.",
            "type": "string"
          },
          "collectionId": {
            "description": "Collection ID that the claim is for (if applicable - collection claims).",
            "$ref": "#/components/schemas/CollectionId"
          },
          "rewards": {
            "items": {
              "$ref": "#/components/schemas/iClaimReward"
            },
            "description": "Rewards for the claim.",
            "type": "array"
          },
          "estimatedCost": {
            "description": "Estimated cost for the claim.",
            "type": "string"
          },
          "showInSearchResults": {
            "description": "If true, the claim will be shown in search results",
            "type": "boolean"
          },
          "categories": {
            "items": {
              "type": "string"
            },
            "description": "The categories of the claim",
            "type": "array"
          },
          "estimatedTime": {
            "description": "Estimated time to satisfy the claim's requirements.",
            "type": "string"
          },
          "manualDistribution": {
            "description": "If manual distribution is enabled, we do not handle any distribution of claim codes.\nWe leave that up to the claim creator.\n\nOnly applicable for on-chain token claims. This is only used in advanced self-hosted cases.",
            "type": "boolean"
          },
          "approach": {
            "description": "How the claim is expected to be completed. This is for display purposes for the frontend.\n\nAvailable options:\n- in-site (default): The claim is expected to be completed in-site.\n- api: The claim is expected to be completed via an API call.\n- zapier: The claim is expected to be completed via Zapier auto-completion.\n\nTypically, you will use the in-site approach",
            "type": "string"
          },
          "seedCode": {
            "description": "Seed code for the claim. Only used for on-chain token claims.\n\nThis is how we produce all reserved codes for the on-chain merkle challenge / proofs.",
            "type": "string"
          },
          "metadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/iMetadata",
                "description": "Metadata for the claim."
              },
              {
                "$ref": "#/components/schemas/iMetadataWithoutInternals"
              }
            ]
          },
          "assignMethod": {
            "description": "Algorithm to determine the claim number order. Blank is just incrementing claim numbers.\n\nFor most cases, you will not need to specify this.",
            "type": "string"
          },
          "satisfyMethod": {
            "description": "Custom satisfaction logic.\n\nIf left blank, all plugins must pass for the claim to be satisfied.\nOtherwise, you can specify a custom method to determine if the claim is satisfied.",
            "$ref": "#/components/schemas/iSatisfyMethod"
          },
          "cachePolicy": {
            "description": "Cache policy for the claim. Only needed for on-demand claims.",
            "$ref": "#/components/schemas/iClaimCachePolicy"
          },
          "cid": {
            "type": "string"
          },
          "plugins": {
            "items": {
              "$ref": "#/components/schemas/ManagePluginRequest"
            },
            "type": "array"
          }
        },
        "required": [
          "claimId",
          "plugins"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "UpdateClaimRequest": {
        "properties": {
          "claimId": {
            "description": "Unique claim ID.",
            "type": "string"
          },
          "collectionId": {
            "description": "Collection ID that the claim is for (if applicable - collection claims).",
            "$ref": "#/components/schemas/CollectionId"
          },
          "rewards": {
            "items": {
              "$ref": "#/components/schemas/iClaimReward"
            },
            "description": "Rewards for the claim.",
            "type": "array"
          },
          "estimatedCost": {
            "description": "Estimated cost for the claim.",
            "type": "string"
          },
          "showInSearchResults": {
            "description": "If true, the claim will be shown in search results",
            "type": "boolean"
          },
          "categories": {
            "items": {
              "type": "string"
            },
            "description": "The categories of the claim",
            "type": "array"
          },
          "estimatedTime": {
            "description": "Estimated time to satisfy the claim's requirements.",
            "type": "string"
          },
          "manualDistribution": {
            "description": "If manual distribution is enabled, we do not handle any distribution of claim codes.\nWe leave that up to the claim creator.\n\nOnly applicable for on-chain token claims. This is only used in advanced self-hosted cases.",
            "type": "boolean"
          },
          "approach": {
            "description": "How the claim is expected to be completed. This is for display purposes for the frontend.\n\nAvailable options:\n- in-site (default): The claim is expected to be completed in-site.\n- api: The claim is expected to be completed via an API call.\n- zapier: The claim is expected to be completed via Zapier auto-completion.\n\nTypically, you will use the in-site approach",
            "type": "string"
          },
          "metadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/iMetadata",
                "description": "Metadata for the claim."
              },
              {
                "$ref": "#/components/schemas/iMetadataWithoutInternals"
              }
            ]
          },
          "assignMethod": {
            "description": "Algorithm to determine the claim number order. Blank is just incrementing claim numbers.\n\nFor most cases, you will not need to specify this.",
            "type": "string"
          },
          "satisfyMethod": {
            "description": "Custom satisfaction logic.\n\nIf left blank, all plugins must pass for the claim to be satisfied.\nOtherwise, you can specify a custom method to determine if the claim is satisfied.",
            "$ref": "#/components/schemas/iSatisfyMethod"
          },
          "cachePolicy": {
            "description": "Cache policy for the claim. Only needed for on-demand claims.",
            "$ref": "#/components/schemas/iClaimCachePolicy"
          },
          "cid": {
            "type": "string"
          },
          "plugins": {
            "items": {
              "$ref": "#/components/schemas/ManagePluginRequest"
            },
            "type": "array"
          }
        },
        "required": [
          "claimId",
          "plugins"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSatisfyMethod": {
        "properties": {
          "type": {
            "enum": [
              "AND",
              "OR",
              "NOT"
            ],
            "type": "string"
          },
          "conditions": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/iSatisfyMethod"
                }
              ]
            },
            "description": "Conditions can either be the instance ID string of the plugin to check success for or another satisfyMethod object.",
            "type": "array"
          },
          "options": {
            "properties": {
              "minNumSatisfied": {
                "description": "Only applicable to OR logic. Implements M of N logic.",
                "type": "number"
              }
            },
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "type",
          "conditions"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iEvent": {
        "properties": {
          "eventId": {
            "description": "The event ID",
            "type": "string"
          },
          "metadata": {
            "description": "The event metadata",
            "$ref": "#/components/schemas/iMetadata"
          },
          "eventTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "Other event specific metadata",
            "type": "array"
          }
        },
        "required": [
          "eventId",
          "metadata",
          "eventTimes"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iTierWithOptionalWeight": {
        "properties": {
          "claimId": {
            "description": "The claim ID to satisfy the tier",
            "type": "string"
          },
          "weight": {
            "description": "The weight of the tier",
            "$ref": "#/components/schemas/NumberType"
          },
          "uncheckable": {
            "description": "Uncheckable? If so, we will not display success or failure for this tier.\n\nWe will just display the claim criteria and metadata.",
            "type": "boolean"
          },
          "pointsCalculationMethod": {
            "description": "The calculation method to use for this tier. This is used for calculating the tier weight.\n\nBy default, we check if the user has met the criteria for non-indexed and for indexed, we check claimed successfully at least one time.",
            "type": "string"
          }
        },
        "required": [
          "claimId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iApplicationPage": {
        "properties": {
          "pageId": {
            "description": "The page ID",
            "type": "string"
          },
          "type": {
            "description": "The type of the page",
            "type": "string"
          },
          "metadata": {
            "description": "Metadata for the page",
            "$ref": "#/components/schemas/iMetadata"
          },
          "points": {
            "items": {
              "$ref": "#/components/schemas/iTierWithOptionalWeight"
            },
            "description": "Points to display in the page",
            "type": "array"
          }
        },
        "required": [
          "pageId",
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iApiKeyDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "tier": {
            "type": "string"
          },
          "label": {
            "type": "string"
          },
          "apiKey": {
            "type": "string"
          },
          "bitbadgesAddress": {
            "type": "string",
            "examples": [
              "bb1..."
            ]
          },
          "numRequests": {
            "type": "number"
          },
          "lastRequest": {
            "type": "number"
          },
          "createdAt": {
            "type": "number"
          },
          "expiry": {
            "type": "number"
          },
          "intendedUse": {
            "type": "string"
          },
          "stripeSubscriptionId": {
            "type": "string"
          },
          "subscriptionStatus": {
            "type": "string"
          },
          "currentPeriodEnd": {
            "type": "number"
          },
          "cancelAtPeriodEnd": {
            "type": "boolean"
          }
        },
        "required": [
          "_docId",
          "label",
          "apiKey",
          "bitbadgesAddress",
          "numRequests",
          "lastRequest",
          "createdAt",
          "expiry",
          "intendedUse"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iApplicationDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "applicationId": {
            "description": "The application ID",
            "type": "string"
          },
          "type": {
            "description": "Type of the application",
            "type": "string"
          },
          "createdBy": {
            "description": "The BitBadges address of the user who created this application",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "managedBy": {
            "description": "The BitBadges address of the user who is currently managing this",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "createdAt": {
            "description": "The time the application was created",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "lastUpdated": {
            "description": "The last updated timestamp",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "metadata": {
            "description": "The overall metadata for the application",
            "$ref": "#/components/schemas/iMetadata"
          },
          "pages": {
            "items": {
              "$ref": "#/components/schemas/iApplicationPage"
            },
            "description": "The pages for the application",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "applicationId",
          "type",
          "createdBy",
          "managedBy",
          "createdAt",
          "metadata",
          "pages"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iInheritMetadataFrom": {
        "properties": {
          "claimId": {
            "description": "The claim ID to link to",
            "type": "string"
          },
          "applicationId": {
            "description": "The application ID to link to",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID to link to",
            "$ref": "#/components/schemas/CollectionId"
          },
          "mapId": {
            "description": "The map ID to link to",
            "type": "string"
          },
          "tokenId": {
            "description": "The token ID to link to \"collectionId: CollectionIddgeId\"",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iUtilityPageDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "listingId": {
            "description": "The listing ID",
            "type": "string"
          },
          "type": {
            "description": "Type of the listing",
            "type": "string"
          },
          "createdBy": {
            "description": "The BitBadges address of the user who created this listing",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "managedBy": {
            "description": "The BitBadges address of the user who is currently managing this",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "directLink": {
            "description": "The direct link for the listing. If specified, we will skip the entire content / listing page. Thus, content and links should be empty [].",
            "type": "string"
          },
          "createdAt": {
            "description": "The time the listing was created",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "lastUpdated": {
            "description": "The last updated timestamp",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "metadata": {
            "description": "The overall metadata for the listing",
            "$ref": "#/components/schemas/iMetadata"
          },
          "inheritMetadataFrom": {
            "description": "Where to inherit metadata from? Only one can be specified.",
            "$ref": "#/components/schemas/iInheritMetadataFrom"
          },
          "content": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageContent"
            },
            "description": "The paginated content for the listing",
            "type": "array"
          },
          "links": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageLink"
            },
            "description": "The relevant links for the listing",
            "type": "array"
          },
          "displayTimes": {
            "description": "Optional time range for when the listing should be shown",
            "$ref": "#/components/schemas/iUintRange"
          },
          "visibility": {
            "enum": [
              "public",
              "private",
              "unlisted"
            ],
            "description": "Visibility state of the listing",
            "type": "string"
          },
          "categories": {
            "items": {
              "type": "string"
            },
            "description": "The categories of the listing",
            "type": "array"
          },
          "approvalStatus": {
            "properties": {
              "isApproved": {
                "description": "Whether the listing is approved",
                "type": "boolean"
              },
              "isFeatured": {
                "description": "Is  Featured",
                "type": "boolean"
              },
              "featuredPriority": {
                "description": "Featured Priority",
                "type": "number"
              },
              "rejected": {
                "description": "Rejected or just pending",
                "type": "boolean"
              },
              "reason": {
                "description": "Optional reason if not approved",
                "type": "string"
              },
              "updatedBy": {
                "$ref": "#/components/schemas/BitBadgesAddress",
                "description": "Address of who last updated the approval status"
              }
            },
            "required": [
              "isApproved"
            ],
            "additionalProperties": false,
            "description": "Approval status - can be used for moderation",
            "type": "object"
          },
          "viewCount": {
            "description": "The total view count for this listing. This is updated periodically from the view tracking document.",
            "$ref": "#/components/schemas/NumberType"
          },
          "estimatedCost": {
            "description": "The estimated cost for this utility/service",
            "$ref": "#/components/schemas/iEstimatedCost"
          },
          "estimatedTime": {
            "description": "The estimated time to complete or deliver this utility/service",
            "type": "string"
          },
          "viewsByPeriod": {
            "properties": {
              "hourly": {
                "description": "Views in the last hour",
                "type": "number"
              },
              "daily": {
                "description": "Views in the last 24 hours",
                "type": "number"
              },
              "weekly": {
                "description": "Views in the last 7 days",
                "type": "number"
              },
              "monthly": {
                "description": "Views in the last 30 days",
                "type": "number"
              }
            },
            "required": [
              "hourly",
              "daily",
              "weekly",
              "monthly"
            ],
            "additionalProperties": false,
            "description": "Optional breakdown of views by time period for trending calculations",
            "type": "object"
          },
          "linkedTo": {
            "description": "Linked details",
            "$ref": "#/components/schemas/iLinkedTo"
          },
          "locale": {
            "description": "Locale (ex: es, fr, etc.). If not specified, we assume en.",
            "type": "string"
          },
          "homePageView": {
            "properties": {
              "type": {
                "enum": [
                  "tokens",
                  "lists",
                  "claims",
                  "applications"
                ],
                "type": "string"
              },
              "category": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "category"
            ],
            "additionalProperties": false,
            "description": "Home page view",
            "type": "object"
          }
        },
        "required": [
          "_docId",
          "listingId",
          "type",
          "createdBy",
          "managedBy",
          "createdAt",
          "metadata",
          "content",
          "links",
          "visibility",
          "categories",
          "approvalStatus"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iLinkedTo": {
        "properties": {
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iUtilityPageContent": {
        "properties": {
          "type": {
            "description": "The type of content",
            "type": "string"
          },
          "label": {
            "description": "Label for the content page",
            "type": "string"
          },
          "content": {
            "description": "The content - markdown supported",
            "type": "string"
          }
        },
        "required": [
          "type",
          "label",
          "content"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUtilityPageLink": {
        "properties": {
          "url": {
            "description": "The URL of the link",
            "type": "string"
          },
          "claimId": {
            "description": "The claim ID to link to",
            "type": "string"
          },
          "applicationId": {
            "description": "The application ID to link to",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID to link to",
            "$ref": "#/components/schemas/CollectionId"
          },
          "mapId": {
            "description": "The map ID to link to",
            "type": "string"
          },
          "metadata": {
            "description": "Metadata for the link. Only applicable if the link is to a non-BitBadges entity. In other words, not tied to a specific claim, application, collection, etc.",
            "$ref": "#/components/schemas/iMetadata"
          }
        },
        "required": [
          "url"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iListingViewsDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "listingId": {
            "description": "The listing ID this view count is for",
            "type": "string"
          },
          "viewCount": {
            "description": "The total number of views",
            "$ref": "#/components/schemas/NumberType"
          },
          "lastUpdated": {
            "description": "The last time this view count was updated",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "viewsByPeriod": {
            "properties": {
              "hourly": {
                "description": "Views in the last hour",
                "type": "number"
              },
              "daily": {
                "description": "Views in the last 24 hours",
                "type": "number"
              },
              "weekly": {
                "description": "Views in the last 7 days",
                "type": "number"
              },
              "monthly": {
                "description": "Views in the last 30 days",
                "type": "number"
              }
            },
            "required": [
              "hourly",
              "daily",
              "weekly",
              "monthly"
            ],
            "additionalProperties": false,
            "description": "Optional breakdown of views by time period for trending calculations",
            "type": "object"
          }
        },
        "required": [
          "_docId",
          "listingId",
          "viewCount",
          "lastUpdated"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iClaimBuilderDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "cid": {
            "description": "The CID (content ID) of the document. This is used behind the scenes to handle off-chain vs on-chain data races.",
            "type": "string"
          },
          "createdBy": {
            "description": "The BitBadges address of the user who created this password",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "docClaimed": {
            "description": "True if the document is claimed by the collection",
            "type": "boolean"
          },
          "collectionId": {
            "description": "The collection ID of the document",
            "$ref": "#/components/schemas/CollectionId"
          },
          "managedBy": {
            "description": "The BitBadges address of the user who is currently managing this",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "trackerDetails": {
            "description": "Which challenge tracker is it tied to",
            "$ref": "#/components/schemas/iChallengeTrackerIdDetails"
          },
          "deletedAt": {
            "description": "Deleted at timestamp",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "plugins": {
            "items": {
              "$ref": "#/components/schemas/IntegrationPluginParams"
            },
            "description": "Dynamic checks to run in the form of plugins",
            "type": "array"
          },
          "pluginIds": {
            "items": {
              "type": "string"
            },
            "description": "For query purposes, the plugin IDs",
            "type": "array"
          },
          "manualDistribution": {
            "description": "If true, the claim codes are to be distributed manually. This doc will only be used for storage purposes.\nOnly in use for legacy on-chain claims.",
            "type": "boolean"
          },
          "approach": {
            "description": "The expected approach for the claim. This is for display purposes for the frontend.\n\nAvailable options:\n- in-site: The claim is expected to be completed in-site.\n- api: The claim is expected to be completed via an API call.\n- zapier: The claim is expected to be completed via Zapier auto-completion.",
            "type": "string"
          },
          "metadata": {
            "description": "Metadata for the claim",
            "$ref": "#/components/schemas/iMetadata"
          },
          "state": {
            "additionalProperties": {},
            "description": "The current state of each plugin",
            "type": "object"
          },
          "assignMethod": {
            "description": "Algorithm to determine the claaim number indices",
            "type": "string"
          },
          "satisfyMethod": {
            "description": "Custom success logic. If not provided, we will default to AND logic with all plugins.",
            "$ref": "#/components/schemas/iSatisfyMethod"
          },
          "action": {
            "properties": {
              "seedCode": {
                "type": "string"
              },
              "siwbbClaim": {
                "type": "boolean"
              }
            },
            "additionalProperties": false,
            "description": "Details for the action to perform if the criteria is correct",
            "type": "object"
          },
          "rewards": {
            "items": {
              "$ref": "#/components/schemas/iClaimReward"
            },
            "description": "Rewards to be shown upon a successful claim. If you need further gating, you can do this in two-steps.",
            "type": "array"
          },
          "estimatedCost": {
            "description": "Estimated cost for the user",
            "type": "string"
          },
          "estimatedTime": {
            "description": "Estimated time to satisfy the claim's requirements",
            "type": "string"
          },
          "showInSearchResults": {
            "description": "If true, the claim will be shown in search results",
            "type": "boolean"
          },
          "categories": {
            "items": {
              "type": "string"
            },
            "description": "The categories of the claim",
            "type": "array"
          },
          "lastUpdated": {
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "createdAt": {
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "version": {
            "$ref": "#/components/schemas/NumberType"
          },
          "testOnly": {
            "type": "boolean"
          },
          "cachePolicy": {
            "description": "For on-demand claims, we cache the result per user for a short period.\n\nTo help optimize performance, please provide a cache policy.\n\nThis is only applicable to on-demand claims.",
            "$ref": "#/components/schemas/iClaimCachePolicy"
          }
        },
        "required": [
          "_docId",
          "cid",
          "createdBy",
          "docClaimed",
          "collectionId",
          "managedBy",
          "plugins",
          "state",
          "action",
          "lastUpdated",
          "createdAt",
          "version"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iClaimCachePolicy": {
        "properties": {
          "ttl": {
            "description": "The number of seconds to cache the result. Default is 5 minutes (300 seconds) if none is specified.\n\nNote: This may be overridden by other options",
            "$ref": "#/components/schemas/NumberType"
          },
          "alwaysPermanent": {
            "description": "Permanent once the claim is calculated once. We will cache results indefinitely.",
            "type": "boolean"
          },
          "permanentAfter": {
            "description": "Permanent after a specific timestamp. Until then, we use the ttl. We will cache results indefinitely after this timestamp.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iClaimReward": {
        "properties": {
          "rewardId": {
            "description": "The ID of the reward (either a pre-configured one or \"custom\"). Currently, this is not used for anything.",
            "type": "string"
          },
          "instanceId": {
            "description": "The instance ID of the reward. A unique identifier for the reward.",
            "type": "string"
          },
          "metadata": {
            "properties": {
              "name": {
                "type": "string",
                "examples": [
                  "Name"
                ]
              },
              "description": {
                "type": "string",
                "examples": [
                  "Brief description."
                ]
              },
              "image": {
                "type": "string",
                "examples": [
                  "https://example.com/image.png",
                  "ipfs://Qm..."
                ]
              }
            },
            "required": [
              "name",
              "description",
              "image"
            ],
            "additionalProperties": false,
            "description": "Metadata for the reward. This is public-facing, so do not include any gated content here. By default, we use the associated rewardId.",
            "type": "object"
          },
          "automatic": {
            "description": "If true, the reward is automatically given to the user upon completion. No in-site logic is required.",
            "type": "boolean"
          },
          "gatedContent": {
            "description": "The gated content to display upon completion.",
            "$ref": "#/components/schemas/iClaimGatedContent"
          },
          "calculationMethod": {
            "properties": {
              "alwaysShow": {
                "type": "boolean"
              },
              "minClaimSuccesses": {
                "type": "number"
              }
            },
            "additionalProperties": false,
            "description": "Calculation method to use for the gated content. This is used to determine who is shown the gated content.\n\nBy default, we check min 1 claim success for indexed claims and criteria met for non-indexed claims.",
            "type": "object"
          }
        },
        "required": [
          "rewardId",
          "instanceId",
          "gatedContent"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iClaimGatedContent": {
        "properties": {
          "content": {
            "description": "The content (markdown supported) to be shown to successful claimers",
            "type": "string"
          },
          "url": {
            "description": "The URL to be shown to successful claimers",
            "type": "string"
          },
          "params": {
            "additionalProperties": {},
            "description": "The params to be shown to successful claimers. Only used for pre-configured rewards.",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iApprovalTrackerDoc": {
        "properties": {
          "collectionId": {
            "description": "The collection ID for the approval.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "approvalId": {
            "description": "The approval ID",
            "type": "string"
          },
          "amountTrackerId": {
            "description": "The amount tracker ID of the approval.",
            "type": "string"
          },
          "approvalLevel": {
            "description": "The approval level of the approval \"collection\", \"incoming\", or \"outgoing\".",
            "type": "string",
            "examples": [
              "collection",
              "incoming",
              "outgoing"
            ]
          },
          "approverAddress": {
            "description": "The address of the approval to check.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "trackerType": {
            "description": "The type of tracker to check \"overall\", \"to\", \"from\", or \"initiatedBy\".",
            "type": "string"
          },
          "approvedAddress": {
            "description": "The address to check for the approval.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "numTransfers": {
            "description": "The number of transfers. Is an incrementing tally.",
            "$ref": "#/components/schemas/NumberType"
          },
          "amounts": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "A tally of the amounts transferred for this approval.",
            "type": "array"
          },
          "lastUpdatedAt": {
            "description": "Last updated timestamp",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "collectionId",
          "approvalId",
          "amountTrackerId",
          "approvalLevel",
          "approverAddress",
          "trackerType",
          "approvedAddress",
          "_docId",
          "numTransfers",
          "amounts",
          "lastUpdatedAt"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iChallengeTrackerIdDetails": {
        "properties": {
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "approvalId": {
            "description": "The approval ID",
            "type": "string"
          },
          "challengeTrackerId": {
            "description": "The challenge ID",
            "type": "string"
          },
          "approvalLevel": {
            "enum": [
              "collection",
              "incoming",
              "outgoing",
              ""
            ],
            "description": "The challenge level (i.e. \"collection\", \"incoming\", \"outgoing\")",
            "type": "string",
            "examples": [
              "collection",
              "incoming",
              "outgoing"
            ]
          },
          "approverAddress": {
            "description": "The approver address (leave blank if approvalLevel = \"collection\")",
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "collectionId",
          "approvalId",
          "challengeTrackerId",
          "approvalLevel",
          "approverAddress"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMerkleChallengeTrackerDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "challengeTrackerId": {
            "description": "The challenge ID",
            "type": "string"
          },
          "approvalId": {
            "description": "The approval ID",
            "type": "string"
          },
          "approvalLevel": {
            "enum": [
              "collection",
              "incoming",
              "outgoing",
              ""
            ],
            "description": "The challenge level (i.e. \"collection\", \"incoming\", \"outgoing\")",
            "type": "string",
            "examples": [
              "collection",
              "incoming",
              "outgoing"
            ]
          },
          "approverAddress": {
            "description": "The approver address (leave blank if approvalLevel = \"collection\")",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "usedLeafIndices": {
            "items": {
              "$ref": "#/components/schemas/iUsedLeafStatus"
            },
            "description": "The used leaf indices for each challenge. A leaf index is the leaf location in the bottommost layer of the Merkle tree",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "collectionId",
          "challengeTrackerId",
          "approvalId",
          "approvalLevel",
          "approverAddress",
          "usedLeafIndices"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iUsedLeafStatus": {
        "properties": {
          "leafIndex": {
            "description": "The leaf index",
            "$ref": "#/components/schemas/NumberType"
          },
          "usedBy": {
            "description": "The address that used the leaf",
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "leafIndex",
          "usedBy"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iFetchDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "content": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/iMetadata"
              },
              {
                "$ref": "#/components/schemas/iApprovalInfoDetails"
              },
              {
                "$ref": "#/components/schemas/iOffChainBalancesMap"
              },
              {
                "$ref": "#/components/schemas/iChallengeDetails"
              }
            ],
            "description": "The content of the fetch document. Note that we store balances in BALANCES_DB and not here to avoid double storage."
          },
          "fetchedAt": {
            "description": "The time the document was fetched",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "fetchedAtBlock": {
            "description": "The block the document was fetched",
            "$ref": "#/components/schemas/NumberType"
          },
          "db": {
            "enum": [
              "ApprovalInfo",
              "Metadata",
              "Balances",
              "ChallengeInfo"
            ],
            "description": "The type of content fetched. This is used for querying purposes",
            "type": "string"
          },
          "isPermanent": {
            "description": "True if the document is permanent (i.e. fetched from a permanent URI like IPFS)",
            "type": "boolean"
          }
        },
        "required": [
          "_docId",
          "fetchedAt",
          "fetchedAtBlock",
          "db",
          "isPermanent"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iRefreshDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "refreshRequestTime": {
            "description": "The time the refresh was requested (Unix timestamp in milliseconds)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "_docId",
          "collectionId",
          "refreshRequestTime"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iAirdropDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "airdropped": {
            "description": "True if the airdrop has been completed",
            "type": "boolean"
          },
          "timestamp": {
            "description": "The timestamp of when the airdrop was completed (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "hash": {
            "description": "The hash of the airdrop transaction",
            "type": "string"
          },
          "ip": {
            "type": "string"
          }
        },
        "required": [
          "_docId",
          "airdropped",
          "timestamp"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iIPFSTotalsDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "bytesUploaded": {
            "description": "The total bytes uploaded",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "_docId",
          "bytesUploaded"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iCreatorCreditsDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "credits": {
            "description": "The total credits",
            "$ref": "#/components/schemas/NumberType"
          },
          "creditsLimit": {
            "description": "The limit of credits",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "_docId",
          "credits"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iComplianceDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "tokens": {
            "properties": {
              "nsfw": {
                "items": {
                  "$ref": "#/components/schemas/iBatchTokenDetails"
                },
                "type": "array"
              },
              "reported": {
                "items": {
                  "$ref": "#/components/schemas/iBatchTokenDetails"
                },
                "type": "array"
              }
            },
            "required": [
              "nsfw",
              "reported"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "accounts": {
            "properties": {
              "nsfw": {
                "items": {
                  "properties": {
                    "bitbadgesAddress": {
                      "$ref": "#/components/schemas/BitBadgesAddress",
                      "examples": [
                        "bb1..."
                      ]
                    },
                    "reason": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "bitbadgesAddress",
                    "reason"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              },
              "reported": {
                "items": {
                  "properties": {
                    "bitbadgesAddress": {
                      "$ref": "#/components/schemas/BitBadgesAddress",
                      "examples": [
                        "bb1..."
                      ]
                    },
                    "reason": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "bitbadgesAddress",
                    "reason"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              }
            },
            "required": [
              "nsfw",
              "reported"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "applications": {
            "properties": {
              "nsfw": {
                "items": {
                  "properties": {
                    "applicationId": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "applicationId",
                    "reason"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              },
              "reported": {
                "items": {
                  "properties": {
                    "applicationId": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "applicationId",
                    "reason"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              }
            },
            "required": [
              "nsfw",
              "reported"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "claims": {
            "properties": {
              "nsfw": {
                "items": {
                  "properties": {
                    "claimId": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "claimId",
                    "reason"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              },
              "reported": {
                "items": {
                  "properties": {
                    "claimId": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "claimId",
                    "reason"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              }
            },
            "required": [
              "nsfw",
              "reported"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "maps": {
            "properties": {
              "nsfw": {
                "items": {
                  "properties": {
                    "mapId": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "mapId",
                    "reason"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              },
              "reported": {
                "items": {
                  "properties": {
                    "mapId": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "mapId",
                    "reason"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              }
            },
            "required": [
              "nsfw",
              "reported"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "_docId",
          "tokens",
          "accounts"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iDeveloperAppDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "createdBy": {
            "description": "Creator of the app",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "managedBy": {
            "description": "The BitBadges address of the user who is currently managing this",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "name": {
            "description": "The name of the app",
            "type": "string",
            "examples": [
              "Name"
            ]
          },
          "description": {
            "description": "The description of the app",
            "type": "string",
            "examples": [
              "Brief description."
            ]
          },
          "image": {
            "description": "The image of the app",
            "type": "string",
            "examples": [
              "https://example.com/image.png",
              "ipfs://Qm..."
            ]
          },
          "clientId": {
            "description": "The client ID of the app",
            "type": "string"
          },
          "clientSecret": {
            "description": "The client secret of the app",
            "type": "string"
          },
          "redirectUris": {
            "items": {
              "type": "string"
            },
            "description": "The redirect URI of the app",
            "type": "array"
          },
          "lastUpdated": {
            "description": "The last updated timestamp",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "createdAt": {
            "description": "The time the app was created",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "_docId",
          "createdBy",
          "managedBy",
          "name",
          "description",
          "image",
          "clientId",
          "clientSecret",
          "redirectUris"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "DynamicDataHandlerType": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/OauthAppName"
          },
          {
            "enum": [
              "addresses"
            ],
            "type": "string"
          }
        ]
      },
      "ActionName": {
        "type": "string"
      },
      "DynamicDataHandlerActionRequest": {
        "properties": {
          "actionName": {
            "examples": [
              "add"
            ],
            "$ref": "#/components/schemas/ActionName"
          },
          "payload": {}
        },
        "required": [
          "actionName",
          "payload"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDynamicDataDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "handlerId": {
            "description": "The handler ID. Can also be thought of as the type of dynamic data (\"addresses\", \"email\", ...)",
            "type": "string",
            "examples": [
              "email",
              "addresses"
            ]
          },
          "dynamicDataId": {
            "description": "The dynamic data ID. The ID of the store.",
            "type": "string"
          },
          "label": {
            "description": "The label of the data store",
            "type": "string"
          },
          "dataSecret": {
            "description": "The data secret. Used in cases where you are not signed in as creator. This authenticates the request. Not applicable to public stores",
            "type": "string"
          },
          "data": {
            "description": "The data itself."
          },
          "createdBy": {
            "description": "The creator of the dynamic data store",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "managedBy": {
            "description": "The manager of the dynamic data store",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "publicUseInClaims": {
            "description": "Whether the dynamic data store is public. If true, the data can be accessed without authentication.",
            "type": "boolean"
          },
          "createdAt": {
            "description": "The time the dynamic data store was created",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "lastUpdated": {
            "description": "The time the dynamic data store was last updated",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "_docId",
          "handlerId",
          "dynamicDataId",
          "label",
          "dataSecret",
          "data",
          "createdBy",
          "managedBy"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iAccessTokenDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "accessToken": {
            "type": "string"
          },
          "tokenType": {
            "type": "string"
          },
          "clientId": {
            "type": "string"
          },
          "accessTokenExpiresAt": {
            "type": "number"
          },
          "refreshToken": {
            "type": "string"
          },
          "refreshTokenExpiresAt": {
            "type": "number"
          },
          "bitbadgesAddress": {
            "type": "string",
            "examples": [
              "bb1..."
            ]
          },
          "address": {
            "type": "string"
          },
          "scopes": {
            "items": {
              "$ref": "#/components/schemas/OAuthScopeDetails"
            },
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "accessToken",
          "tokenType",
          "clientId",
          "accessTokenExpiresAt",
          "refreshToken",
          "refreshTokenExpiresAt",
          "bitbadgesAddress",
          "address",
          "scopes"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iPluginDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "createdBy": {
            "description": "The BitBadges address who created the plugin doc",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "managedBy": {
            "description": "The BitBadges address of the user who is currently managing this",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "pluginId": {
            "description": "The unique plugin ID",
            "type": "string"
          },
          "pluginSecret": {
            "description": "The secret of the plugin. Used to verify BitBadges as origin of request.",
            "type": "string"
          },
          "inviteCode": {
            "description": "Invite code for the plugin",
            "type": "string"
          },
          "toPublish": {
            "description": "To publish to directory?",
            "type": "boolean"
          },
          "reviewCompleted": {
            "description": "Review process completed",
            "type": "boolean"
          },
          "metadata": {
            "properties": {
              "createdBy": {
                "description": "Creator of the plugin",
                "type": "string"
              },
              "name": {
                "description": "The name of the plugin",
                "type": "string",
                "examples": [
                  "Name"
                ]
              },
              "description": {
                "description": "Description of the plugin",
                "type": "string",
                "examples": [
                  "Brief description."
                ]
              },
              "image": {
                "description": "The image of the plugin",
                "type": "string",
                "examples": [
                  "https://example.com/image.png",
                  "ipfs://Qm..."
                ]
              },
              "parentApp": {
                "description": "Parent app of the plugin. If blank, treated as its own app / entity.",
                "type": "string"
              },
              "documentation": {
                "description": "Documentation for the plugin",
                "type": "string"
              },
              "sourceCode": {
                "description": "Source code for the plugin",
                "type": "string"
              },
              "supportLink": {
                "description": "Support link for the plugin",
                "type": "string"
              }
            },
            "required": [
              "createdBy",
              "name",
              "description",
              "image"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "locale": {
            "description": "Locale that is supported by the plugin. By default, we assume 'en' is supported if not specified.",
            "type": "string"
          },
          "lastUpdated": {
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "createdAt": {
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "deletedAt": {
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "approvedUsers": {
            "items": {
              "$ref": "#/components/schemas/NativeAddress"
            },
            "type": "array"
          },
          "versions": {
            "items": {
              "$ref": "#/components/schemas/iPluginVersionConfig"
            },
            "description": "Array of version-controlled plugin configurations",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "createdBy",
          "managedBy",
          "pluginId",
          "toPublish",
          "reviewCompleted",
          "metadata",
          "lastUpdated",
          "createdAt",
          "approvedUsers",
          "versions"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iPluginVersionConfig": {
        "properties": {
          "version": {
            "description": "Version of the plugin",
            "$ref": "#/components/schemas/NumberType"
          },
          "finalized": {
            "description": "True if the version is finalized",
            "type": "boolean"
          },
          "createdAt": {
            "description": "The time the version was created",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "lastUpdated": {
            "description": "The time the version was last updated",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "reuseForNonIndexed": {
            "description": "Reuse for nonindexed balances? Only applicable if is stateless, requires no user inputs, and requires no sessions.",
            "type": "boolean"
          },
          "receiveStatusWebhook": {
            "description": "Whether the plugin should receive status webhooks",
            "type": "boolean"
          },
          "skipProcessingWebhook": {
            "description": "Whether the plugin should skip processing webhooks. We will just auto-treat it as successful.",
            "type": "boolean"
          },
          "ignoreSimulations": {
            "description": "Ignore simulations?",
            "type": "boolean"
          },
          "stateFunctionPreset": {
            "description": "Preset type for how the plugin state is to be maintained."
          },
          "duplicatesAllowed": {
            "description": "Whether it makes sense for multiple of this plugin to be allowed",
            "type": "boolean"
          },
          "requiresSessions": {
            "description": "This means that the plugin can be used w/o any session cookies or authentication.",
            "type": "boolean"
          },
          "requiresUserInputs": {
            "description": "This is a flag for being compatible with auto-triggered claims, meaning no user interaction is needed.",
            "type": "boolean"
          },
          "userInputsSchema": {
            "items": {
              "$ref": "#/components/schemas/JsonBodyInputSchema"
            },
            "type": "array"
          },
          "publicParamsSchema": {
            "items": {
              "$ref": "#/components/schemas/JsonBodyInputSchema"
            },
            "type": "array"
          },
          "privateParamsSchema": {
            "items": {
              "$ref": "#/components/schemas/JsonBodyInputSchema"
            },
            "type": "array"
          },
          "userInputRedirect": {
            "properties": {
              "baseUri": {
                "description": "The base URI for user inputs. Note: This is experimental and not fully supported yet.",
                "type": "string"
              },
              "tutorialUri": {
                "description": "The tutorial URI for user inputs.",
                "type": "string"
              }
            },
            "additionalProperties": false,
            "description": "The redirect URI for user inputs.",
            "type": "object"
          },
          "claimCreatorRedirect": {
            "properties": {
              "toolUri": {
                "description": "The tool URI for claim creators. Note: This is experimental and not fully supported yet.",
                "type": "string"
              },
              "tutorialUri": {
                "description": "The tutorial URI for claim creators.",
                "type": "string"
              },
              "testerUri": {
                "description": "The tester URI for claim creators. Note: This is experimental and not fully supported yet.",
                "type": "string"
              }
            },
            "additionalProperties": false,
            "description": "The redirect URI for claim creators.",
            "type": "object"
          },
          "verificationCall": {
            "properties": {
              "uri": {
                "type": "string",
                "examples": [
                  "https://example.com",
                  "ipfs://Qm..."
                ]
              },
              "method": {
                "enum": [
                  "POST",
                  "GET",
                  "PUT",
                  "DELETE"
                ],
                "type": "string"
              },
              "hardcodedInputs": {
                "items": {
                  "$ref": "#/components/schemas/JsonBodyInputWithValue"
                },
                "type": "array"
              },
              "passAddress": {
                "type": "boolean"
              },
              "passDiscord": {
                "type": "boolean"
              },
              "passEmail": {
                "type": "boolean"
              },
              "passTwitter": {
                "type": "boolean"
              },
              "passGoogle": {
                "type": "boolean"
              },
              "passYoutube": {
                "type": "boolean"
              },
              "passGithub": {
                "type": "boolean"
              },
              "passTwitch": {
                "type": "boolean"
              },
              "passStrava": {
                "type": "boolean"
              },
              "passReddit": {
                "type": "boolean"
              },
              "passBluesky": {
                "type": "boolean"
              },
              "passShopify": {
                "type": "boolean"
              },
              "passFacebook": {
                "type": "boolean"
              },
              "passTelegram": {
                "type": "boolean"
              },
              "passFarcaster": {
                "type": "boolean"
              },
              "passSlack": {
                "type": "boolean"
              },
              "passMeetup": {
                "type": "boolean"
              },
              "passMailchimp": {
                "type": "boolean"
              },
              "postProcessingJs": {
                "type": "string"
              }
            },
            "required": [
              "uri",
              "method",
              "hardcodedInputs",
              "postProcessingJs"
            ],
            "additionalProperties": false,
            "description": "The verification URL config. This lets us know what should be passed to the plugin payload.",
            "type": "object"
          },
          "customDetailsDisplay": {
            "description": "Custom details display for the plugin. Use {{publicParamKey}} to dynamically display the values of public parameters.\n\nExample: \"This plugin checks for a minimum of {{publicBalanceParam}} balance.\"",
            "type": "string"
          },
          "requireSignIn": {
            "description": "Require BitBadges sign-in to use the plugin?\nThis will ensure that any addresss received is actually verified by BitBadges.\nOtherwise, the address will be the claimee's address but it could be manually entered (if configuration allows).\n\nWe recommend keeping this false to allow for non-indexed support and also be more flexible\nfor the claim creator's implementation.",
            "type": "boolean"
          }
        },
        "required": [
          "version",
          "finalized",
          "createdAt",
          "lastUpdated",
          "reuseForNonIndexed",
          "receiveStatusWebhook",
          "stateFunctionPreset",
          "duplicatesAllowed",
          "requiresSessions",
          "requiresUserInputs",
          "userInputsSchema",
          "publicParamsSchema",
          "privateParamsSchema"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDepositBalanceDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "bitbadgesAddress": {
            "description": "The BitBadges address of the user",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "_docId",
          "bitbadgesAddress"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iSIWBBRequestDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "code": {
            "description": "The actual code itself",
            "type": "string"
          },
          "bitbadgesAddress": {
            "description": "The BitBadges address of the signer",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "address": {
            "description": "The native address of the signer",
            "$ref": "#/components/schemas/NativeAddress"
          },
          "chain": {
            "description": "The native chain for the user",
            "$ref": "#/components/schemas/SupportedChain"
          },
          "name": {
            "type": "string",
            "examples": [
              "Name"
            ]
          },
          "description": {
            "type": "string",
            "examples": [
              "Brief description."
            ]
          },
          "image": {
            "type": "string",
            "examples": [
              "https://example.com/image.png",
              "ipfs://Qm..."
            ]
          },
          "scopes": {
            "items": {
              "$ref": "#/components/schemas/OAuthScopeDetails"
            },
            "type": "array"
          },
          "expiresAt": {
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "createdAt": {
            "description": "The timestamp of when the signature was created (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "deletedAt": {
            "description": "If deleted, we still store temporarily for a period of time. We use a deletedAt timestamp to determine when to delete.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "clientId": {
            "description": "The client ID of the app that requested the signature",
            "type": "string"
          },
          "redirectUri": {
            "description": "The redirect URI of the app",
            "type": "string"
          },
          "codeChallenge": {
            "description": "The code challenge for the SIWBB request (if used with PKCE).",
            "type": "string"
          },
          "codeChallengeMethod": {
            "enum": [
              "S256",
              "plain"
            ],
            "description": "The code challenge method for the SIWBB request (if used with PKCE).",
            "type": "string"
          }
        },
        "required": [
          "_docId",
          "code",
          "bitbadgesAddress",
          "address",
          "chain",
          "scopes",
          "expiresAt",
          "createdAt",
          "clientId"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iMapDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "creator": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "mapId": {
            "type": "string"
          },
          "inheritManagerFrom": {
            "$ref": "#/components/schemas/NumberType"
          },
          "manager": {
            "type": "string"
          },
          "updateCriteria": {
            "$ref": "#/components/schemas/iMapUpdateCriteria"
          },
          "valueOptions": {
            "$ref": "#/components/schemas/iValueOptions"
          },
          "defaultValue": {
            "type": "string"
          },
          "permissions": {
            "$ref": "#/components/schemas/iMapPermissions"
          },
          "metadata": {
            "$ref": "#/components/schemas/iCollectionMetadata"
          },
          "values": {
            "additionalProperties": {
              "$ref": "#/components/schemas/iValueStore"
            },
            "description": "The (key, value) pairs for the maps that are set.",
            "type": "object"
          },
          "populatedMetadata": {
            "description": "The fetched/populated metadata for the map (if any). This is the actual metadata object with name, image, description, etc.",
            "$ref": "#/components/schemas/iMetadata"
          },
          "updateHistory": {
            "items": {
              "$ref": "#/components/schemas/iUpdateHistory"
            },
            "description": "The update history for the map. Maps are maintained through blockchain transactions.",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "creator",
          "mapId",
          "inheritManagerFrom",
          "manager",
          "updateCriteria",
          "valueOptions",
          "defaultValue",
          "permissions",
          "metadata",
          "values",
          "updateHistory"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iUpdateHistory": {
        "properties": {
          "txHash": {
            "description": "The transaction hash of the on-chain transaction that updated this.",
            "type": "string",
            "examples": [
              "CE22D7..."
            ]
          },
          "block": {
            "description": "The block number of the on-chain transaction that updated this.",
            "$ref": "#/components/schemas/NumberType"
          },
          "blockTimestamp": {
            "description": "The timestamp of the block of the on-chain transaction that updated this.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "timestamp": {
            "description": "The indexer's timestamp of the update. This is provided in some cases because the time of indexing may be inconsistent with the time of the block.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "txHash",
          "block",
          "blockTimestamp",
          "timestamp"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMapWithValues": {
        "properties": {
          "creator": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "mapId": {
            "type": "string"
          },
          "inheritManagerFrom": {
            "$ref": "#/components/schemas/NumberType"
          },
          "manager": {
            "type": "string"
          },
          "updateCriteria": {
            "$ref": "#/components/schemas/iMapUpdateCriteria"
          },
          "valueOptions": {
            "$ref": "#/components/schemas/iValueOptions"
          },
          "defaultValue": {
            "type": "string"
          },
          "permissions": {
            "$ref": "#/components/schemas/iMapPermissions"
          },
          "metadata": {
            "$ref": "#/components/schemas/iCollectionMetadata"
          },
          "values": {
            "additionalProperties": {
              "$ref": "#/components/schemas/iValueStore"
            },
            "description": "The (key, value) pairs for the maps that are set.",
            "type": "object"
          },
          "populatedMetadata": {
            "description": "The fetched/populated metadata for the map (if any). This is the actual metadata object with name, image, description, etc.",
            "$ref": "#/components/schemas/iMetadata"
          },
          "updateHistory": {
            "items": {
              "$ref": "#/components/schemas/iUpdateHistory"
            },
            "description": "The update history for the map. Maps are maintained through blockchain transactions.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "mapId",
          "inheritManagerFrom",
          "manager",
          "updateCriteria",
          "valueOptions",
          "defaultValue",
          "permissions",
          "metadata",
          "values",
          "updateHistory"
        ],
        "additionalProperties": false,
        "description": "",
        "type": "object"
      },
      "iClaimDetails": {
        "properties": {
          "_includesPrivateParams": {
            "description": "Whether the claim fetch includes private params",
            "type": "boolean"
          },
          "claimId": {
            "description": "Unique claim ID.",
            "type": "string"
          },
          "createdBy": {
            "description": "The original creator of the claim",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "managedBy": {
            "description": "The BitBadges address of the user who is currently managing this",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "Collection ID that the claim is for (if applicable - collection claims).",
            "$ref": "#/components/schemas/CollectionId"
          },
          "standaloneClaim": {
            "description": "Standalone claims are not linked with a token or list.",
            "type": "boolean"
          },
          "trackerDetails": {
            "description": "The tracker details for the claim (if applicable - collection claims).",
            "$ref": "#/components/schemas/iChallengeTrackerIdDetails"
          },
          "plugins": {
            "items": {
              "$ref": "#/components/schemas/IntegrationPluginDetails"
            },
            "description": "Claim plugins. These are the criteria that must pass for a user to claim.",
            "type": "array"
          },
          "rewards": {
            "items": {
              "$ref": "#/components/schemas/iClaimReward"
            },
            "description": "Rewards for the claim.",
            "type": "array"
          },
          "estimatedCost": {
            "description": "Estimated cost for the claim.",
            "type": "string"
          },
          "showInSearchResults": {
            "description": "If true, the claim will be shown in search results",
            "type": "boolean"
          },
          "categories": {
            "items": {
              "type": "string"
            },
            "description": "The categories of the claim",
            "type": "array"
          },
          "estimatedTime": {
            "description": "Estimated time to satisfy the claim's requirements.",
            "type": "string"
          },
          "manualDistribution": {
            "description": "If manual distribution is enabled, we do not handle any distribution of claim codes.\nWe leave that up to the claim creator.\n\nOnly applicable for on-chain token claims. This is only used in advanced self-hosted cases.",
            "type": "boolean"
          },
          "approach": {
            "description": "How the claim is expected to be completed. This is for display purposes for the frontend.\n\nAvailable options:\n- in-site (default): The claim is expected to be completed in-site.\n- api: The claim is expected to be completed via an API call.\n- zapier: The claim is expected to be completed via Zapier auto-completion.\n\nTypically, you will use the in-site approach",
            "type": "string"
          },
          "seedCode": {
            "description": "Seed code for the claim. Only used for on-chain token claims.\n\nThis is how we produce all reserved codes for the on-chain merkle challenge / proofs.",
            "type": "string"
          },
          "metadata": {
            "description": "Metadata for the claim.",
            "$ref": "#/components/schemas/iMetadata"
          },
          "assignMethod": {
            "description": "Algorithm to determine the claim number order. Blank is just incrementing claim numbers.\n\nFor most cases, you will not need to specify this.",
            "type": "string"
          },
          "lastUpdated": {
            "description": "Last updated timestamp for the claim.",
            "$ref": "#/components/schemas/NumberType"
          },
          "version": {
            "description": "The version of the claim.",
            "$ref": "#/components/schemas/NumberType"
          },
          "satisfyMethod": {
            "description": "Custom satisfaction logic.\n\nIf left blank, all plugins must pass for the claim to be satisfied.\nOtherwise, you can specify a custom method to determine if the claim is satisfied.",
            "$ref": "#/components/schemas/iSatisfyMethod"
          },
          "cachePolicy": {
            "description": "Cache policy for the claim. Only needed for on-demand claims.",
            "$ref": "#/components/schemas/iClaimCachePolicy"
          },
          "_templateInfo": {
            "properties": {
              "supportedApproaches": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "pluginId": {
                "type": "string"
              },
              "completedTemplateStep": {
                "type": "boolean"
              }
            },
            "additionalProperties": false,
            "description": "For internal use by the frontend.",
            "type": "object"
          }
        },
        "required": [
          "_includesPrivateParams",
          "claimId",
          "plugins",
          "version"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iEstimatedCost": {
        "properties": {
          "amount": {
            "description": "The amount of the cost",
            "$ref": "#/components/schemas/NumberType"
          },
          "denom": {
            "description": "The denomination of the cost (e.g. 'USD', 'ETH', etc.)",
            "type": "string"
          }
        },
        "required": [
          "amount",
          "denom"
        ],
        "additionalProperties": false,
        "description": "A cost estimate with an amount and denomination, similar to CosmosCoin but for display purposes only.",
        "type": "object"
      },
      "iDynamicStoreDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "storeId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "createdBy": {
            "type": "string"
          },
          "defaultValue": {
            "type": "boolean"
          },
          "globalEnabled": {
            "type": "boolean"
          },
          "uri": {
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "type": "string"
          }
        },
        "required": [
          "_docId",
          "storeId",
          "createdBy",
          "defaultValue",
          "globalEnabled"
        ],
        "additionalProperties": false,
        "description": "DynamicStoreDoc represents an on-chain dynamic store document from the API indexer.\n\nBondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iDynamicStoreValueDoc": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "storeId": {
            "$ref": "#/components/schemas/NumberType"
          },
          "address": {
            "type": "string"
          },
          "value": {
            "type": "boolean"
          }
        },
        "required": [
          "_docId",
          "storeId",
          "address",
          "value"
        ],
        "additionalProperties": false,
        "description": "DynamicStoreValueDoc represents a value stored in an on-chain dynamic store for a specific address.\n\nBondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iGetMapsPayload": {
        "properties": {
          "mapIds": {
            "items": {
              "type": "string"
            },
            "description": "The IDs of the maps to fetch.",
            "type": "array"
          }
        },
        "required": [
          "mapIds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetMapsSuccessResponse": {
        "properties": {
          "maps": {
            "items": {
              "$ref": "#/components/schemas/iMapWithValues"
            },
            "type": "array"
          }
        },
        "required": [
          "maps"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetMapValuesPayload": {
        "properties": {
          "mapId": {
            "description": "The map ID to fetch.",
            "type": "string"
          },
          "keys": {
            "items": {
              "type": "string"
            },
            "description": "The values to fetch for each map.",
            "type": "array"
          }
        },
        "required": [
          "mapId",
          "keys"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetMapValuesSuccessResponse": {
        "properties": {
          "values": {
            "items": {
              "properties": {
                "mapId": {
                  "type": "string"
                },
                "values": {
                  "additionalProperties": {
                    "$ref": "#/components/schemas/iValueStore"
                  },
                  "type": "object"
                }
              },
              "required": [
                "mapId",
                "values"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "values"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetMapPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetMapSuccessResponse": {
        "properties": {
          "map": {
            "$ref": "#/components/schemas/iMapWithValues"
          }
        },
        "required": [
          "map"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetMapValuePayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetMapValueSuccessResponse": {
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "lastSetBy": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "key",
          "value",
          "lastSetBy"
        ],
        "additionalProperties": false,
        "description": "",
        "type": "object"
      },
      "iGetCollectionOwnersPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionOwnersSuccessResponse": {
        "properties": {
          "owners": {
            "items": {
              "$ref": "#/components/schemas/iBalanceDoc"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "owners",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionTransferActivityPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          },
          "address": {
            "description": "Optional address to filter activity by",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionTransferActivitySuccessResponse": {
        "properties": {
          "activity": {
            "items": {
              "$ref": "#/components/schemas/iTransferActivityDoc"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "activity",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionChallengeTrackersPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionChallengeTrackersSuccessResponse": {
        "properties": {
          "challengeTrackers": {
            "items": {
              "$ref": "#/components/schemas/iMerkleChallengeTrackerDoc"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "challengeTrackers",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionAmountTrackersPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionAmountTrackersSuccessResponse": {
        "properties": {
          "amountTrackers": {
            "items": {
              "$ref": "#/components/schemas/iApprovalTrackerDoc"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "amountTrackers",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionListingsPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          },
          "tokenId": {
            "description": "Optional token ID to filter listings by",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionListingsSuccessResponse": {
        "properties": {
          "listings": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageDoc"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "listings",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTransferActivityForUserPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTokensViewForUserPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          },
          "collectionId": {
            "description": "Optional collection ID to filter by",
            "$ref": "#/components/schemas/CollectionId"
          },
          "viewType": {
            "enum": [
              "collected",
              "managing",
              "created"
            ],
            "description": "The view type to search for. Default is 'collected'\n\n- 'collected' will return the tokens the user has a balance of\n- 'managing' will return the tokens the user is managing\n- 'created' will return the tokens the user has created",
            "type": "string",
            "examples": [
              "viewKey"
            ]
          },
          "standard": {
            "description": "The standard to filter by for the view.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTransferActivityForUserSuccessResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          },
          "activity": {
            "items": {
              "$ref": "#/components/schemas/iTransferActivityDoc"
            },
            "type": "array"
          }
        },
        "required": [
          "pagination",
          "activity"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTokensViewForUserSuccessResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          },
          "tokens": {
            "items": {
              "$ref": "#/components/schemas/iBalanceDoc"
            },
            "type": "array"
          }
        },
        "required": [
          "pagination",
          "tokens"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimActivityForUserPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          },
          "viewType": {
            "enum": [
              "all",
              "public"
            ],
            "description": "The view type to search for. Default is 'public'\n\n- 'all' will return all claim activity even private (must have permission to view private activity)\n- 'public' will only return public claim activity",
            "type": "string",
            "examples": [
              "viewKey"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimActivityForUserSuccessResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          },
          "activity": {
            "items": {
              "$ref": "#/components/schemas/iClaimActivityDoc"
            },
            "type": "array"
          }
        },
        "required": [
          "pagination",
          "activity"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetSiwbbRequestsForUserPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetSiwbbRequestsForUserSuccessResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          },
          "requests": {
            "items": {},
            "type": "array"
          }
        },
        "required": [
          "pagination",
          "requests"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPointsActivityForUserPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPointsActivityForUserSuccessResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          },
          "activity": {
            "items": {
              "$ref": "#/components/schemas/iPointsActivityDoc"
            },
            "type": "array"
          }
        },
        "required": [
          "pagination",
          "activity"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionSuccessResponse": {
        "properties": {
          "collection": {
            "description": "The collection details",
            "$ref": "#/components/schemas/iBitBadgesCollection"
          },
          "metadata": {
            "description": "The current collection metadata",
            "$ref": "#/components/schemas/iMetadata"
          }
        },
        "required": [
          "collection",
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTokenMetadataPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTokenMetadataSuccessResponse": {
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/iMetadata"
          }
        },
        "required": [
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "GetCollectionClaimsPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionClaimsSuccessResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          },
          "claims": {
            "items": {
              "$ref": "#/components/schemas/iClaimDetails"
            },
            "type": "array"
          }
        },
        "required": [
          "pagination",
          "claims"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "GetAddressListClaimsPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetAddressListClaimsSuccessResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          },
          "claims": {
            "items": {
              "$ref": "#/components/schemas/iClaimDetails"
            },
            "type": "array"
          }
        },
        "required": [
          "pagination",
          "claims"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iFilterSuggestionsPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iFilterSuggestionsSuccessResponse": {
        "properties": {
          "attributes": {
            "items": {
              "properties": {
                "name": {
                  "type": "string",
                  "examples": [
                    "Name"
                  ]
                },
                "value": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    }
                  ]
                },
                "count": {
                  "type": "number"
                },
                "type": {
                  "type": "string"
                },
                "floorPrice": {
                  "properties": {
                    "amount": {
                      "$ref": "#/components/schemas/NumberType"
                    },
                    "denom": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "amount",
                    "denom"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                }
              },
              "required": [
                "name",
                "value",
                "count",
                "type"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "attributes"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iFilterTokensInCollectionPayload": {
        "properties": {
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "Limit to specific token IDs. Leave undefined to not filter by token ID.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "categories": {
            "items": {
              "type": "string"
            },
            "description": "Limit to specific lists. Leave undefined to not filter by list.",
            "type": "array"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "description": "Limit to specific lists. Leave undefined to not filter by list.",
            "type": "array"
          },
          "mostViewed": {
            "enum": [
              "daily",
              "allTime",
              "weekly",
              "monthly",
              "yearly"
            ],
            "description": "mostViewed is a special view that sorts by most viewed tokens. May be incompatible with other filters.",
            "type": "string"
          },
          "bookmark": {
            "description": "Pagination bookmark. Leave undefined or \"\" for first request.",
            "type": "string"
          },
          "attributes": {
            "items": {
              "properties": {
                "name": {
                  "type": "string",
                  "examples": [
                    "Name"
                  ]
                },
                "value": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    }
                  ]
                }
              },
              "required": [
                "name",
                "value"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "Attribute queries",
            "type": "array"
          },
          "priceRange": {
            "description": "The listing prices",
            "$ref": "#/components/schemas/iUintRange"
          },
          "denom": {
            "description": "Denom for the price range. Defaults to ubadge.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iFilterTokensInCollectionSuccessResponse": {
        "properties": {
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "tokenIds",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetOwnersPayload": {
        "properties": {
          "bookmark": {
            "description": "The pagination bookmark for where to start the request. Bookmarks are obtained via the previous response. \"\" for first request.",
            "type": "string"
          },
          "sortBy": {
            "description": "Sort by amount descending.",
            "enum": [
              "amount"
            ],
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetOwnersSuccessResponse": {
        "properties": {
          "owners": {
            "items": {
              "$ref": "#/components/schemas/iBalanceDoc"
            },
            "description": "Represents a list of owners balance details.",
            "type": "array"
          },
          "pagination": {
            "description": "Represents pagination information.",
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "owners",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetBalanceByAddressSpecificTokenPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetBalanceByAddressSpecificTokenSuccessResponse": {
        "properties": {
          "balance": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "balance"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetBalanceByAddressPayload": {
        "properties": {
          "fetchPrivateParams": {
            "description": "If true, we will fetch private parameters for any claims / approvals. Must be creator.\n\nThis is only applicable to incoming / outgoing approvals with claims.",
            "type": "boolean"
          },
          "forceful": {
            "description": "If true, we will forcefully fetch the balance even if it is already cached. Only applicable to non-indexed / on-demand collections.",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetBalanceByAddressSuccessResponse": {
        "properties": {
          "balances": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "The user's balances.",
            "type": "array"
          },
          "incomingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserIncomingApproval"
            },
            "description": "The user's incoming approvals.",
            "type": "array"
          },
          "outgoingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserOutgoingApproval"
            },
            "description": "The user's outgoing approvals.",
            "type": "array"
          },
          "userPermissions": {
            "description": "The user's permissions.",
            "$ref": "#/components/schemas/iUserPermissions"
          },
          "autoApproveSelfInitiatedOutgoingTransfers": {
            "description": "Whether the user's self-initiated outgoing transfers are auto-approved. If not, they must be explicitly approved using the outgoing approvals.",
            "type": "boolean"
          },
          "autoApproveSelfInitiatedIncomingTransfers": {
            "description": "Whether the user's self-initiated incoming transfers are auto-approved. If not, they must be explicitly approved using the incoming approvals.",
            "type": "boolean"
          },
          "autoApproveAllIncomingTransfers": {
            "description": "Whether the user's all incoming transfers are auto-approved. If not, they must be explicitly approved using the incoming approvals.",
            "type": "boolean"
          },
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "bitbadgesAddress": {
            "description": "The BitBadges address of the user",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "updateHistory": {
            "items": {
              "$ref": "#/components/schemas/iUpdateHistory"
            },
            "description": "The update history of this balance",
            "type": "array"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "description": "Optional tags for this balance",
            "type": "array"
          }
        },
        "required": [
          "balances",
          "incomingApprovals",
          "outgoingApprovals",
          "userPermissions",
          "autoApproveSelfInitiatedOutgoingTransfers",
          "autoApproveSelfInitiatedIncomingTransfers",
          "autoApproveAllIncomingTransfers",
          "_docId",
          "collectionId",
          "bitbadgesAddress",
          "updateHistory"
        ],
        "additionalProperties": false,
        "description": "\nThis stores everythign about a user's balances for a specific collection ID.\nThis includes their balances, incoming approvals, outgoing approvals, and permissions.\n\nBondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iGetTokenActivityPayload": {
        "properties": {
          "bookmark": {
            "description": "An optional bookmark for pagination. Bookmarks are obtained via the previous response. \"\" for first request.",
            "type": "string"
          },
          "bitbadgesAddress": {
            "description": "Specific address to filter by. If not present, all activity will be returned.",
            "type": "string",
            "examples": [
              "bb1..."
            ]
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTokenActivitySuccessResponse": {
        "properties": {
          "activity": {
            "items": {
              "$ref": "#/components/schemas/iTransferActivityDoc"
            },
            "description": "Array of transfer activity information.",
            "type": "array"
          },
          "pagination": {
            "description": "Pagination information.",
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "activity",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "MetadataFetchOptions": {
        "properties": {
          "doNotFetchCollectionMetadata": {
            "description": "If true, collection metadata will not be fetched.",
            "type": "boolean"
          },
          "uris": {
            "items": {
              "type": "string"
            },
            "description": "If present, the metadata corresponding to the specified URIs will be fetched.",
            "type": "array"
          },
          "tokenIds": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/iUintRange"
                },
                "type": "array"
              }
            ],
            "description": "If present, the metadata corresponding to the specified token IDs will be fetched.",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          }
        },
        "additionalProperties": false,
        "description": "Defines the options for fetching metadata.",
        "type": "object"
      },
      "CollectionViewKey": {
        "enum": [
          "transferActivity",
          "owners",
          "amountTrackers",
          "challengeTrackers",
          "listings",
          "tokenFloorPrices"
        ],
        "description": "Supported view keys for fetching additional collection details.",
        "type": "string"
      },
      "GetAdditionalCollectionDetailsPayload": {
        "properties": {
          "viewsToFetch": {
            "items": {
              "properties": {
                "viewType": {
                  "$ref": "#/components/schemas/CollectionViewKey",
                  "description": "The base view type to fetch.",
                  "examples": [
                    "viewKey"
                  ]
                },
                "viewId": {
                  "description": "A unique view ID. This is used for pagination. All fetches w/ same ID should be made with same criteria.",
                  "type": "string",
                  "examples": [
                    "viewKey"
                  ]
                },
                "bookmark": {
                  "description": "A bookmark to pass in for pagination. \"\" for first request.",
                  "type": "string"
                },
                "oldestFirst": {
                  "description": "If defined, we will return the oldest items first.",
                  "type": "boolean"
                },
                "address": {
                  "description": "If specified, we will only fetch this users' activity.",
                  "type": "string"
                },
                "tokenId": {
                  "description": "IF specified, we will filter to this abdge ID (only applicable to utiity listings view currently)",
                  "$ref": "#/components/schemas/NumberType"
                }
              },
              "required": [
                "viewType",
                "viewId",
                "bookmark"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "If present, the specified views will be fetched.",
            "type": "array"
          },
          "fetchTotalBalances": {
            "description": "If true, the total and mint balances will be fetched and will be put in owners[].\n\ncollection.owners.find(x => x.bitbadgesAddresss === 'Mint')",
            "type": "boolean"
          },
          "challengeTrackersToFetch": {
            "items": {
              "$ref": "#/components/schemas/iChallengeTrackerIdDetails"
            },
            "description": "If present, the merkle challenge trackers corresponding to the specified merkle challenge IDs will be fetched.",
            "type": "array"
          },
          "disableDefaults": {
            "description": "Disable appending default approvals.",
            "type": "boolean"
          },
          "approvalTrackersToFetch": {
            "items": {
              "$ref": "#/components/schemas/iAmountTrackerIdDetails"
            },
            "description": "If present, the approvals trackers corresponding to the specified approvals tracker IDs will be fetched.",
            "type": "array"
          },
          "fetchPrivateParams": {
            "description": "Fetches private parameters for any claims in addition to public parameters.",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "description": "Defines the options for fetching additional collection details.\n\nA view is a way of fetching additional details about a collection, and these will be queryable in the response via the `views` property.\nEach view has a bookmark that is used for pagination and must be supplied to get the next page.\nIf the bookmark is not supplied, the first page will be returned.",
        "type": "object"
      },
      "GetMetadataForCollectionPayload": {
        "properties": {
          "metadataToFetch": {
            "description": "If present, we will fetch the metadata corresponding to the specified options.\n\nConsider using pruneMetadataToFetch for filtering out previously fetched metadata.",
            "$ref": "#/components/schemas/MetadataFetchOptions"
          },
          "tokenFloorPricesToFetch": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/iUintRange"
                },
                "type": "array"
              }
            ],
            "description": "If present, we will fetch the floor price for the specified token IDs."
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "GetCollectionRequestBody": {
        "properties": {
          "viewsToFetch": {
            "items": {
              "properties": {
                "viewType": {
                  "$ref": "#/components/schemas/CollectionViewKey",
                  "description": "The base view type to fetch.",
                  "examples": [
                    "viewKey"
                  ]
                },
                "viewId": {
                  "description": "A unique view ID. This is used for pagination. All fetches w/ same ID should be made with same criteria.",
                  "type": "string",
                  "examples": [
                    "viewKey"
                  ]
                },
                "bookmark": {
                  "description": "A bookmark to pass in for pagination. \"\" for first request.",
                  "type": "string"
                },
                "oldestFirst": {
                  "description": "If defined, we will return the oldest items first.",
                  "type": "boolean"
                },
                "address": {
                  "description": "If specified, we will only fetch this users' activity.",
                  "type": "string"
                },
                "tokenId": {
                  "description": "IF specified, we will filter to this abdge ID (only applicable to utiity listings view currently)",
                  "$ref": "#/components/schemas/NumberType"
                }
              },
              "required": [
                "viewType",
                "viewId",
                "bookmark"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "If present, the specified views will be fetched.",
            "type": "array"
          },
          "fetchTotalBalances": {
            "description": "If true, the total and mint balances will be fetched and will be put in owners[].\n\ncollection.owners.find(x => x.bitbadgesAddresss === 'Mint')",
            "type": "boolean"
          },
          "challengeTrackersToFetch": {
            "items": {
              "$ref": "#/components/schemas/iChallengeTrackerIdDetails"
            },
            "description": "If present, the merkle challenge trackers corresponding to the specified merkle challenge IDs will be fetched.",
            "type": "array"
          },
          "disableDefaults": {
            "description": "Disable appending default approvals.",
            "type": "boolean"
          },
          "approvalTrackersToFetch": {
            "items": {
              "$ref": "#/components/schemas/iAmountTrackerIdDetails"
            },
            "description": "If present, the approvals trackers corresponding to the specified approvals tracker IDs will be fetched.",
            "type": "array"
          },
          "fetchPrivateParams": {
            "description": "Fetches private parameters for any claims in addition to public parameters.",
            "type": "boolean"
          },
          "metadataToFetch": {
            "description": "If present, we will fetch the metadata corresponding to the specified options.\n\nConsider using pruneMetadataToFetch for filtering out previously fetched metadata.",
            "$ref": "#/components/schemas/MetadataFetchOptions"
          },
          "tokenFloorPricesToFetch": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/iUintRange"
                },
                "type": "array"
              }
            ],
            "description": "If present, we will fetch the floor price for the specified token IDs."
          },
          "collectionId": {
            "$ref": "#/components/schemas/CollectionId"
          }
        },
        "required": [
          "collectionId"
        ],
        "additionalProperties": false,
        "description": "\nDefines the options for fetching additional collection details.\n\nA view is a way of fetching additional details about a collection, and these will be queryable in the response via the `views` property.\nEach view has a bookmark that is used for pagination and must be supplied to get the next page.\nIf the bookmark is not supplied, the first page will be returned.",
        "type": "object"
      },
      "iRefreshMetadataPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iRefreshMetadataSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iRefreshStatusPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iRefreshStatusSuccessResponse": {
        "properties": {
          "inQueue": {
            "description": "Boolean indicating if the collection is currently in the queue.",
            "type": "boolean"
          },
          "errorDocs": {
            "items": {
              "$ref": "#/components/schemas/iQueueDoc"
            },
            "description": "Array of error documents corresponding to the collection.",
            "type": "array"
          },
          "refreshDoc": {
            "description": "The status information corresponding to the collection.",
            "$ref": "#/components/schemas/iRefreshDoc"
          }
        },
        "required": [
          "inQueue",
          "errorDocs",
          "refreshDoc"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "DeliverTxResponse": {
        "properties": {
          "height": {
            "type": "number"
          },
          "txIndex": {
            "description": "The position of the transaction within the block. This is a 0-based index.",
            "type": "number"
          },
          "code": {
            "description": "Error code. The transaction suceeded if and only if code is 0.",
            "type": "number"
          },
          "transactionHash": {
            "type": "string"
          },
          "events": {},
          "rawLog": {
            "description": "A string-based log document.\n\nThis currently seems to merge attributes of multiple events into one event per type\n(https://github.com/tendermint/tendermint/issues/9595). You might want to use the `events`\nfield instead.\n@deprecated This field is not filled anymore in Cosmos SDK 0.50+ (https://github.com/cosmos/cosmos-sdk/pull/15845).\nPlease consider using `events` instead.",
            "type": "string"
          },
          "data": {
            "description": "@deprecated Use `msgResponses` instead."
          },
          "msgResponses": {
            "items": {
              "properties": {
                "typeUrl": {
                  "type": "string"
                },
                "value": {}
              },
              "required": [
                "typeUrl",
                "value"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "The message responses of the [TxMsgData](https://github.com/cosmos/cosmos-sdk/blob/v0.46.3/proto/cosmos/base/abci/v1beta1/abci.proto#L128-L140)\nas `Any`s.\nThis field is an empty list for chains running Cosmos SDK < 0.46.",
            "type": "array"
          },
          "gasUsed": {},
          "gasWanted": {}
        },
        "required": [
          "height",
          "txIndex",
          "code",
          "transactionHash",
          "events",
          "msgResponses",
          "gasUsed",
          "gasWanted"
        ],
        "additionalProperties": false,
        "description": "The response after successfully broadcasting a transaction.\nSuccess or failure refer to the execution result.",
        "type": "object"
      },
      "Attribute": {
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "key",
          "value"
        ],
        "additionalProperties": false,
        "description": "An event attribute.\n\nThis is the same attribute type as tendermint34.Attribute and tendermint35.EventAttribute\nbut `key` and `value` are unified to strings. The conversion\nfrom bytes to string in the Tendermint 0.34 case should be done by performing\n[lossy] UTF-8 decoding.\n\n[lossy]: https://doc.rust-lang.org/stable/std/string/struct.String.html#method.from_utf8_lossy",
        "type": "object"
      },
      "CosmosEvent": {
        "properties": {
          "type": {
            "type": "string"
          },
          "attributes": {}
        },
        "required": [
          "type",
          "attributes"
        ],
        "additionalProperties": false,
        "description": "The same event type as tendermint34.Event and tendermint35.Event\nbut attribute keys and values are unified to strings. The conversion\nfrom bytes to string in the Tendermint 0.34 case should be done by performing\n[lossy] UTF-8 decoding.\n\n[lossy]: https://doc.rust-lang.org/stable/std/string/struct.String.html#method.from_utf8_lossy",
        "type": "object"
      },
      "iGetStatusPayload": {
        "properties": {
          "withOutOfSyncCheck": {
            "description": "If true, we will check if the indexer is out of sync with the blockchain.",
            "type": "boolean"
          },
          "chain": {
            "enum": [
              "Thorchain",
              "BitBadges"
            ],
            "description": "Chain to check? Defaults to BitBadges poller.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetStatusSuccessResponse": {
        "properties": {
          "status": {
            "description": "Status details about the indexer / blockchain.",
            "$ref": "#/components/schemas/iStatusDoc"
          },
          "outOfSync": {
            "description": "If true, we are out of sync with the blockchain.\nIf undefined, we did not check for out of sync.",
            "type": "boolean"
          },
          "prices": {
            "description": "Prices for the assets"
          }
        },
        "required": [
          "status"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetSearchPayload": {
        "properties": {
          "noCollections": {
            "description": "If true, we will skip all collection queries.",
            "type": "boolean"
          },
          "noAccounts": {
            "description": "If true, we will skip all account queries.",
            "type": "boolean"
          },
          "noTokens": {
            "description": "If true, we will skip all badge queries.",
            "type": "boolean"
          },
          "noMaps": {
            "description": "If true, we will skip all map queries.",
            "type": "boolean"
          },
          "noApplications": {
            "description": "If true, we will skip all application queries.",
            "type": "boolean"
          },
          "noClaims": {
            "description": "If true, we will skip all claim queries.",
            "type": "boolean"
          },
          "specificCollectionId": {
            "description": "If true, we will limit collection-based results to a single collection.",
            "$ref": "#/components/schemas/CollectionId"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetSearchSuccessResponse": {
        "properties": {
          "collections": {
            "items": {
              "$ref": "#/components/schemas/iBitBadgesCollection"
            },
            "type": "array"
          },
          "accounts": {
            "items": {
              "$ref": "#/components/schemas/iBitBadgesUserInfo"
            },
            "type": "array"
          },
          "tokens": {
            "items": {
              "properties": {
                "collection": {
                  "$ref": "#/components/schemas/iBitBadgesCollection"
                },
                "tokenIds": {
                  "items": {
                    "$ref": "#/components/schemas/iUintRange"
                  },
                  "type": "array",
                  "examples": [
                    [
                      {
                        "start": "1",
                        "end": "10"
                      }
                    ]
                  ]
                }
              },
              "required": [
                "collection",
                "tokenIds"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "maps": {
            "items": {
              "$ref": "#/components/schemas/iMapWithValues"
            },
            "type": "array"
          },
          "applications": {
            "items": {
              "$ref": "#/components/schemas/iApplicationDoc"
            },
            "type": "array"
          },
          "claims": {
            "items": {
              "$ref": "#/components/schemas/iClaimDetails"
            },
            "type": "array"
          },
          "utilityPages": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageDoc"
            },
            "type": "array"
          }
        },
        "required": [
          "collections",
          "accounts",
          "tokens",
          "maps"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchClaimsPayload": {
        "properties": {
          "bookmark": {
            "description": "Bookmark to start from. Obtained from previous request. Leave blank to start from the beginning. Only applicable when no additional criteria is specified.",
            "type": "string"
          },
          "fetchPrivateParams": {
            "description": "Fetch private parameters for the claim. Only applicable if you are the creator / manager of the claim. Otherwise, it will be the public read-only view.",
            "type": "boolean"
          },
          "searchValue": {
            "description": "If provided, we will only return claims with names that regex match the search value.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimsPayload": {
        "properties": {
          "claimIds": {
            "items": {
              "type": "string"
            },
            "description": "The claim IDs to fetch.",
            "type": "array"
          },
          "fetchPrivateParams": {
            "description": "Fetch private parameters for the claim. Only applicable if you are the creator / manager of the claim.",
            "type": "boolean"
          },
          "privateStatesToFetch": {
            "items": {
              "properties": {
                "claimId": {
                  "type": "string"
                },
                "instanceId": {
                  "type": "string"
                }
              },
              "required": [
                "claimId",
                "instanceId"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "Which private state instance IDs to fetch. claimId and instanceId are required and must match a claimId in claimIds and the claim must have the corresponding instanceId.",
            "type": "array"
          },
          "fetchAllClaimedUsers": {
            "description": "Fetch all claimed users for the claim. If true, you will be able to find all { [bitbadgesAddress]: [...zeroIndexedClaimNumbers] }\non the numUses plugin's publicState.",
            "type": "boolean"
          }
        },
        "required": [
          "claimIds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimsPayloadV1": {
        "properties": {
          "claimsToFetch": {
            "items": {
              "properties": {
                "claimId": {
                  "description": "The claim ID to fetch.",
                  "type": "string"
                },
                "privateStatesToFetch": {
                  "items": {
                    "type": "string"
                  },
                  "description": "The private state instance IDs to fetch. By default, we do not fetch any private states.",
                  "type": "array"
                },
                "fetchAllClaimedUsers": {
                  "description": "Fetch all claimed users for the claim. If true, you will be able to find all { [bitbadgesAddress]: [...zeroIndexedClaimNumbers] }\non the numUses plugin's publicState.",
                  "type": "boolean"
                },
                "fetchPrivateParams": {
                  "description": "Fetch private parameters for the claim. Only applicable if you are the creator / manager of the claim.",
                  "type": "boolean"
                }
              },
              "required": [
                "claimId"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "The claims to fetch.",
            "type": "array"
          }
        },
        "required": [
          "claimsToFetch"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimsSuccessResponse": {
        "properties": {
          "claims": {
            "items": {
              "$ref": "#/components/schemas/iClaimDetails"
            },
            "type": "array"
          },
          "bookmark": {
            "type": "string"
          }
        },
        "required": [
          "claims"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimPayload": {
        "properties": {
          "fetchPrivateParams": {
            "description": "Fetch private parameters for the claim. Only applicable if you are the creator / manager of the claim.",
            "type": "boolean"
          },
          "fetchAllClaimedUsers": {
            "description": "Fetch all claimed users for the claim.  If true, you will be able to find all { [bitbadgesAddress]: [...zeroIndexedClaimNumbers] }\non the numUses plugin's publicState.",
            "type": "boolean"
          },
          "privateStatesToFetch": {
            "items": {
              "type": "string"
            },
            "description": "The private state instance IDs to fetch. By default, we do not fetch any private states.",
            "type": "array"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimSuccessResponse": {
        "properties": {
          "claim": {
            "$ref": "#/components/schemas/iClaimDetails"
          }
        },
        "required": [
          "claim"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchClaimsSuccessResponse": {
        "properties": {
          "claims": {
            "items": {
              "$ref": "#/components/schemas/iClaimDetails"
            },
            "type": "array"
          },
          "bookmark": {
            "type": "string"
          }
        },
        "required": [
          "claims"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCompleteClaimPayload": {
        "properties": {
          "_expectedVersion": {
            "description": "Needs to be provided so we check that no plugins or claims have been updated since the claim was fetched. To override, set to -1.",
            "type": "number"
          },
          "_specificInstanceIds": {
            "items": {
              "type": "string"
            },
            "description": "If provided, we will only complete the claim for the specific plugins w/ the provided instance IDs. Must be compatible with the satisfaction logic.",
            "type": "array"
          }
        },
        "required": [
          "_expectedVersion"
        ],
        "additionalProperties": {},
        "type": "object"
      },
      "iCompleteClaimSuccessResponse": {
        "properties": {
          "claimAttemptId": {
            "description": "The transaction ID to track the claim.",
            "type": "string"
          }
        },
        "required": [
          "claimAttemptId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimAttemptStatusPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimAttemptStatusSuccessResponse": {
        "properties": {
          "success": {
            "type": "boolean"
          },
          "error": {
            "type": "string"
          },
          "code": {
            "description": "The code for the on-chain transaction. Only provided if you have permissions and this is an on-chain token claim.",
            "type": "string"
          },
          "bitbadgesAddress": {
            "type": "string",
            "examples": [
              "bb1..."
            ]
          }
        },
        "required": [
          "success",
          "error",
          "bitbadgesAddress"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimAttemptsPayload": {
        "properties": {
          "bookmark": {
            "description": "The bookmark to start from.",
            "type": "string"
          },
          "includeErrors": {
            "description": "Whether to include errors or not.",
            "type": "boolean"
          },
          "address": {
            "description": "The specific address to fetch claims for. If blank, we fetch most recent claims.",
            "$ref": "#/components/schemas/NativeAddress"
          },
          "includeRequestBinAttemptData": {
            "description": "Include the cached payload data for requestBin plugin. Must be claim creator to view.\n\nYou can also use the individual GET route to fetch this data.",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetClaimAttemptsSuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "properties": {
                "success": {
                  "type": "boolean"
                },
                "attemptedAt": {
                  "$ref": "#/components/schemas/UNIXMilliTimestamp"
                },
                "claimId": {
                  "type": "string"
                },
                "bitbadgesAddress": {
                  "$ref": "#/components/schemas/NativeAddress",
                  "examples": [
                    "bb1..."
                  ]
                },
                "claimAttemptId": {
                  "type": "string"
                },
                "claimNumber": {
                  "description": "Zero-based index claim number",
                  "type": "number"
                },
                "error": {
                  "type": "string"
                },
                "attemptData": {
                  "additionalProperties": {},
                  "description": "This is in the format of { [instanceId: string]: Record<string, any> }\nwhere the object is what was configured via the plugin.",
                  "type": "object"
                }
              },
              "required": [
                "success",
                "attemptedAt",
                "claimId",
                "bitbadgesAddress",
                "claimAttemptId",
                "claimNumber"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "bookmark": {
            "type": "string"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "docs"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iClaimAttempt": {
        "properties": {
          "success": {
            "type": "boolean"
          },
          "attemptedAt": {
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "claimId": {
            "type": "string"
          },
          "bitbadgesAddress": {
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/NativeAddress"
          },
          "claimAttemptId": {
            "type": "string"
          },
          "claimNumber": {
            "type": "number"
          },
          "error": {
            "type": "string"
          },
          "attemptData": {
            "additionalProperties": {},
            "description": "This is in the format of { [instanceId: string]: Record<string, any> }\nwhere the object is what was configured via the plugin.\n\nThe instanceId is for the requestBin plugin's instance ID.",
            "type": "object"
          }
        },
        "required": [
          "success",
          "attemptedAt",
          "claimId",
          "bitbadgesAddress",
          "claimAttemptId",
          "claimNumber"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSimulateClaimPayload": {
        "properties": {
          "_expectedVersion": {
            "description": "Will fail if the claim version is not the expected version. To override, set to -1.",
            "type": "number"
          },
          "_specificInstanceIds": {
            "items": {
              "type": "string"
            },
            "description": "If provided, we will only simulate the claim for the specific plugins w/ the provided instance IDs.",
            "type": "array"
          }
        },
        "required": [
          "_expectedVersion"
        ],
        "additionalProperties": {},
        "type": "object"
      },
      "iSimulateClaimSuccessResponse": {
        "properties": {
          "claimAttemptId": {
            "description": "The transaction ID to track the claim. This is just a simulated value for compatibility purposes.",
            "type": "string"
          }
        },
        "required": [
          "claimAttemptId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetReservedClaimCodesPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetReservedClaimCodesSuccessResponse": {
        "properties": {
          "reservedCodes": {
            "items": {
              "type": "string"
            },
            "description": "The previously reserved claim codes for the user. These are\nwhat are used in the eventual on-chain merkle proof to complete\nthe transaction.",
            "type": "array"
          },
          "leafSignatures": {
            "items": {
              "type": "string"
            },
            "description": "The leaf signatures for the reserved claim codes to prove address <-> leaf mapping.",
            "type": "array"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateAccountInfoPayload": {
        "properties": {
          "discord": {
            "description": "The Discord username.",
            "type": "string"
          },
          "twitter": {
            "description": "The Twitter username.",
            "type": "string"
          },
          "github": {
            "description": "The GitHub username.",
            "type": "string"
          },
          "telegram": {
            "description": "The Telegram username.",
            "type": "string"
          },
          "bluesky": {
            "description": "The Bluesky username.",
            "type": "string"
          },
          "affiliateCode": {
            "description": "The affiliate code of the referrer  that sent them?",
            "type": "string"
          },
          "seenActivity": {
            "description": "The last seen activity timestamp.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "readme": {
            "description": "The README details (markdown supported).",
            "type": "string"
          },
          "hiddenTokens": {
            "items": {
              "$ref": "#/components/schemas/iBatchTokenDetails"
            },
            "description": "The tokens to hide and not view for this profile's portfolio",
            "type": "array"
          },
          "profilePicUrl": {
            "description": "The profile picture URL.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "bannerImage": {
            "description": "The banner image URL.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "username": {
            "description": "The username.",
            "type": "string"
          },
          "profilePicImageFile": {
            "description": "The profile picture image file to set. We will then upload to our CDN."
          },
          "notifications": {
            "properties": {
              "email": {
                "type": "string"
              },
              "discord": {
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "username": {
                    "type": "string"
                  },
                  "discriminator": {
                    "type": "string"
                  }
                },
                "required": [
                  "id",
                  "username",
                  "discriminator"
                ],
                "additionalProperties": false,
                "type": "object"
              },
              "antiPhishingCode": {
                "type": "string"
              },
              "preferences": {
                "properties": {
                  "transferActivity": {
                    "type": "boolean"
                  },
                  "ignoreIfInitiator": {
                    "type": "boolean"
                  },
                  "signInAlertsEnabled": {
                    "type": "boolean"
                  }
                },
                "additionalProperties": false,
                "type": "object"
              }
            },
            "additionalProperties": false,
            "description": "The notification preferences for the user. Will only be returned if user is authenticated with full access.",
            "type": "object"
          },
          "socialConnections": {
            "description": "The social connections for the user. Only returned if user is authenticated with full access.",
            "$ref": "#/components/schemas/iSocialConnections"
          },
          "publicSocialConnectionsToSet": {
            "items": {
              "properties": {
                "appName": {
                  "type": "string"
                },
                "toDelete": {
                  "type": "boolean"
                }
              },
              "required": [
                "appName"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "The public social connections for the user. Will be returned for all queries and may be publicly displayed on profile",
            "type": "array"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateAccountInfoSuccessResponse": {
        "properties": {
          "verificationEmailSent": {
            "description": "Verificatiom email sent?",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetAttemptDataFromRequestBinPayload": {
        "properties": {
          "instanceId": {
            "description": "The instance ID of the request bin plugin.\n\nOnly needed if there are duplicates. Else, we default to first instance found.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetAttemptDataFromRequestBinSuccessResponse": {
        "properties": {
          "payload": {
            "description": "The attempt payload we cached. This will be in the format configured for the request bin plugin."
          }
        },
        "required": [
          "payload"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAddToIpfsPayload": {
        "properties": {
          "contents": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/iTokenMetadataDetails"
                },
                {
                  "$ref": "#/components/schemas/iMetadata"
                },
                {
                  "$ref": "#/components/schemas/iCollectionMetadataDetails"
                },
                {
                  "$ref": "#/components/schemas/iChallengeDetails"
                }
              ]
            },
            "description": "The stuff to add to IPFS",
            "type": "array"
          },
          "method": {
            "enum": [
              "ipfs",
              "centralized"
            ],
            "type": "string"
          }
        },
        "required": [
          "method"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAddToIpfsSuccessResponse": {
        "properties": {
          "results": {
            "items": {
              "properties": {
                "cid": {
                  "type": "string"
                },
                "uri": {
                  "type": "string",
                  "examples": [
                    "https://example.com",
                    "ipfs://Qm..."
                  ]
                }
              },
              "required": [
                "cid"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "An array of token metadata results, if applicable.",
            "type": "array"
          }
        },
        "required": [
          "results"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAddApprovalDetailsToOffChainStoragePayload": {
        "properties": {
          "approvalDetails": {
            "items": {
              "properties": {
                "name": {
                  "description": "The name of the approval.",
                  "type": "string",
                  "examples": [
                    "Name"
                  ]
                },
                "description": {
                  "description": "The description of the approval.",
                  "type": "string",
                  "examples": [
                    "Brief description."
                  ]
                },
                "image": {
                  "description": "The image of the approval.",
                  "type": "string",
                  "examples": [
                    "https://example.com/image.png",
                    "ipfs://Qm..."
                  ]
                },
                "challengeInfoDetails": {
                  "items": {
                    "$ref": "#/components/schemas/iChallengeInfoDetailsUpdate"
                  },
                  "description": "For any merkle challenge claims that we are implementing",
                  "type": "array"
                }
              },
              "required": [
                "name",
                "description",
                "image"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "approvalDetails"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAddApprovalDetailsToOffChainStorageSuccessResponse": {
        "properties": {
          "approvalResults": {
            "items": {
              "properties": {
                "metadataResult": {
                  "properties": {
                    "cid": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "cid"
                  ],
                  "additionalProperties": false,
                  "description": "The result for name / description (if applicable).",
                  "type": "object"
                },
                "challengeResults": {
                  "items": {
                    "properties": {
                      "cid": {
                        "type": "string"
                      }
                    },
                    "required": [
                      "cid"
                    ],
                    "additionalProperties": false,
                    "type": "object"
                  },
                  "description": "The result for the approval challenge details (if applicable).",
                  "type": "array"
                }
              },
              "required": [
                "metadataResult"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "approvalResults"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetSignInChallengePayload": {
        "properties": {
          "chain": {
            "description": "The blockchain to be signed in with.",
            "$ref": "#/components/schemas/SupportedChain"
          },
          "address": {
            "description": "The user's blockchain address. This can be their native address.",
            "$ref": "#/components/schemas/NativeAddress"
          }
        },
        "required": [
          "chain",
          "address"
        ],
        "additionalProperties": false,
        "description": "",
        "type": "object"
      },
      "iGetSignInChallengeSuccessResponse": {
        "properties": {
          "nonce": {
            "description": "The nonce for the challenge.",
            "type": "string"
          },
          "params": {
            "description": "The challenge parameters.",
            "$ref": "#/components/schemas/ChallengeParams"
          },
          "message": {
            "description": "The challenge message to sign.",
            "$ref": "#/components/schemas/SiwbbMessage"
          }
        },
        "required": [
          "nonce",
          "params",
          "message"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iVerifySignInPayload": {
        "properties": {
          "message": {
            "description": "The original message that was signed.",
            "$ref": "#/components/schemas/SiwbbMessage"
          },
          "signature": {
            "description": "The signature of the message",
            "type": "string",
            "examples": [
              "0x...",
              "8d42172..."
            ]
          },
          "publicKey": {
            "description": "Required for some chains (Cosmos) to verify signature. The public key of the signer.",
            "type": "string",
            "examples": [
              "AksB.... (base64)"
            ]
          }
        },
        "required": [
          "message",
          "signature"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iVerifySignInSuccessResponse": {
        "properties": {
          "requires2FA": {
            "description": "True if 2FA is set up and verification is required.",
            "type": "boolean"
          },
          "message": {
            "description": "Message indicating 2FA is required.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iCheckSignInStatusPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iCheckSignInStatusSuccessResponse": {
        "properties": {
          "signedIn": {
            "description": "Indicates whether the user is signed in.",
            "type": "boolean"
          },
          "address": {
            "$ref": "#/components/schemas/NativeAddress"
          },
          "bitbadgesAddress": {
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "chain": {
            "$ref": "#/components/schemas/SupportedChain"
          },
          "scopes": {
            "items": {
              "$ref": "#/components/schemas/OAuthScopeDetailsWithId"
            },
            "description": "Approved scopes",
            "type": "array"
          },
          "message": {
            "description": "The message that was signed.",
            "$ref": "#/components/schemas/SiwbbMessage"
          },
          "email": {
            "description": "The email of the session.",
            "type": "string"
          },
          "discord": {
            "properties": {
              "username": {
                "type": "string"
              },
              "discriminator": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "discriminator",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Discord username and discriminator?",
            "type": "object"
          },
          "twitter": {
            "properties": {
              "id": {
                "type": "string"
              },
              "username": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "username"
            ],
            "additionalProperties": false,
            "description": "Signed in with Twitter username?",
            "type": "object"
          },
          "github": {
            "properties": {
              "id": {
                "type": "string"
              },
              "username": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "username"
            ],
            "additionalProperties": false,
            "description": "Signed in with GitHub username?",
            "type": "object"
          },
          "google": {
            "properties": {
              "id": {
                "type": "string"
              },
              "username": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "username"
            ],
            "additionalProperties": false,
            "description": "Signed in with Google username?",
            "type": "object"
          },
          "twitch": {
            "properties": {
              "id": {
                "type": "string"
              },
              "username": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "username"
            ],
            "additionalProperties": false,
            "description": "Signed in with Twitch?",
            "type": "object"
          },
          "strava": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Strava?",
            "type": "object"
          },
          "reddit": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Reddit?",
            "type": "object"
          },
          "meetup": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Meetup?",
            "type": "object"
          },
          "bluesky": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Bluesky?",
            "type": "object"
          },
          "mailchimp": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Mailchimp?",
            "type": "object"
          },
          "facebook": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Facebook?",
            "type": "object"
          },
          "linkedIn": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with LinkedIn?",
            "type": "object"
          },
          "shopify": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Shopify?",
            "type": "object"
          },
          "telegram": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Telegram?",
            "type": "object"
          },
          "farcaster": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Farcaster?",
            "type": "object"
          },
          "slack": {
            "properties": {
              "username": {
                "type": "string"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "username",
              "id"
            ],
            "additionalProperties": false,
            "description": "Signed in with Slack?",
            "type": "object"
          },
          "youtube": {
            "properties": {
              "id": {
                "type": "string"
              },
              "username": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "username"
            ],
            "additionalProperties": false,
            "description": "Signed in with Youtube?",
            "type": "object"
          },
          "googleCalendar": {
            "properties": {
              "id": {
                "type": "string"
              },
              "username": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "username"
            ],
            "additionalProperties": false,
            "description": "Signed in with Google Calendar?",
            "type": "object"
          },
          "twoFAVerified": {
            "description": "True if 2FA is verified in session.",
            "type": "boolean"
          },
          "requires2FA": {
            "description": "True if 2FA is set up but not verified.",
            "type": "boolean"
          },
          "twoFAVerifiedAt": {
            "description": "Timestamp when 2FA was verified.",
            "type": "number"
          }
        },
        "required": [
          "signedIn",
          "address",
          "bitbadgesAddress",
          "chain",
          "scopes",
          "message"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "OAuthScopeDetailsWithId": {
        "properties": {
          "scopeName": {
            "description": "The name of the scope. Note: For this, we use the capitalized version of the scope name with spaces.\n\nFor example, \"completeClaims\" becomes \"Complete Claims\"",
            "type": "string"
          },
          "options": {
            "description": "The options for the scope. Currently, this is not used.",
            "type": "object"
          },
          "scopeId": {
            "description": "Camel case version of the scope name.",
            "type": "string"
          }
        },
        "required": [
          "scopeName",
          "scopeId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSignOutPayload": {
        "properties": {
          "signOutBlockin": {
            "description": "Sign out of Blockin, and thus the entire API.",
            "type": "boolean"
          },
          "signOutDiscord": {
            "description": "Sign out of Discord.",
            "type": "boolean"
          },
          "signOutTwitter": {
            "description": "Sign out of Twitter.",
            "type": "boolean"
          },
          "signOutGoogle": {
            "description": "Sign out of Google.",
            "type": "boolean"
          },
          "signOutGithub": {
            "description": "Sign out of GitHub.",
            "type": "boolean"
          },
          "signOutTwitch": {
            "description": "Sign out of Twitch.",
            "type": "boolean"
          },
          "signOutStrava": {
            "description": "Sign out of Strava.",
            "type": "boolean"
          },
          "signOutYoutube": {
            "description": "Sign out of Youtube",
            "type": "boolean"
          },
          "signOutReddit": {
            "description": "Sign out of Reddit",
            "type": "boolean"
          },
          "signOutMeetup": {
            "description": "Sign out of Meetup",
            "type": "boolean"
          },
          "signOutBluesky": {
            "description": "Sign out of Bluesky",
            "type": "boolean"
          },
          "signOutMailchimp": {
            "description": "Sign out of Mailchimp",
            "type": "boolean"
          },
          "signOutGoogleCalendar": {
            "description": "Sign out of Google Calendar",
            "type": "boolean"
          },
          "signOutTelegram": {
            "description": "Sign out of Telegram",
            "type": "boolean"
          },
          "signOutFarcaster": {
            "description": "Sign out of Farcaster",
            "type": "boolean"
          },
          "signOutSlack": {
            "description": "Sign out of Slack",
            "type": "boolean"
          },
          "signOutEmail": {
            "description": "Sign out of email",
            "type": "boolean"
          },
          "signOutFacebook": {
            "description": "Sign out of Facebook",
            "type": "boolean"
          },
          "signOutLinkedIn": {
            "description": "Sign out of LinkedIn",
            "type": "boolean"
          },
          "signOutShopify": {
            "description": "Sign out of Shopify",
            "type": "boolean"
          }
        },
        "required": [
          "signOutBlockin"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSignOutSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetBrowsePayload": {
        "properties": {
          "type": {
            "enum": [
              "collections",
              "tokens",
              "addressLists",
              "maps",
              "claims",
              "activity",
              "utilityPages",
              "applications",
              "claimActivity",
              "pointsActivity"
            ],
            "type": "string"
          },
          "category": {
            "type": "string"
          },
          "sortBy": {
            "type": "string"
          },
          "timeFrame": {
            "type": "string"
          },
          "searchTerm": {
            "type": "string"
          },
          "locale": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetBrowseSuccessResponse": {
        "properties": {
          "collections": {
            "additionalProperties": {
              "items": {
                "$ref": "#/components/schemas/iBitBadgesCollection"
              },
              "type": "array"
            },
            "type": "object"
          },
          "profiles": {
            "additionalProperties": {
              "items": {
                "$ref": "#/components/schemas/iBitBadgesUserInfo"
              },
              "type": "array"
            },
            "type": "object"
          },
          "activity": {
            "items": {
              "$ref": "#/components/schemas/iTransferActivityDoc"
            },
            "type": "array"
          },
          "tokens": {
            "additionalProperties": {
              "items": {
                "properties": {
                  "collection": {
                    "$ref": "#/components/schemas/iBitBadgesCollection"
                  },
                  "tokenIds": {
                    "items": {
                      "$ref": "#/components/schemas/iUintRange"
                    },
                    "type": "array",
                    "examples": [
                      [
                        {
                          "start": "1",
                          "end": "10"
                        }
                      ]
                    ]
                  }
                },
                "required": [
                  "collection",
                  "tokenIds"
                ],
                "additionalProperties": false,
                "type": "object"
              },
              "type": "array"
            },
            "type": "object"
          },
          "applications": {
            "additionalProperties": {
              "items": {
                "$ref": "#/components/schemas/iApplicationDoc"
              },
              "type": "array"
            },
            "type": "object"
          },
          "maps": {
            "additionalProperties": {
              "items": {
                "$ref": "#/components/schemas/iMapWithValues"
              },
              "type": "array"
            },
            "type": "object"
          },
          "claims": {
            "additionalProperties": {
              "items": {
                "$ref": "#/components/schemas/iClaimDetails"
              },
              "type": "array"
            },
            "type": "object"
          },
          "claimActivity": {
            "items": {
              "$ref": "#/components/schemas/iClaimActivityDoc"
            },
            "type": "array"
          },
          "pointsActivity": {
            "items": {
              "$ref": "#/components/schemas/iPointsActivityDoc"
            },
            "type": "array"
          },
          "utilityPages": {
            "additionalProperties": {
              "items": {
                "$ref": "#/components/schemas/iUtilityPageDoc"
              },
              "type": "array"
            },
            "type": "object"
          }
        },
        "required": [
          "collections",
          "profiles",
          "activity",
          "tokens",
          "maps"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iBroadcastTxPayload": {
        "$ref": "#/components/schemas/BroadcastPostBody"
      },
      "iBroadcastTxSuccessResponse": {
        "properties": {
          "tx_response": {
            "properties": {
              "code": {
                "type": "number"
              },
              "codespace": {
                "type": "string"
              },
              "data": {
                "type": "string"
              },
              "events": {
                "items": {
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "attributes": {
                      "items": {
                        "properties": {
                          "key": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          },
                          "index": {
                            "type": "boolean"
                          }
                        },
                        "required": [
                          "key",
                          "value",
                          "index"
                        ],
                        "additionalProperties": false,
                        "type": "object"
                      },
                      "type": "array"
                    }
                  },
                  "required": [
                    "type",
                    "attributes"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              },
              "gas_wanted": {
                "type": "string"
              },
              "gas_used": {
                "type": "string"
              },
              "height": {
                "type": "string"
              },
              "logs": {
                "items": {
                  "properties": {
                    "events": {
                      "items": {
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "attributes": {
                            "items": {
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                },
                                "index": {
                                  "type": "boolean"
                                }
                              },
                              "required": [
                                "key",
                                "value",
                                "index"
                              ],
                              "additionalProperties": false,
                              "type": "object"
                            },
                            "type": "array"
                          }
                        },
                        "required": [
                          "type",
                          "attributes"
                        ],
                        "additionalProperties": false,
                        "type": "object"
                      },
                      "type": "array"
                    }
                  },
                  "required": [
                    "events"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              },
              "raw_log": {
                "type": "string"
              },
              "timestamp": {
                "type": "string"
              },
              "tx": {
                "nullable": true,
                "type": "object"
              },
              "txhash": {
                "type": "string"
              }
            },
            "required": [
              "code",
              "codespace",
              "data",
              "events",
              "gas_wanted",
              "gas_used",
              "height",
              "logs",
              "raw_log",
              "timestamp",
              "tx",
              "txhash"
            ],
            "additionalProperties": false,
            "description": "The response from the blockchain for the broadcasted tx.",
            "type": "object"
          }
        },
        "required": [
          "tx_response"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSimulateTxPayload": {
        "$ref": "#/components/schemas/BroadcastPostBody"
      },
      "iSimulateTxSuccessResponse": {
        "properties": {
          "gas_info": {
            "properties": {
              "gas_used": {
                "type": "string"
              },
              "gas_wanted": {
                "type": "string"
              }
            },
            "required": [
              "gas_used",
              "gas_wanted"
            ],
            "additionalProperties": false,
            "description": "How much gas was used in the simulation.",
            "type": "object"
          },
          "result": {
            "properties": {
              "data": {
                "type": "string"
              },
              "log": {
                "type": "string"
              },
              "events": {
                "items": {
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "attributes": {
                      "items": {
                        "properties": {
                          "key": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          },
                          "index": {
                            "type": "boolean"
                          }
                        },
                        "required": [
                          "key",
                          "value",
                          "index"
                        ],
                        "additionalProperties": false,
                        "type": "object"
                      },
                      "type": "array"
                    }
                  },
                  "required": [
                    "type",
                    "attributes"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              }
            },
            "required": [
              "data",
              "log",
              "events"
            ],
            "additionalProperties": false,
            "description": "The result of the simulation.",
            "type": "object"
          }
        },
        "required": [
          "gas_info",
          "result"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iFetchMetadataDirectlyPayload": {
        "properties": {
          "uris": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "uris"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iFetchMetadataDirectlySuccessResponse": {
        "properties": {
          "metadata": {
            "items": {
              "$ref": "#/components/schemas/iMetadata"
            },
            "type": "array"
          }
        },
        "required": [
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTokensFromFaucetPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetTokensFromFaucetSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "CosmosAccountResponse": {
        "properties": {
          "account_number": {
            "type": "number"
          },
          "sequence": {
            "type": "number"
          },
          "pub_key": {
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "address": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "account_number",
          "sequence",
          "pub_key",
          "address"
        ],
        "additionalProperties": false,
        "description": "Information returned by the REST API getAccount route.\n\nNote this should be converted into AccountDoc or BitBadgesUserInfo before being returned by the BitBadges API for consistency.",
        "type": "object"
      },
      "iGenericVerifyAssetsPayload": {
        "properties": {
          "address": {
            "description": "The address to check",
            "$ref": "#/components/schemas/NativeAddress"
          },
          "assetOwnershipRequirements": {
            "description": "The asset requirements to verify.",
            "examples": [
              {
                "assets": [
                  {
                    "chain": "BitBadges",
                    "collectionId": "1",
                    "assetIds": [
                      {
                        "start": "1",
                        "end": "1"
                      }
                    ],
                    "mustOwnAmounts": {
                      "start": "1",
                      "end": "1"
                    },
                    "ownershipTimes": []
                  }
                ]
              }
            ],
            "$ref": "#/components/schemas/AssetConditionGroup"
          }
        },
        "required": [
          "address",
          "assetOwnershipRequirements"
        ],
        "additionalProperties": false,
        "description": "Generic route to verify any asset ownership requirements.",
        "type": "object"
      },
      "iGenericVerifyAssetsSuccessResponse": {
        "properties": {
          "success": {
            "description": "Success response of the verification check. Use this to determine if the verification was successful.\n\nStatus code will be 200 both if the user meets or does not meet requirements, so you must check this success field to determine the result.",
            "type": "boolean"
          },
          "errorMessage": {
            "type": "string"
          }
        },
        "required": [
          "success"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGenericBlockinVerifyPayload": {
        "properties": {
          "message": {
            "description": "The original message that was signed.",
            "$ref": "#/components/schemas/SiwbbMessage"
          },
          "signature": {
            "description": "The signature of the message",
            "type": "string",
            "examples": [
              "0x...",
              "8d42172..."
            ]
          },
          "publicKey": {
            "description": "Required for some chains (Cosmos) to verify signature. The public key of the signer.",
            "type": "string",
            "examples": [
              "AksB.... (base64)"
            ]
          },
          "options": {
            "description": "Additional options for verifying the challenge.",
            "$ref": "#/components/schemas/VerifyChallengeOptions"
          }
        },
        "required": [
          "message",
          "signature"
        ],
        "additionalProperties": false,
        "description": "Generic route to verify any SIWBB request. Does not sign you in with the API. Used for custom SIWBB implementations.",
        "type": "object"
      },
      "iGenericBlockinVerifySuccessResponse": {
        "properties": {
          "requires2FA": {
            "description": "True if 2FA is set up and verification is required.",
            "type": "boolean"
          },
          "message": {
            "description": "Message indicating 2FA is required.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "description": "",
        "type": "object"
      },
      "iCreateSIWBBRequestPayload": {
        "properties": {
          "response_type": {
            "description": "The response type for the SIWBB request.",
            "type": "string"
          },
          "scopes": {
            "items": {
              "$ref": "#/components/schemas/OAuthScopeDetails"
            },
            "description": "The scopes to request.",
            "type": "array"
          },
          "name": {
            "description": "The name of the SIWBB request for display purposes.",
            "type": "string",
            "examples": [
              "Name"
            ]
          },
          "description": {
            "description": "The description of the SIWBB request for display purposes.",
            "type": "string",
            "examples": [
              "Brief description."
            ]
          },
          "image": {
            "description": "The image of the SIWBB request for display purposes.",
            "type": "string",
            "examples": [
              "https://example.com/image.png",
              "ipfs://Qm..."
            ]
          },
          "client_id": {
            "description": "Client ID for the SIWBB request.",
            "type": "string"
          },
          "redirect_uri": {
            "description": "Redirect URI if redirected after successful sign-in.",
            "type": "string"
          },
          "state": {
            "description": "State to be passed back to the redirect URI.",
            "type": "string"
          },
          "code_challenge": {
            "description": "The code challenge for the SIWBB request.",
            "type": "string"
          },
          "code_challenge_method": {
            "enum": [
              "S256",
              "plain"
            ],
            "description": "The code challenge method for the SIWBB request.",
            "type": "string"
          }
        },
        "required": [
          "response_type",
          "scopes",
          "client_id"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateSIWBBRequestSuccessResponse": {
        "properties": {
          "code": {
            "description": "Secret code which can be exchanged for the SIWBB request details.",
            "type": "string"
          }
        },
        "required": [
          "code"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iRotateSIWBBRequestPayload": {
        "properties": {
          "code": {
            "description": "The code of the SIWBB request to rotate.",
            "type": "string"
          }
        },
        "required": [
          "code"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iRotateSIWBBRequestSuccessResponse": {
        "properties": {
          "code": {
            "description": "The new code for the SIWBB request.",
            "type": "string"
          }
        },
        "required": [
          "code"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetSIWBBRequestsForDeveloperAppPayload": {
        "properties": {
          "bookmark": {
            "description": "The bookmark for pagination.",
            "type": "string"
          },
          "clientId": {
            "description": "The client ID to fetch for",
            "type": "string"
          }
        },
        "required": [
          "clientId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetSIWBBRequestsForDeveloperAppSuccessResponse": {
        "properties": {
          "siwbbRequests": {
            "items": {
              "$ref": "#/components/schemas/iSIWBBRequestDoc"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "siwbbRequests",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iExchangeSIWBBAuthorizationCodePayload": {
        "properties": {
          "code": {
            "description": "The SIWBB request.",
            "type": "string"
          },
          "options": {
            "description": "We attempt to verify the current status with each request. You can provide additional options for verification here.",
            "$ref": "#/components/schemas/VerifySIWBBOptions"
          },
          "client_secret": {
            "description": "Client secret for the SIWBB request.",
            "type": "string"
          },
          "client_id": {
            "description": "Client ID for the SIWBB request.",
            "type": "string"
          },
          "redirect_uri": {
            "description": "The redirect URI for the SIWBB request. Only required if the code was created with a redirect URI.",
            "type": "string"
          },
          "grant_type": {
            "enum": [
              "authorization_code",
              "refresh_token"
            ],
            "description": "The grant type for the SIWBB request.",
            "type": "string"
          },
          "refresh_token": {
            "description": "The refresh token to use for the SIWBB request.",
            "type": "string"
          },
          "code_verifier": {
            "description": "The code verifier for the SIWBB request (if used with PKCE).",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iExchangeSIWBBAuthorizationCodeSuccessResponse": {
        "properties": {
          "address": {
            "description": "The user's address",
            "type": "string"
          },
          "chain": {
            "description": "The chain of the address",
            "$ref": "#/components/schemas/SupportedChain"
          },
          "ownershipRequirements": {
            "description": "The ownership requirements for the user",
            "$ref": "#/components/schemas/AssetConditionGroup"
          },
          "bitbadgesAddress": {
            "description": "The converted BitBadges address of params.address. This can be used as the\nunique identifier for the user (e.g. avoid duplicate sign ins from equivalent 0x and bb1 addresses).",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "verificationResponse": {
            "properties": {
              "success": {
                "description": "Returns whether the current (message, signature) pair is valid and verified (i.e. signature is valid and any assets are owned).",
                "type": "boolean"
              },
              "errorMessage": {
                "description": "Returns the response message returned from verification.",
                "type": "string"
              }
            },
            "required": [
              "success"
            ],
            "additionalProperties": false,
            "description": "Verification response",
            "type": "object"
          },
          "access_token": {
            "description": "The access token to use for the SIWBB request.",
            "type": "string"
          },
          "token_type": {
            "description": "The token type",
            "type": "string"
          },
          "access_token_expires_at": {
            "description": "The time at which the access token expires.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "refresh_token": {
            "description": "The refresh token to use for the SIWBB request.",
            "type": "string"
          },
          "refresh_token_expires_at": {
            "description": "The time at which the refresh token expires.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          }
        },
        "required": [
          "address",
          "chain",
          "bitbadgesAddress",
          "access_token",
          "token_type"
        ],
        "additionalProperties": false,
        "description": "",
        "type": "object"
      },
      "iDeleteSIWBBRequestPayload": {
        "properties": {
          "code": {
            "type": "string"
          }
        },
        "required": [
          "code"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteSIWBBRequestSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateDeveloperAppPayload": {
        "properties": {
          "name": {
            "description": "Metadata for the secret for display purposes. Note this should not contain anything sensitive. It may be displayed to verifiers.",
            "type": "string",
            "examples": [
              "Name"
            ]
          },
          "description": {
            "description": "Description of the app.",
            "type": "string",
            "examples": [
              "Brief description."
            ]
          },
          "image": {
            "description": "Image for the app.",
            "type": "string",
            "examples": [
              "https://example.com/image.png",
              "ipfs://Qm..."
            ]
          },
          "redirectUris": {
            "items": {
              "type": "string"
            },
            "description": "Redirect URIs for the app.",
            "type": "array"
          }
        },
        "required": [
          "name",
          "description",
          "image",
          "redirectUris"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateDeveloperAppSuccessResponse": {
        "properties": {
          "clientId": {
            "description": "Client ID for the app.",
            "type": "string"
          },
          "clientSecret": {
            "description": "Client secret for the app.",
            "type": "string"
          }
        },
        "required": [
          "clientId",
          "clientSecret"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetActiveAuthorizationsPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetActiveAuthorizationsSuccessResponse": {
        "properties": {
          "authorizations": {
            "items": {
              "$ref": "#/components/schemas/iAccessTokenDoc"
            },
            "type": "array"
          },
          "developerApps": {
            "items": {
              "$ref": "#/components/schemas/iDeveloperAppDoc"
            },
            "description": "Developer app docs for each authorization.\n\nUndefined if deleted.",
            "type": "array"
          }
        },
        "required": [
          "authorizations",
          "developerApps"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchDeveloperAppsPayload": {
        "properties": {
          "bookmark": {
            "description": "Bookmark for pagination of the apps. Not compatible with clientId.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDeveloperAppPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDeveloperAppSuccessResponse": {
        "properties": {
          "developerApp": {
            "$ref": "#/components/schemas/iDeveloperAppDoc"
          }
        },
        "required": [
          "developerApp"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDeveloperAppsPayload": {
        "properties": {
          "clientId": {
            "description": "If you want to get a specific app, specify the client ID here (will not return the client secret).",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDeveloperAppsSuccessResponse": {
        "properties": {
          "developerApps": {
            "items": {
              "$ref": "#/components/schemas/iDeveloperAppDoc"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "developerApps",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchDeveloperAppsSuccessResponse": {
        "properties": {
          "developerApps": {
            "items": {
              "$ref": "#/components/schemas/iDeveloperAppDoc"
            },
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "developerApps",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteDeveloperAppPayload": {
        "properties": {
          "clientId": {
            "description": "The client ID of the app to delete.",
            "type": "string"
          },
          "clientSecret": {
            "description": "The client secret of the app to delete. This is only needed for temporary developer apps (not linked to a user).\nFor non-temporary developer apps, the client secret is not needed, but you must be signed in and the owner of the app.",
            "type": "string"
          }
        },
        "required": [
          "clientId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteDeveloperAppSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateDeveloperAppPayload": {
        "properties": {
          "clientId": {
            "description": "Client ID for the app to update.",
            "type": "string"
          },
          "name": {
            "description": "Metadata for for display purposes. Note this should not contain anything sensitive. It may be displayed to verifiers.",
            "type": "string",
            "examples": [
              "Name"
            ]
          },
          "description": {
            "description": "Description of the app.",
            "type": "string",
            "examples": [
              "Brief description."
            ]
          },
          "image": {
            "description": "Image for the app.",
            "type": "string",
            "examples": [
              "https://example.com/image.png",
              "ipfs://Qm..."
            ]
          },
          "redirectUris": {
            "items": {
              "type": "string"
            },
            "description": "Redirect URIs for the app.",
            "type": "array"
          },
          "rotateClientSecret": {
            "description": "Rotate the client secret?",
            "type": "boolean"
          }
        },
        "required": [
          "clientId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateDeveloperAppSuccessResponse": {
        "properties": {
          "success": {
            "type": "boolean"
          },
          "clientSecret": {
            "type": "string"
          }
        },
        "required": [
          "success"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "PluginVersionConfigPayload": {
        "properties": {
          "finalized": {
            "description": "Finalized",
            "type": "boolean"
          },
          "stateFunctionPreset": {
            "description": "Preset type for how the plugin state is to be maintained."
          },
          "duplicatesAllowed": {
            "description": "Whether it makes sense for multiple of this plugin to be allowed",
            "type": "boolean"
          },
          "receiveStatusWebhook": {
            "description": "Whether the plugin should receive status webhooks",
            "type": "boolean"
          },
          "skipProcessingWebhook": {
            "description": "Whether the plugin should skip processing webhooks. We will just auto-treat it as successful.",
            "type": "boolean"
          },
          "ignoreSimulations": {
            "description": "Ignore simulations?",
            "type": "boolean"
          },
          "reuseForNonIndexed": {
            "description": "Reuse for non-indexed?",
            "type": "boolean"
          },
          "requiresUserInputs": {
            "description": "This is a flag for being compatible with auto-triggered claims, meaning no user interaction is needed.",
            "type": "boolean"
          },
          "userInputRedirect": {
            "properties": {
              "baseUri": {
                "description": "The base URI for user inputs. Note: This is experimental and not fully supported yet.",
                "type": "string"
              },
              "tutorialUri": {
                "description": "The tutorial URI for user inputs.",
                "type": "string"
              }
            },
            "additionalProperties": false,
            "description": "The redirect URI for user inputs.",
            "type": "object"
          },
          "userInputsSchema": {
            "items": {
              "$ref": "#/components/schemas/JsonBodyInputSchema"
            },
            "type": "array"
          },
          "claimCreatorRedirect": {
            "properties": {
              "toolUri": {
                "description": "The tool URI for claim creators. Note: This is experimental and not fully supported yet.",
                "type": "string"
              },
              "tutorialUri": {
                "description": "The tutorial URI for claim creators.",
                "type": "string"
              },
              "testerUri": {
                "description": "The tester URI for claim creators. Note: This is experimental and not fully supported yet.",
                "type": "string"
              }
            },
            "additionalProperties": false,
            "description": "The redirect URI for claim creators.",
            "type": "object"
          },
          "publicParamsSchema": {
            "items": {
              "$ref": "#/components/schemas/JsonBodyInputSchema"
            },
            "type": "array"
          },
          "privateParamsSchema": {
            "items": {
              "$ref": "#/components/schemas/JsonBodyInputSchema"
            },
            "type": "array"
          },
          "verificationCall": {
            "properties": {
              "uri": {
                "type": "string",
                "examples": [
                  "https://example.com",
                  "ipfs://Qm..."
                ]
              },
              "method": {
                "enum": [
                  "POST",
                  "GET",
                  "PUT",
                  "DELETE"
                ],
                "type": "string"
              },
              "hardcodedInputs": {
                "items": {
                  "$ref": "#/components/schemas/JsonBodyInputWithValue"
                },
                "type": "array"
              },
              "passAddress": {
                "type": "boolean"
              },
              "passDiscord": {
                "type": "boolean"
              },
              "passEmail": {
                "type": "boolean"
              },
              "passTwitter": {
                "type": "boolean"
              },
              "passGoogle": {
                "type": "boolean"
              },
              "passYoutube": {
                "type": "boolean"
              },
              "passGithub": {
                "type": "boolean"
              },
              "passStrava": {
                "type": "boolean"
              },
              "passTwitch": {
                "type": "boolean"
              },
              "passReddit": {
                "type": "boolean"
              },
              "passMeetup": {
                "type": "boolean"
              },
              "passFacebook": {
                "type": "boolean"
              },
              "passTelegram": {
                "type": "boolean"
              },
              "passFarcaster": {
                "type": "boolean"
              },
              "passSlack": {
                "type": "boolean"
              },
              "passShopify": {
                "type": "boolean"
              },
              "passBluesky": {
                "type": "boolean"
              },
              "postProcessingJs": {
                "type": "string"
              }
            },
            "required": [
              "uri",
              "method",
              "hardcodedInputs",
              "postProcessingJs"
            ],
            "additionalProperties": false,
            "description": "The verification URL",
            "type": "object"
          },
          "requireSignIn": {
            "description": "Require BitBadges sign-in to use the plugin?",
            "type": "boolean"
          },
          "customDetailsDisplay": {
            "description": "Custom details display for the plugin. Use {{publicParamKey}} to dynamically display the values of public parameters.",
            "type": "string"
          }
        },
        "required": [
          "finalized",
          "stateFunctionPreset",
          "duplicatesAllowed",
          "receiveStatusWebhook",
          "reuseForNonIndexed",
          "requiresUserInputs"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreatePluginPayload": {
        "properties": {
          "pluginId": {
            "description": "The unique plugin ID",
            "type": "string"
          },
          "inviteCode": {
            "description": "Invite code for the plugin",
            "type": "string"
          },
          "metadata": {
            "properties": {
              "name": {
                "description": "The name of the plugin",
                "type": "string",
                "examples": [
                  "Name"
                ]
              },
              "description": {
                "description": "Description of the plugin",
                "type": "string",
                "examples": [
                  "Brief description."
                ]
              },
              "image": {
                "description": "The image of the plugin",
                "type": "string",
                "examples": [
                  "https://example.com/image.png",
                  "ipfs://Qm..."
                ]
              },
              "documentation": {
                "description": "Documentation for the plugin",
                "type": "string"
              },
              "parentApp": {
                "description": "Parent app of the plugin. If blank, treated as its own app / entity.",
                "type": "string"
              },
              "sourceCode": {
                "description": "Source code for the plugin",
                "type": "string"
              },
              "supportLink": {
                "description": "Support link for the plugin",
                "type": "string"
              },
              "createdBy": {
                "$ref": "#/components/schemas/BitBadgesAddress",
                "description": "The creator of the plugin"
              }
            },
            "required": [
              "name",
              "description",
              "image",
              "createdBy"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "toPublish": {
            "description": "To publish in the directory. This will trigger the start of the review process.",
            "type": "boolean"
          },
          "approvedUsers": {
            "items": {
              "$ref": "#/components/schemas/NativeAddress"
            },
            "description": "The addresses that are allowed to use this plugin.",
            "type": "array"
          },
          "initialVersion": {
            "description": "The initial version configuration",
            "$ref": "#/components/schemas/PluginVersionConfigPayload"
          },
          "locale": {
            "description": "Locale that is supported by the plugin. By default, we assume 'en' is supported if not specified.",
            "type": "string"
          }
        },
        "required": [
          "pluginId",
          "metadata",
          "toPublish",
          "initialVersion"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreatePluginSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdatePluginPayload": {
        "properties": {
          "pluginId": {
            "description": "The unique plugin ID",
            "type": "string"
          },
          "inviteCode": {
            "description": "Invite code for the plugin",
            "type": "string"
          },
          "removeSelfFromApprovedUsers": {
            "description": "Remove self from approved users?",
            "type": "boolean"
          },
          "metadata": {
            "properties": {
              "name": {
                "description": "The name of the plugin",
                "type": "string",
                "examples": [
                  "Name"
                ]
              },
              "description": {
                "description": "Description of the plugin",
                "type": "string",
                "examples": [
                  "Brief description."
                ]
              },
              "image": {
                "description": "The image of the plugin",
                "type": "string",
                "examples": [
                  "https://example.com/image.png",
                  "ipfs://Qm..."
                ]
              },
              "documentation": {
                "description": "Documentation for the plugin",
                "type": "string"
              },
              "parentApp": {
                "description": "Parent app of the plugin. If blank, treated as its own app / entity.",
                "type": "string"
              },
              "sourceCode": {
                "description": "Source code for the plugin",
                "type": "string"
              },
              "supportLink": {
                "description": "Support link for the plugin",
                "type": "string"
              },
              "createdBy": {
                "description": "Creator of the plugin",
                "type": "string"
              }
            },
            "required": [
              "name",
              "description",
              "image"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "toPublish": {
            "description": "To publish in the directory. This will trigger the start of the review process.",
            "type": "boolean"
          },
          "approvedUsers": {
            "items": {
              "$ref": "#/components/schemas/NativeAddress"
            },
            "description": "The addresses that are allowed to use this plugin.",
            "type": "array"
          },
          "rotatePluginSecret": {
            "description": "Rotate the plugin secret?",
            "type": "boolean"
          },
          "versionUpdates": {
            "items": {
              "properties": {
                "version": {
                  "description": "The version to update or create",
                  "$ref": "#/components/schemas/NumberType"
                },
                "config": {
                  "properties": {
                    "finalized": {
                      "description": "Finalized",
                      "type": "boolean"
                    },
                    "stateFunctionPreset": {
                      "description": "Preset type for how the plugin state is to be maintained."
                    },
                    "duplicatesAllowed": {
                      "description": "Whether it makes sense for multiple of this plugin to be allowed",
                      "type": "boolean"
                    },
                    "receiveStatusWebhook": {
                      "description": "Whether the plugin should receive status webhooks",
                      "type": "boolean"
                    },
                    "skipProcessingWebhook": {
                      "description": "Whether the plugin should skip processing webhooks. We will just auto-treat it as successful.",
                      "type": "boolean"
                    },
                    "ignoreSimulations": {
                      "description": "Ignore simulations?",
                      "type": "boolean"
                    },
                    "reuseForNonIndexed": {
                      "description": "Reuse for non-indexed?",
                      "type": "boolean"
                    },
                    "requiresUserInputs": {
                      "description": "This is a flag for being compatible with auto-triggered claims, meaning no user interaction is needed.",
                      "type": "boolean"
                    },
                    "userInputRedirect": {
                      "properties": {
                        "baseUri": {
                          "description": "The base URI for user inputs. Note: This is experimental and not fully supported yet.",
                          "type": "string"
                        },
                        "tutorialUri": {
                          "description": "The tutorial URI for user inputs.",
                          "type": "string"
                        }
                      },
                      "additionalProperties": false,
                      "description": "The redirect URI for user inputs.",
                      "type": "object"
                    },
                    "userInputsSchema": {
                      "items": {
                        "$ref": "#/components/schemas/JsonBodyInputSchema"
                      },
                      "type": "array"
                    },
                    "claimCreatorRedirect": {
                      "properties": {
                        "toolUri": {
                          "description": "The tool URI for claim creators. Note: This is experimental and not fully supported yet.",
                          "type": "string"
                        },
                        "tutorialUri": {
                          "description": "The tutorial URI for claim creators.",
                          "type": "string"
                        },
                        "testerUri": {
                          "description": "The tester URI for claim creators. Note: This is experimental and not fully supported yet.",
                          "type": "string"
                        }
                      },
                      "additionalProperties": false,
                      "description": "The redirect URI for claim creators.",
                      "type": "object"
                    },
                    "publicParamsSchema": {
                      "items": {
                        "$ref": "#/components/schemas/JsonBodyInputSchema"
                      },
                      "type": "array"
                    },
                    "privateParamsSchema": {
                      "items": {
                        "$ref": "#/components/schemas/JsonBodyInputSchema"
                      },
                      "type": "array"
                    },
                    "verificationCall": {
                      "properties": {
                        "uri": {
                          "type": "string",
                          "examples": [
                            "https://example.com",
                            "ipfs://Qm..."
                          ]
                        },
                        "method": {
                          "enum": [
                            "POST",
                            "GET",
                            "PUT",
                            "DELETE"
                          ],
                          "type": "string"
                        },
                        "hardcodedInputs": {
                          "items": {
                            "$ref": "#/components/schemas/JsonBodyInputWithValue"
                          },
                          "type": "array"
                        },
                        "passAddress": {
                          "type": "boolean"
                        },
                        "passDiscord": {
                          "type": "boolean"
                        },
                        "passEmail": {
                          "type": "boolean"
                        },
                        "passTwitter": {
                          "type": "boolean"
                        },
                        "passGoogle": {
                          "type": "boolean"
                        },
                        "passYoutube": {
                          "type": "boolean"
                        },
                        "passGithub": {
                          "type": "boolean"
                        },
                        "passStrava": {
                          "type": "boolean"
                        },
                        "passTwitch": {
                          "type": "boolean"
                        },
                        "passReddit": {
                          "type": "boolean"
                        },
                        "passMeetup": {
                          "type": "boolean"
                        },
                        "passFacebook": {
                          "type": "boolean"
                        },
                        "passTelegram": {
                          "type": "boolean"
                        },
                        "passFarcaster": {
                          "type": "boolean"
                        },
                        "passSlack": {
                          "type": "boolean"
                        },
                        "passShopify": {
                          "type": "boolean"
                        },
                        "passBluesky": {
                          "type": "boolean"
                        },
                        "postProcessingJs": {
                          "type": "string"
                        }
                      },
                      "required": [
                        "uri",
                        "method",
                        "hardcodedInputs",
                        "postProcessingJs"
                      ],
                      "additionalProperties": false,
                      "description": "The verification URL",
                      "type": "object"
                    },
                    "requireSignIn": {
                      "description": "Require BitBadges sign-in to use the plugin?",
                      "type": "boolean"
                    },
                    "customDetailsDisplay": {
                      "description": "Custom details display for the plugin. Use {{publicParamKey}} to dynamically display the values of public parameters.",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false,
                  "description": "The configuration for this version",
                  "type": "object"
                }
              },
              "required": [
                "version",
                "config"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "Update an existing version",
            "type": "array"
          },
          "versionCreate": {
            "description": "Create a new version",
            "$ref": "#/components/schemas/PluginVersionConfigPayload"
          },
          "locale": {
            "description": "Locale that is supported by the plugin. By default, we assume 'en' is supported if not specified.",
            "type": "string"
          }
        },
        "required": [
          "pluginId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdatePluginSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iDeletePluginPayload": {
        "properties": {
          "pluginId": {
            "description": "The unique plugin ID",
            "type": "string"
          }
        },
        "required": [
          "pluginId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeletePluginSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchPluginsPayload": {
        "properties": {
          "pluginsForSignedInUser": {
            "description": "If true, we will fetch all plugins for the authenticated user (with plugin secrets).\n\nThis will include plugins created by the signed in user and also those where they are explicitly approved / invited.",
            "type": "boolean"
          },
          "bookmark": {
            "description": "Bookmark for pagination of the plugins (obtained from a previous call to this endpoint).",
            "type": "string"
          },
          "searchValue": {
            "description": "Search value",
            "type": "string"
          },
          "locale": {
            "description": "Locale to restrict results to. By default, we assume 'en'. This is not applicable if you specify createdPluginsOnly, speciifc pluginIds, or an invite code.",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPluginsPayload": {
        "properties": {
          "pluginIds": {
            "items": {
              "type": "string"
            },
            "description": "If true, we will fetch only the specific plugin with the plugin ID (no secrets).",
            "type": "array"
          },
          "inviteCode": {
            "description": "Invite code to fetch the plugin with.",
            "type": "string"
          }
        },
        "required": [
          "pluginIds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPluginPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iCreatePaymentIntentPayload": {
        "properties": {
          "amount": {
            "description": "The amount in USD to pay",
            "type": "number"
          },
          "purpose": {
            "enum": [
              "credits",
              "deposit"
            ],
            "description": "Purpose of the payment",
            "type": "string"
          },
          "affiliateCode": {
            "description": "The affiliate code to use for the payment",
            "type": "string"
          }
        },
        "required": [
          "amount",
          "purpose"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreatePaymentIntentSuccessResponse": {
        "properties": {
          "clientSecret": {
            "description": "The payment intent client secret",
            "type": "string"
          }
        },
        "required": [
          "clientSecret"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPluginSuccessResponse": {
        "properties": {
          "plugin": {
            "$ref": "#/components/schemas/iPluginDoc"
          }
        },
        "required": [
          "plugin"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPluginsSuccessResponse": {
        "properties": {
          "plugins": {
            "items": {
              "$ref": "#/components/schemas/iPluginDoc"
            },
            "type": "array"
          },
          "bookmark": {
            "description": "Bookmark for pagination of the plugins. Only applicable if fetching the directory.",
            "type": "string"
          }
        },
        "required": [
          "plugins"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchPluginsSuccessResponse": {
        "properties": {
          "plugins": {
            "items": {
              "$ref": "#/components/schemas/iPluginDoc"
            },
            "type": "array"
          },
          "bookmark": {
            "description": "Bookmark for pagination of the plugins. Only applicable if fetching the directory.",
            "type": "string"
          }
        },
        "required": [
          "plugins"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteClaimPayload": {
        "properties": {
          "claimIds": {
            "items": {
              "type": "string"
            },
            "description": "The claim ID to delete.",
            "type": "array"
          }
        },
        "required": [
          "claimIds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteClaimSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateClaimPayload": {
        "properties": {
          "claims": {
            "items": {
              "$ref": "#/components/schemas/UpdateClaimRequest"
            },
            "type": "array"
          }
        },
        "required": [
          "claims"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateClaimSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateClaimPayload": {
        "properties": {
          "claims": {
            "items": {
              "$ref": "#/components/schemas/CreateClaimRequest"
            },
            "description": "The claims to create.\n\nBy default, it will create standalone (non-test claims) or  collection linked claims if the\ncorresponding fields are specified in the claim.\n\nNote that collection / list linked claims require the proper permissions and have special setup\nrequired.\n\nFor test claims, you must specify the `testClaims` field to be true.",
            "type": "array"
          },
          "testClaims": {
            "description": "Create test claims (e.g. the claim tester). Used for frontend testing. Test claims are auto-deleted\nafter the browser session is terminated and do not show up in search results.",
            "type": "boolean"
          }
        },
        "required": [
          "claims"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateClaimSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iOauthRevokePayload": {
        "properties": {
          "token": {
            "description": "The OAuth token to revoke.",
            "type": "string"
          }
        },
        "required": [
          "token"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iOauthRevokeSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetGatedContentForClaimPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetGatedContentForClaimSuccessResponse": {
        "properties": {
          "rewards": {
            "items": {
              "$ref": "#/components/schemas/iClaimReward"
            },
            "type": "array"
          }
        },
        "required": [
          "rewards"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateDynamicDataStorePayload": {
        "properties": {
          "handlerId": {
            "description": "The handler ID for the dynamic data store",
            "type": "string",
            "examples": [
              "email",
              "addresses"
            ]
          },
          "label": {
            "description": "The label of the dynamic data store",
            "type": "string"
          },
          "publicUseInClaims": {
            "description": "Whether the dynamic data store should be public. If true, the data can be accessed without authentication. Defaults to false (private).",
            "type": "boolean"
          }
        },
        "required": [
          "handlerId",
          "label"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateDynamicDataStoreSuccessResponse": {
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/iDynamicDataDoc"
          }
        },
        "required": [
          "doc"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchDynamicDataStoresPayload": {
        "properties": {
          "bookmark": {
            "description": "The pagination bookmark to start from",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataStoreValuesPaginatedPayload": {
        "properties": {
          "dataSecret": {
            "description": "The data secret to fetch. Only needed if you are not signed in as creator. Not applicable to public stores",
            "type": "string"
          },
          "bookmark": {
            "description": "The pagination bookmark to start from",
            "type": "string"
          },
          "lookupType": {
            "enum": [
              "id",
              "username"
            ],
            "description": "The lookup type to fetch (if you need to specify).",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataStoreValuesPaginatedSuccessResponse": {
        "properties": {
          "lookupValues": {
            "items": {
              "properties": {
                "key": {
                  "description": "The key of the lookup value",
                  "type": "string"
                },
                "lookupType": {
                  "enum": [
                    "id",
                    "username"
                  ],
                  "description": "The lookup type of the lookup value",
                  "type": "string"
                },
                "inStore": {
                  "description": "Whether the lookup value is in the store",
                  "type": "boolean"
                }
              },
              "required": [
                "key",
                "inStore"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "The lookup values for the dynamic data store",
            "type": "array"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "lookupValues",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataStoreValuePayload": {
        "properties": {
          "key": {
            "description": "The key to fetch.",
            "type": "string"
          },
          "dataSecret": {
            "description": "The data secret to fetch. Only needed if you are not signed in as creator. Not applicable to public stores",
            "type": "string"
          },
          "lookupType": {
            "enum": [
              "id",
              "username"
            ],
            "description": "The lookup type to fetch (if you need to specify).",
            "type": "string"
          }
        },
        "required": [
          "key"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataStoreValueSuccessResponse": {
        "properties": {
          "key": {
            "type": "string"
          },
          "lookupType": {
            "enum": [
              "id",
              "username"
            ],
            "type": "string"
          },
          "inStore": {
            "type": "boolean"
          }
        },
        "required": [
          "key",
          "inStore"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataStorePayload": {
        "properties": {
          "dataSecret": {
            "description": "The data secret to fetch. Only needed if you are not signed in as creator. Not applicable to public stores",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataStoreSuccessResponse": {
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/iDynamicDataDoc"
          }
        },
        "required": [
          "doc"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataStoresPayload": {
        "properties": {
          "dynamicDataIds": {
            "items": {
              "type": "string"
            },
            "description": "The IDs to fetch. If not provided, all dynamic data stores will be fetched for the current signed in address without any data populated.",
            "type": "array"
          },
          "dataSecret": {
            "description": "The data secret to fetch. Only needed if you are not signed in as creator. Not applicable to public stores",
            "type": "string"
          }
        },
        "required": [
          "dynamicDataIds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataStoresSuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "$ref": "#/components/schemas/iDynamicDataDoc"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "bookmark": {
                "type": "string"
              },
              "hasMore": {
                "type": "boolean"
              }
            },
            "required": [
              "bookmark",
              "hasMore"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "docs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchDynamicDataStoresSuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "$ref": "#/components/schemas/iDynamicDataDoc"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "bookmark": {
                "type": "string"
              },
              "hasMore": {
                "type": "boolean"
              }
            },
            "required": [
              "bookmark",
              "hasMore"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "docs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateDynamicDataStorePayload": {
        "properties": {
          "dynamicDataId": {
            "description": "The dynamic data ID to update",
            "type": "string"
          },
          "rotateDataSecret": {
            "description": "Whether to rotate the data secret",
            "type": "boolean"
          },
          "label": {
            "description": "The new label",
            "type": "string"
          }
        },
        "required": [
          "dynamicDataId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateDynamicDataStoreSuccessResponse": {
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/iDynamicDataDoc"
          }
        },
        "required": [
          "doc"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteDynamicDataStorePayload": {
        "properties": {
          "dynamicDataId": {
            "description": "The dynamic data ID to delete",
            "type": "string"
          }
        },
        "required": [
          "dynamicDataId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteDynamicDataStoreSuccessResponse": {
        "properties": {
          "message": {
            "type": "string"
          }
        },
        "required": [
          "message"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPerformStoreActionSingleWithBodyAuthPayload": {
        "properties": {
          "_isSimulation": {
            "description": "Whether to simulate the action",
            "type": "boolean"
          },
          "dynamicDataId": {
            "description": "The dynamic data ID",
            "type": "string"
          },
          "dataSecret": {
            "description": "The data secret. Needed if you are not signed in as creator. Not applicable to public stores",
            "type": "string"
          },
          "actionName": {
            "description": "The name of the action to perform",
            "type": "string",
            "examples": [
              "add"
            ]
          },
          "payload": {
            "description": "The payload for this specific action",
            "$ref": "#/components/schemas/iPerformStoreActionPayload"
          }
        },
        "required": [
          "dynamicDataId",
          "actionName",
          "payload"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPerformStoreActionSingleWithBodyAuthSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iPerformStoreActionBatchWithBodyAuthPayload": {
        "properties": {
          "_isSimulation": {
            "description": "Whether to simulate the action",
            "type": "boolean"
          },
          "dynamicDataId": {
            "description": "The dynamic data ID",
            "type": "string"
          },
          "dataSecret": {
            "description": "The data secret. Needed if you are not signed in as creator. Not applicable to public stores",
            "type": "string"
          },
          "actions": {
            "items": {
              "properties": {
                "actionName": {
                  "description": "The name of the action to perform",
                  "type": "string",
                  "examples": [
                    "add"
                  ]
                },
                "payload": {
                  "$ref": "#/components/schemas/iPerformStoreActionPayload",
                  "description": "The payload for this specific action"
                }
              },
              "required": [
                "actionName",
                "payload"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "The actions to perform",
            "type": "array"
          }
        },
        "required": [
          "dynamicDataId",
          "actions"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPerformStoreActionBatchWithBodyAuthSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iPerformStoreActionPayload": {
        "additionalProperties": {},
        "type": "object"
      },
      "iPerformStoreActionSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iBatchStoreActionSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataActivityPayload": {
        "properties": {
          "dynamicDataId": {
            "description": "The dynamic data ID to fetch activity for",
            "type": "string"
          },
          "bookmark": {
            "description": "The pagination bookmark to start from",
            "type": "string"
          },
          "dataSecret": {
            "description": "The data secret to fetch activity for. Needed if you are not signed in as creator. Not applicable to public stores",
            "type": "string"
          }
        },
        "required": [
          "dynamicDataId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetDynamicDataActivitySuccessResponse": {
        "properties": {
          "pending": {
            "items": {
              "properties": {
                "dynamicDataId": {
                  "type": "string"
                },
                "handlerId": {
                  "type": "string",
                  "examples": [
                    "email",
                    "addresses"
                  ]
                },
                "actions": {
                  "items": {},
                  "type": "array"
                },
                "lastFetchedAt": {
                  "type": "number"
                },
                "numRetries": {
                  "type": "number"
                },
                "nextFetchTime": {
                  "type": "number"
                },
                "error": {
                  "type": "string"
                }
              },
              "required": [
                "dynamicDataId",
                "handlerId",
                "actions",
                "lastFetchedAt",
                "numRetries",
                "nextFetchTime",
                "error"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          },
          "history": {
            "properties": {
              "docs": {
                "items": {
                  "properties": {
                    "dynamicDataId": {
                      "type": "string"
                    },
                    "updatedAt": {
                      "type": "number"
                    },
                    "actions": {
                      "items": {},
                      "type": "array"
                    }
                  },
                  "required": [
                    "dynamicDataId",
                    "updatedAt",
                    "actions"
                  ],
                  "additionalProperties": false,
                  "type": "object"
                },
                "type": "array"
              },
              "pagination": {
                "properties": {
                  "bookmark": {
                    "type": "string"
                  },
                  "hasMore": {
                    "type": "boolean"
                  }
                },
                "required": [
                  "bookmark",
                  "hasMore"
                ],
                "additionalProperties": false,
                "type": "object"
              }
            },
            "required": [
              "docs",
              "pagination"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "pending",
          "history"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetApiKeysPayload": {
        "properties": {
          "bookmark": {
            "description": "The pagination bookmark to start from",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetApiKeysSuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "$ref": "#/components/schemas/iApiKeyDoc"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "bookmark": {
                "type": "string"
              },
              "hasMore": {
                "type": "boolean"
              }
            },
            "required": [
              "bookmark",
              "hasMore"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "docs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateApiKeyPayload": {
        "properties": {
          "label": {
            "description": "The label for the API key",
            "type": "string"
          },
          "intendedUse": {
            "description": "The intended use for the API key",
            "type": "string"
          }
        },
        "required": [
          "label",
          "intendedUse"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateApiKeySuccessResponse": {
        "properties": {
          "key": {
            "type": "string"
          }
        },
        "required": [
          "key"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iRotateApiKeyPayload": {
        "properties": {
          "docId": {
            "description": "The doc ID to rotate",
            "type": "string"
          }
        },
        "required": [
          "docId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iRotateApiKeySuccessResponse": {
        "properties": {
          "key": {
            "type": "string"
          }
        },
        "required": [
          "key"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteApiKeyPayload": {
        "properties": {
          "key": {
            "description": "The API key to delete",
            "type": "string"
          },
          "_docId": {
            "description": "The doc ID to delete",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteApiKeySuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchApplicationsPayload": {
        "properties": {
          "bookmark": {
            "description": "The search value to search for",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetApplicationPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetApplicationSuccessResponse": {
        "properties": {
          "application": {
            "$ref": "#/components/schemas/iApplicationDoc"
          }
        },
        "required": [
          "application"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetApplicationsPayload": {
        "properties": {
          "applicationIds": {
            "items": {
              "type": "string"
            },
            "description": "The specific IDs to fetch",
            "type": "array"
          }
        },
        "required": [
          "applicationIds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetApplicationsSuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "$ref": "#/components/schemas/iApplicationDoc"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "bookmark": {
                "type": "string"
              },
              "hasMore": {
                "type": "boolean"
              }
            },
            "required": [
              "bookmark",
              "hasMore"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "docs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchApplicationsSuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "$ref": "#/components/schemas/iApplicationDoc"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "bookmark": {
                "type": "string"
              },
              "hasMore": {
                "type": "boolean"
              }
            },
            "required": [
              "bookmark",
              "hasMore"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "docs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateApplicationPayload": {
        "properties": {
          "metadata": {
            "description": "The overall metadata for the application",
            "$ref": "#/components/schemas/iMetadataWithoutInternals"
          },
          "pages": {
            "items": {
              "$ref": "#/components/schemas/iApplicationPage"
            },
            "description": "The pages in the application",
            "type": "array"
          }
        },
        "required": [
          "metadata",
          "pages"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateApplicationSuccessResponse": {
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/iApplicationDoc"
          }
        },
        "required": [
          "doc"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateApplicationPayload": {
        "properties": {
          "applicationId": {
            "description": "The application ID to update",
            "type": "string"
          },
          "metadata": {
            "description": "The overall metadata for the application",
            "$ref": "#/components/schemas/iMetadataWithoutInternals"
          },
          "pages": {
            "items": {
              "$ref": "#/components/schemas/iApplicationPage"
            },
            "description": "The pages in the application",
            "type": "array"
          }
        },
        "required": [
          "applicationId",
          "metadata",
          "pages"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateApplicationSuccessResponse": {
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/iApplicationDoc"
          }
        },
        "required": [
          "doc"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteApplicationPayload": {
        "properties": {
          "applicationId": {
            "description": "The application ID to delete",
            "type": "string"
          }
        },
        "required": [
          "applicationId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteApplicationSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iCalculatePointsPayload": {
        "properties": {
          "applicationId": {
            "description": "The application ID to calculate points for",
            "type": "string"
          },
          "pageId": {
            "description": "The page ID to calculate points for",
            "type": "string"
          },
          "address": {
            "description": "The address to calculate points for",
            "$ref": "#/components/schemas/NativeAddress"
          },
          "bookmark": {
            "description": "The pagination bookmark to start from",
            "type": "string"
          },
          "skipCache": {
            "description": "Skip the cache and calculate points from scratch",
            "type": "boolean"
          }
        },
        "required": [
          "applicationId",
          "pageId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPointsValue": {
        "properties": {
          "address": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "points": {
            "type": "number"
          },
          "lastCalculatedAt": {
            "type": "number"
          },
          "claimSuccessCounts": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object"
          }
        },
        "required": [
          "address",
          "points",
          "lastCalculatedAt"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCalculatePointsSuccessResponse": {
        "properties": {
          "values": {
            "items": {
              "$ref": "#/components/schemas/iPointsValue"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "bookmark": {
                "type": "string"
              },
              "hasMore": {
                "type": "boolean"
              }
            },
            "required": [
              "bookmark",
              "hasMore"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "values",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPointsActivityPayload": {
        "properties": {
          "applicationId": {
            "description": "The application ID to get points activity for",
            "type": "string"
          },
          "pageId": {
            "description": "The page ID to get points activity for",
            "type": "string"
          },
          "bookmark": {
            "description": "The pagination bookmark to start from",
            "type": "string"
          },
          "address": {
            "description": "The specific address to get points activity for",
            "$ref": "#/components/schemas/NativeAddress"
          }
        },
        "required": [
          "applicationId",
          "pageId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPointsActivitySuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "$ref": "#/components/schemas/iPointsActivityDoc"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "bookmark": {
                "type": "string"
              },
              "hasMore": {
                "type": "boolean"
              }
            },
            "required": [
              "bookmark",
              "hasMore"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "docs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchUtilityPagesPayload": {
        "properties": {
          "bookmark": {
            "description": "The pagination bookmark to start from",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetUtilityPagePayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetUtilityPageSuccessResponse": {
        "properties": {
          "listing": {
            "$ref": "#/components/schemas/iUtilityPageDoc"
          }
        },
        "required": [
          "listing"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetUtilityPagesPayload": {
        "properties": {
          "listingIds": {
            "items": {
              "type": "string"
            },
            "description": "The specific IDs to fetch",
            "type": "array"
          }
        },
        "required": [
          "listingIds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetUtilityPagesSuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageDoc"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "bookmark": {
                "type": "string"
              },
              "hasMore": {
                "type": "boolean"
              }
            },
            "required": [
              "bookmark",
              "hasMore"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "docs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSearchUtilityPagesSuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageDoc"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "bookmark": {
                "type": "string"
              },
              "hasMore": {
                "type": "boolean"
              }
            },
            "required": [
              "bookmark",
              "hasMore"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "docs",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateUtilityPagePayload": {
        "properties": {
          "metadata": {
            "description": "The overall metadata for the listing",
            "$ref": "#/components/schemas/iMetadataWithoutInternals"
          },
          "content": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageContent"
            },
            "description": "The content for the listing",
            "type": "array"
          },
          "links": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageLink"
            },
            "description": "The links for the listing",
            "type": "array"
          },
          "type": {
            "description": "The type of the listing",
            "type": "string"
          },
          "visibility": {
            "enum": [
              "public",
              "private",
              "unlisted"
            ],
            "description": "The visibility of the listing",
            "type": "string"
          },
          "displayTimes": {
            "description": "The display times of the listing. Optionally specify when to show vs not show the listing.",
            "$ref": "#/components/schemas/iUintRange"
          },
          "directLink": {
            "description": "The direct link for the listing. If specified, we will skip the entire content / listing page. Thus, content and links should be empty [].",
            "type": "string"
          },
          "categories": {
            "items": {
              "type": "string"
            },
            "description": "The categories of the listing",
            "type": "array"
          },
          "linkedTo": {
            "description": "The details for if this listing is linked to a specific collection or list (displayed in Utility tab)",
            "$ref": "#/components/schemas/iLinkedTo"
          },
          "inheritMetadataFrom": {
            "description": "Where to inherit metadata from? Only one can be specified.",
            "$ref": "#/components/schemas/iInheritMetadataFrom"
          },
          "locale": {
            "description": "Locale (ex: es, fr, etc.). If not specified, we assume en.",
            "type": "string"
          },
          "estimatedCost": {
            "description": "The estimated cost for this utility/service",
            "$ref": "#/components/schemas/iEstimatedCost"
          },
          "estimatedTime": {
            "description": "The estimated time to complete or deliver this utility/service",
            "type": "string"
          }
        },
        "required": [
          "metadata",
          "content",
          "links",
          "type",
          "visibility",
          "categories"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCreateUtilityPageSuccessResponse": {
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/iUtilityPageDoc"
          }
        },
        "required": [
          "doc"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateUtilityPagePayload": {
        "properties": {
          "listingId": {
            "description": "The listing ID to update",
            "type": "string"
          },
          "metadata": {
            "description": "The overall metadata for the listing",
            "$ref": "#/components/schemas/iMetadataWithoutInternals"
          },
          "content": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageContent"
            },
            "description": "The content for the listing. This is only used for a dedicated listing page (not compatible with direct link or inherited metadata).",
            "type": "array"
          },
          "links": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageLink"
            },
            "description": "The links for the listing. This is only used for a dedicated listing page (not compatible with direct link or inherited metadata).",
            "type": "array"
          },
          "visibility": {
            "enum": [
              "public",
              "private",
              "unlisted"
            ],
            "description": "The visibility of the listing",
            "type": "string"
          },
          "displayTimes": {
            "description": "The display times of the listing. Optionally specify when to show vs not show the listing.",
            "$ref": "#/components/schemas/iUintRange"
          },
          "directLink": {
            "description": "The direct link for the listing. If specified, we will skip the entire content / listing page. Thus, content and links should be empty [].\n\nThis is incompatible with inherited metadata.",
            "type": "string"
          },
          "categories": {
            "items": {
              "type": "string"
            },
            "description": "The categories of the listing",
            "type": "array"
          },
          "linkedTo": {
            "description": "The details for if this listing is linked to a specific collection or list (displayed in Utility tab)",
            "$ref": "#/components/schemas/iLinkedTo"
          },
          "inheritMetadataFrom": {
            "description": "Where to inherit metadata from? Only one can be specified.\n\nIf specified, we automatically override the metadata from what is specified and\nautomatically set a direct link to the page.\n\nEx: Inherit claim metadata and direct link to the claim page.",
            "$ref": "#/components/schemas/iInheritMetadataFrom"
          },
          "locale": {
            "description": "Locale (ex: es, fr, etc.). If not specified, we assume \"en\" (English).",
            "type": "string"
          },
          "estimatedCost": {
            "description": "The estimated cost for this utility/service",
            "$ref": "#/components/schemas/iEstimatedCost"
          },
          "estimatedTime": {
            "description": "The estimated time to complete or deliver this utility/service",
            "type": "string"
          }
        },
        "required": [
          "listingId",
          "metadata",
          "content",
          "links",
          "visibility",
          "categories"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUpdateUtilityPageSuccessResponse": {
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/iUtilityPageDoc"
          }
        },
        "required": [
          "doc"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteUtilityPagePayload": {
        "properties": {
          "listingId": {
            "description": "The listing ID to delete",
            "type": "string"
          }
        },
        "required": [
          "listingId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDeleteUtilityPageSuccessResponse": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPostActionStatusesPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPostActionStatusesSuccessResponse": {
        "properties": {
          "postActionStatuses": {
            "items": {
              "properties": {
                "lastFetchedAt": {
                  "$ref": "#/components/schemas/UNIXMilliTimestamp"
                },
                "claimId": {
                  "type": "string"
                },
                "bitbadgesAddress": {
                  "type": "string",
                  "examples": [
                    "bb1..."
                  ]
                },
                "pluginId": {
                  "type": "string"
                },
                "claimAttemptId": {
                  "type": "string"
                },
                "numRetries": {
                  "$ref": "#/components/schemas/NumberType"
                },
                "nextFetchTime": {
                  "$ref": "#/components/schemas/UNIXMilliTimestamp"
                }
              },
              "required": [
                "lastFetchedAt",
                "claimId",
                "bitbadgesAddress",
                "pluginId",
                "claimAttemptId",
                "numRetries",
                "nextFetchTime"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "postActionStatuses"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPluginErrorsPayload": {
        "properties": {
          "pluginId": {
            "description": "The plugin ID to get errors for",
            "type": "string"
          },
          "bookmark": {
            "description": "The pagination bookmark to start from",
            "type": "string"
          }
        },
        "required": [
          "pluginId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "PluginErrorDoc": {
        "properties": {
          "_docId": {
            "type": "string"
          },
          "_id": {
            "type": "string"
          },
          "pluginId": {
            "type": "string"
          },
          "timestamp": {
            "type": "number"
          },
          "error": {
            "type": "string"
          },
          "context": {}
        },
        "required": [
          "_docId",
          "pluginId",
          "timestamp",
          "error"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetPluginErrorsSuccessResponse": {
        "properties": {
          "docs": {
            "items": {
              "$ref": "#/components/schemas/PluginErrorDoc"
            },
            "type": "array"
          },
          "bookmark": {
            "type": "string"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "docs"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iScheduleTokenRefreshPayload": {
        "properties": {
          "provider": {
            "type": "string"
          },
          "claimId": {
            "type": "string"
          },
          "instanceId": {
            "type": "string"
          }
        },
        "required": [
          "provider"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iScheduleTokenRefreshSuccessResponse": {
        "properties": {
          "message": {
            "type": "string"
          },
          "docId": {
            "type": "string"
          }
        },
        "required": [
          "message",
          "docId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCheckClaimSuccessPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iCheckClaimSuccessSuccessResponse": {
        "properties": {
          "successCount": {
            "type": "number"
          },
          "claimNumbers": {
            "items": {
              "type": "number"
            },
            "description": "If indexed, the claim numbers that were successfully completed (zero-based)",
            "type": "array"
          }
        },
        "required": [
          "successCount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionAmountTrackerByIdPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionAmountTrackerByIdSuccessResponse": {
        "properties": {
          "amountTracker": {
            "$ref": "#/components/schemas/iApprovalTrackerDoc"
          }
        },
        "required": [
          "amountTracker"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionChallengeTrackerByIdPayload": {
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionChallengeTrackerByIdSuccessResponse": {
        "properties": {
          "challengeTracker": {
            "$ref": "#/components/schemas/iApprovalTrackerDoc"
          }
        },
        "required": [
          "challengeTracker"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetSwapActivitiesPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          }
        },
        "additionalProperties": false,
        "description": "Get Swap Activities\nRoute: GET /api/:version/swapActivities",
        "type": "object"
      },
      "iGetOnChainDynamicStorePayload": {
        "additionalProperties": false,
        "description": "Get On-Chain Dynamic Store by ID\nRoute: GET /api/:version/onChainDynamicStore/:storeId",
        "type": "object"
      },
      "iGetOnChainDynamicStoresByCreatorPayload": {
        "additionalProperties": false,
        "description": "Get On-Chain Dynamic Stores by Creator\nRoute: GET /api/:version/onChainDynamicStores/by-creator/:address",
        "type": "object"
      },
      "iGetOnChainDynamicStoreValuePayload": {
        "additionalProperties": false,
        "description": "Get On-Chain Dynamic Store Value\nRoute: GET /api/:version/onChainDynamicStore/:storeId/value/:address",
        "type": "object"
      },
      "iGetOnChainDynamicStoreValuesPaginatedPayload": {
        "properties": {
          "bookmark": {
            "type": "string"
          }
        },
        "additionalProperties": false,
        "description": "Get On-Chain Dynamic Store Values (Paginated)\nRoute: GET /api/:version/onChainDynamicStore/:storeId/values",
        "type": "object"
      },
      "iAssetDetails": {
        "properties": {
          "chain": {
            "type": "string"
          },
          "collectionId": {
            "type": "string"
          },
          "assetIds": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/iUintRange"
                }
              ]
            },
            "type": "array"
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "mustOwnAmounts": {
            "$ref": "#/components/schemas/iUintRange"
          },
          "additionalCriteria": {
            "type": "string"
          },
          "ownershipPartyCheck": {
            "type": "string"
          }
        },
        "required": [
          "chain",
          "collectionId",
          "assetIds",
          "ownershipTimes",
          "mustOwnAmounts"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "SiwbbAssetConditionGroup": {
        "$ref": "#/components/schemas/OwnershipRequirements"
      },
      "iMetadata": {
        "properties": {
          "name": {
            "description": "The name of this item.",
            "type": "string",
            "examples": [
              "Name"
            ]
          },
          "description": {
            "description": "The description of this item. Supports markdown.",
            "type": "string",
            "examples": [
              "Brief description."
            ]
          },
          "image": {
            "description": "The image for this item.",
            "type": "string",
            "examples": [
              "https://example.com/image.png",
              "ipfs://Qm..."
            ]
          },
          "bannerImage": {
            "description": "The banner image for this item.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "category": {
            "description": "The category for this item (e.g. \"Education\", \"Attendance\").",
            "type": "string"
          },
          "externalUrl": {
            "description": "The external URL for this item.",
            "type": "string"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "description": "The tags for this item",
            "type": "array"
          },
          "socials": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "The socials for this item",
            "type": "object"
          },
          "attributes": {
            "items": {
              "properties": {
                "type": {
                  "type": "string"
                },
                "name": {
                  "type": "string",
                  "examples": [
                    "Name"
                  ]
                },
                "value": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    }
                  ]
                }
              },
              "required": [
                "type",
                "name",
                "value"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "The attributes for this item",
            "type": "array"
          },
          "additionalInfo": {
            "items": {
              "properties": {
                "name": {
                  "type": "string",
                  "examples": [
                    "Name"
                  ]
                },
                "image": {
                  "type": "string",
                  "examples": [
                    "https://example.com/image.png",
                    "ipfs://Qm..."
                  ]
                },
                "description": {
                  "type": "string",
                  "examples": [
                    "Brief description."
                  ]
                },
                "url": {
                  "type": "string"
                }
              },
              "required": [
                "name",
                "image",
                "description"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "Header links for this item displayed right under the title",
            "type": "array"
          },
          "fetchedAtBlock": {
            "description": "The block the metadata was fetched at.",
            "$ref": "#/components/schemas/NumberType"
          },
          "fetchedAt": {
            "description": "The time the metadata was fetched.",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "_isUpdating": {
            "description": "Whether the metadata is currently being updated.",
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "description",
          "image"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMetadataWithoutInternals": {
        "properties": {
          "name": {
            "description": "The name of this item.",
            "type": "string",
            "examples": [
              "Name"
            ]
          },
          "description": {
            "description": "The description of this item. Supports markdown.",
            "type": "string",
            "examples": [
              "Brief description."
            ]
          },
          "image": {
            "description": "The image for this item.",
            "type": "string",
            "examples": [
              "https://example.com/image.png",
              "ipfs://Qm..."
            ]
          },
          "bannerImage": {
            "description": "The banner image for this item.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "category": {
            "description": "The category for this item (e.g. \"Education\", \"Attendance\").",
            "type": "string"
          },
          "externalUrl": {
            "description": "The external URL for this item.",
            "type": "string"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "description": "The tags for this item",
            "type": "array"
          },
          "socials": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "The socials for this item",
            "type": "object"
          },
          "attributes": {
            "items": {
              "properties": {
                "type": {
                  "type": "string"
                },
                "name": {
                  "type": "string",
                  "examples": [
                    "Name"
                  ]
                },
                "value": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    }
                  ]
                }
              },
              "required": [
                "type",
                "name",
                "value"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "The attributes for this item",
            "type": "array"
          },
          "additionalInfo": {
            "items": {
              "properties": {
                "name": {
                  "type": "string",
                  "examples": [
                    "Name"
                  ]
                },
                "image": {
                  "type": "string",
                  "examples": [
                    "https://example.com/image.png",
                    "ipfs://Qm..."
                  ]
                },
                "description": {
                  "type": "string",
                  "examples": [
                    "Brief description."
                  ]
                },
                "url": {
                  "type": "string"
                }
              },
              "required": [
                "name",
                "image",
                "description"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "Header links for this item displayed right under the title",
            "type": "array"
          }
        },
        "required": [
          "name",
          "description",
          "image"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iTokenMetadataDetails": {
        "properties": {
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs that correspond to the metadata",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "metadata": {
            "description": "The metadata fetched by the URI",
            "$ref": "#/components/schemas/iMetadata"
          },
          "uri": {
            "description": "The URI that the metadata was fetched from. This is the original on-chain URI, so may still have placeholders (i.e. {id} or {address})",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "fetchedUri": {
            "description": "The URI that the metadata was fetched from with placeholders replaced.",
            "type": "string"
          },
          "customData": {
            "description": "Custom data",
            "type": "string"
          },
          "toUploadToIpfs": {
            "description": "Flag to denote if the metadata is new and should be updated. Used internally.",
            "type": "boolean"
          }
        },
        "required": [
          "tokenIds",
          "uri",
          "customData"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCollectionMetadataDetails": {
        "properties": {
          "metadata": {
            "description": "The metadata fetched by the URI",
            "$ref": "#/components/schemas/iMetadata"
          },
          "uri": {
            "description": "The URI that the metadata was fetched from. This is the original on-chain URI, so may still have placeholders (i.e. {id} or {address})",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "fetchedUri": {
            "description": "The URI that the metadata was fetched from with placeholders replaced.",
            "type": "string"
          },
          "customData": {
            "description": "Custom data",
            "type": "string"
          },
          "toUploadToIpfs": {
            "description": "Flag to denote if the metadata is new and should be updated. Used internally.",
            "type": "boolean"
          }
        },
        "required": [
          "uri",
          "customData"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iBitBadgesCollection": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "collectionId": {
            "description": "The collection ID",
            "$ref": "#/components/schemas/CollectionId"
          },
          "collectionMetadata": {
            "description": "The collection metadata",
            "$ref": "#/components/schemas/iCollectionMetadata"
          },
          "tokenMetadata": {
            "items": {
              "$ref": "#/components/schemas/iTokenMetadata"
            },
            "description": "The token metadata",
            "type": "array"
          },
          "customData": {
            "description": "The custom data",
            "type": "string"
          },
          "manager": {
            "description": "The manager",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionApprovals": {
            "allOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/iCollectionApproval"
                },
                "description": "The collection approved transfers timeline",
                "type": "array"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/iCollectionApproval"
                },
                "description": "The collection approvals for this collection, with off-chain metadata populated.",
                "type": "array"
              }
            ]
          },
          "standards": {
            "items": {
              "type": "string"
            },
            "description": "The standards",
            "type": "array"
          },
          "isArchived": {
            "description": "The is archived flag",
            "type": "boolean"
          },
          "createdBy": {
            "description": "The BitBadges address of the user who created this collection",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "createdBlock": {
            "description": "The block number when this collection was created",
            "$ref": "#/components/schemas/NumberType"
          },
          "createdTimestamp": {
            "description": "The timestamp when this collection was created (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "updateHistory": {
            "items": {
              "$ref": "#/components/schemas/iUpdateHistory"
            },
            "description": "The update history of this collection",
            "type": "array"
          },
          "validTokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "Valid token IDs for the collection",
            "type": "array"
          },
          "mintEscrowAddress": {
            "description": "Mint escrow address",
            "type": "string"
          },
          "cosmosCoinWrapperPaths": {
            "allOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/iCosmosCoinWrapperPath"
                },
                "description": "The IBC wrapper paths for the collection",
                "type": "array"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/iCosmosCoinWrapperPath"
                },
                "description": "The IBC wrapper paths for the collection, with off-chain metadata populated.",
                "type": "array"
              }
            ]
          },
          "aliasPaths": {
            "allOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/iAliasPath"
                },
                "description": "The alias (non-wrapping) paths for the collection",
                "type": "array"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/iAliasPath"
                },
                "description": "The alias (non-wrapping) paths for the collection, with off-chain metadata populated.",
                "type": "array"
              }
            ]
          },
          "invariants": {
            "description": "Collection-level invariants that cannot be broken. These are set upon genesis and cannot be modified.",
            "$ref": "#/components/schemas/iCollectionInvariants"
          },
          "activity": {
            "items": {
              "$ref": "#/components/schemas/iTransferActivityDoc"
            },
            "description": "The fetched activity for this collection. Returned collections will only fetch the current page. Use the pagination to fetch more. To be used in conjunction with views.",
            "type": "array"
          },
          "owners": {
            "items": {
              "$ref": "#/components/schemas/iBalanceDoc"
            },
            "description": "The fetched owners of this collection. Returned collections will only fetch the current page. Use the pagination to fetch more. To be used in conjunction with views.",
            "type": "array"
          },
          "challengeTrackers": {
            "items": {
              "$ref": "#/components/schemas/iMerkleChallengeTrackerDoc"
            },
            "description": "The fetched merkle challenge trackers for this collection. Returned collections will only fetch the current page. Use the pagination to fetch more. To be used in conjunction with views.",
            "type": "array"
          },
          "approvalTrackers": {
            "items": {
              "$ref": "#/components/schemas/iApprovalTrackerDoc"
            },
            "description": "The fetched approval trackers for this collection. Returned collections will only fetch the current page. Use the pagination to fetch more. To be used in conjunction with views.",
            "type": "array"
          },
          "listings": {
            "items": {
              "$ref": "#/components/schemas/iUtilityPageDoc"
            },
            "description": "The listings for this collection.",
            "type": "array"
          },
          "nsfw": {
            "description": "The token IDs in this collection that are marked as NSFW.",
            "$ref": "#/components/schemas/iCollectionNSFW"
          },
          "reported": {
            "description": "The token IDs in this collection that have been reported.",
            "$ref": "#/components/schemas/iCollectionNSFW"
          },
          "views": {
            "additionalProperties": {
              "properties": {
                "ids": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "type": {
                  "type": "string"
                },
                "pagination": {
                  "$ref": "#/components/schemas/PaginationInfo"
                }
              },
              "required": [
                "ids",
                "type",
                "pagination"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "The views for this collection and their pagination Doc. Views will only include the doc _ids. Use the pagination to fetch more. For example, if you want to fetch the activity for a view, you would use the view's pagination to fetch the doc _ids, then use the corresponding activity array to find the matching docs.",
            "type": "object"
          },
          "claims": {
            "items": {
              "$ref": "#/components/schemas/iClaimDetails"
            },
            "description": "Details about any off-chain claims for this collection. Only applicable when outsourced to BitBadges.",
            "type": "array"
          },
          "stats": {
            "description": "The stats for this collection.",
            "$ref": "#/components/schemas/iCollectionStatsDoc"
          },
          "tokenFloorPrices": {
            "items": {
              "$ref": "#/components/schemas/iTokenFloorPriceDoc"
            },
            "description": "The floor prices for this collection.",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "collectionId",
          "collectionMetadata",
          "tokenMetadata",
          "customData",
          "manager",
          "collectionApprovals",
          "standards",
          "isArchived",
          "createdBy",
          "createdBlock",
          "createdTimestamp",
          "updateHistory",
          "validTokenIds",
          "mintEscrowAddress",
          "cosmosCoinWrapperPaths",
          "aliasPaths",
          "invariants",
          "activity",
          "owners",
          "challengeTrackers",
          "approvalTrackers",
          "listings",
          "views",
          "claims"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "iCollectionNSFW": {
        "properties": {
          "tokenIds": {
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "reason": {
            "type": "string"
          }
        },
        "required": [
          "tokenIds",
          "reason"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "CollectionMap": {
        "additionalProperties": {
          "anyOf": []
        },
        "type": "object"
      },
      "iGetCollectionsPayload": {
        "properties": {
          "collectionsToFetch": {
            "items": {
              "$ref": "#/components/schemas/GetCollectionRequestBody"
            },
            "type": "array"
          }
        },
        "required": [
          "collectionsToFetch"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetCollectionsSuccessResponse": {
        "properties": {
          "collections": {
            "items": {
              "$ref": "#/components/schemas/iBitBadgesCollection"
            },
            "type": "array"
          }
        },
        "required": [
          "collections"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iBitBadgesUserInfo": {
        "properties": {
          "_docId": {
            "description": "A unique stringified document ID",
            "type": "string"
          },
          "_id": {
            "description": "A unique document ID (Mongo DB ObjectID)",
            "type": "string"
          },
          "publicKey": {
            "description": "The public key of the account",
            "type": "string",
            "examples": [
              "AksB.... (base64)"
            ]
          },
          "accountNumber": {
            "description": "The account number of the account. This is the account number registered on the BitBadges blockchain.",
            "$ref": "#/components/schemas/NumberType"
          },
          "pubKeyType": {
            "description": "The public key type of the account",
            "type": "string"
          },
          "bitbadgesAddress": {
            "description": "The BitBadges address of the account",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "sequence": {
            "description": "The sequence of the account. This is the nonce for the blockchain for this account",
            "$ref": "#/components/schemas/NumberType"
          },
          "balances": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The BADGE balance of the account and other sdk.coin balances",
            "type": "array"
          },
          "fetchedProfile": {
            "enum": [
              "full",
              "partial"
            ],
            "description": "Whether we have already fetched the profile or not",
            "type": "string"
          },
          "seenActivity": {
            "description": "The timestamp of the last activity seen for this account (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "createdAt": {
            "description": "The timestamp of when this account was created (milliseconds since epoch)",
            "$ref": "#/components/schemas/UNIXMilliTimestamp"
          },
          "discord": {
            "description": "The Discord username of the account",
            "type": "string"
          },
          "twitter": {
            "description": "The Twitter username of the account",
            "type": "string"
          },
          "github": {
            "description": "The GitHub username of the account",
            "type": "string"
          },
          "telegram": {
            "description": "The Telegram username of the account",
            "type": "string"
          },
          "readme": {
            "description": "The readme of the account",
            "type": "string"
          },
          "affiliateCode": {
            "description": "Affiliate code",
            "type": "string"
          },
          "hiddenTokens": {
            "items": {
              "$ref": "#/components/schemas/iBatchTokenDetails"
            },
            "description": "The hidden badges of the account",
            "type": "array"
          },
          "profilePicUrl": {
            "description": "The profile picture URL of the account",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "bannerImage": {
            "description": "The banner image URL of the account",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "username": {
            "description": "The username of the account",
            "type": "string"
          },
          "latestSignedInChain": {
            "description": "The latest chain the user signed in with",
            "$ref": "#/components/schemas/SupportedChain"
          },
          "notifications": {
            "description": "The notifications of the account",
            "$ref": "#/components/schemas/iNotificationPreferences"
          },
          "socialConnections": {
            "description": "Social connections stored for the account",
            "$ref": "#/components/schemas/iSocialConnections"
          },
          "publicSocialConnections": {
            "description": "Public social connections stored for the account",
            "$ref": "#/components/schemas/iSocialConnections"
          },
          "resolvedName": {
            "description": "The resolved name of the account (e.g. ENS name).",
            "type": "string"
          },
          "avatar": {
            "description": "The avatar of the account.",
            "type": "string"
          },
          "chain": {
            "description": "The chain of the account.",
            "$ref": "#/components/schemas/SupportedChain"
          },
          "airdropped": {
            "description": "Indicates whether the account has claimed their airdrop.",
            "type": "boolean"
          },
          "collected": {
            "items": {
              "$ref": "#/components/schemas/iBalanceDoc"
            },
            "description": "A list of tokens that the account has collected. Paginated and fetched as needed. To be used in conjunction with views.",
            "type": "array"
          },
          "activity": {
            "items": {
              "$ref": "#/components/schemas/iTransferActivityDoc"
            },
            "description": "A list of transfer activity items for the account. Paginated and fetched as needed. To be used in conjunction with views.",
            "type": "array"
          },
          "claimActivity": {
            "items": {
              "$ref": "#/components/schemas/iClaimActivityDoc"
            },
            "description": "A list of claim activity items for the account. Paginated and fetched as needed. To be used in conjunction with views.",
            "type": "array"
          },
          "pointsActivity": {
            "items": {
              "$ref": "#/components/schemas/iPointsActivityDoc"
            },
            "description": "A list of points activity items for the account. Paginated and fetched as needed. To be used in conjunction with views.",
            "type": "array"
          },
          "challengeTrackers": {
            "items": {
              "$ref": "#/components/schemas/iMerkleChallengeTrackerDoc"
            },
            "description": "A list of merkle challenge activity items for the account. Paginated and fetched as needed. To be used in conjunction with views.",
            "type": "array"
          },
          "approvalTrackers": {
            "items": {
              "$ref": "#/components/schemas/iApprovalTrackerDoc"
            },
            "description": "A list of approvals tracker activity items for the account. Paginated and fetched as needed. To be used in conjunction with views.",
            "type": "array"
          },
          "siwbbRequests": {
            "items": {
              "$ref": "#/components/schemas/iSIWBBRequestDoc"
            },
            "description": "A list of SIWBB requests for the account. Paginated and fetched as needed. To be used in conjunction with views.",
            "type": "array"
          },
          "address": {
            "description": "The native address of the account",
            "$ref": "#/components/schemas/NativeAddress"
          },
          "nsfw": {
            "properties": {
              "reason": {
                "type": "string"
              }
            },
            "required": [
              "reason"
            ],
            "additionalProperties": false,
            "description": "Indicates whether the account is NSFW.",
            "type": "object"
          },
          "reported": {
            "properties": {
              "reason": {
                "type": "string"
              }
            },
            "required": [
              "reason"
            ],
            "additionalProperties": false,
            "description": "Indicates whether the account has been reported.",
            "type": "object"
          },
          "views": {
            "additionalProperties": {
              "properties": {
                "ids": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "type": {
                  "type": "string"
                },
                "pagination": {
                  "$ref": "#/components/schemas/PaginationInfo"
                }
              },
              "required": [
                "ids",
                "type",
                "pagination"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "The views for this collection and their pagination Doc. Views will only include the doc _ids. Use the pagination to fetch more.  For example, if you want to fetch the activity for a view, you would use the view's pagination to fetch the doc _ids, then use the corresponding activity array to find the matching docs.",
            "type": "object"
          },
          "alias": {
            "properties": {
              "collectionId": {
                "$ref": "#/components/schemas/CollectionId"
              }
            },
            "additionalProperties": false,
            "description": "For advanced cases where you want a custom address or account for a collection or list. We map it to an account.\n\nExperimental - For example, if you want to send a badge to a collection, you can transfer it to the alias account.",
            "type": "object"
          },
          "creatorCredits": {
            "description": "The credits for the account.",
            "$ref": "#/components/schemas/iCreatorCreditsDoc"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "description": "The tags for the account. Extra descriptors for what this address is used for (e.g. \"Pool\", \"Governance\",  etc).",
            "type": "array"
          }
        },
        "required": [
          "_docId",
          "publicKey",
          "accountNumber",
          "pubKeyType",
          "bitbadgesAddress",
          "chain",
          "collected",
          "activity",
          "challengeTrackers",
          "approvalTrackers",
          "siwbbRequests",
          "address",
          "views"
        ],
        "additionalProperties": false,
        "description": "BondStatus is the status of a validator.\n@generated from enum cosmos.staking.v1beta1.BondStatus",
        "type": "object"
      },
      "AccountMap": {
        "additionalProperties": {
          "anyOf": []
        },
        "description": "AccountMap is used to store the user information by address.",
        "type": "object"
      },
      "AccountViewKey": {
        "enum": [
          "siwbbRequests",
          "transferActivity",
          "tokensCollected",
          "createdTokens",
          "managingTokens",
          "publicClaimActivity",
          "allClaimActivity",
          "pointsActivity"
        ],
        "description": "The supported view keys for fetching account details.",
        "type": "string"
      },
      "AccountFetchDetails": {
        "properties": {
          "address": {
            "description": "The address of the user. This can be their native address. Only one of address or username should be specified.",
            "$ref": "#/components/schemas/NativeAddress"
          },
          "username": {
            "description": "The username of the user. Only one of address or username should be specified.",
            "type": "string"
          },
          "partialProfile": {
            "description": "If true, we will only fetch a partial set of the document for the user.\n\nCurrently includes: username, profile pic, and latest signed in chain\n\nPretty much, anything you need to display the address but not the full profile",
            "type": "boolean"
          },
          "viewsToFetch": {
            "items": {
              "properties": {
                "viewId": {
                  "description": "Unique view ID. Used for pagination. All fetches w/ same ID should be made with same criteria.",
                  "type": "string",
                  "examples": [
                    "viewKey"
                  ]
                },
                "viewType": {
                  "$ref": "#/components/schemas/AccountViewKey",
                  "description": "The base view type to fetch.",
                  "examples": [
                    "viewKey"
                  ]
                },
                "specificCollections": {
                  "items": {
                    "$ref": "#/components/schemas/iBatchTokenDetails"
                  },
                  "description": "If defined, we will filter the view to only include the specified collections.",
                  "type": "array"
                },
                "oldestFirst": {
                  "description": "Oldest first. By default, we fetch newest",
                  "type": "boolean"
                },
                "bookmark": {
                  "description": "A bookmark to pass in for pagination. \"\" for first request.",
                  "type": "string"
                },
                "standard": {
                  "description": "The standard to filter by for the view.",
                  "type": "string"
                }
              },
              "required": [
                "viewId",
                "viewType",
                "bookmark"
              ],
              "additionalProperties": false,
              "type": "object"
            },
            "description": "An array of views to fetch",
            "type": "array"
          }
        },
        "additionalProperties": false,
        "description": "This defines the options for fetching additional account details.\n\nA view is a way of fetching additional details about an account, and these will be queryable in the response via the `views` property.\n\nEach view has a bookmark that is used for pagination and must be supplied to get the next page.",
        "type": "object"
      },
      "iGetAccountPayload": {
        "properties": {
          "address": {
            "$ref": "#/components/schemas/NativeAddress"
          },
          "username": {
            "type": "string"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iGetAccountSuccessResponse": {
        "properties": {
          "account": {
            "$ref": "#/components/schemas/iBitBadgesUserInfo"
          }
        },
        "required": [
          "account"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetAccountsPayload": {
        "properties": {
          "accountsToFetch": {
            "items": {
              "$ref": "#/components/schemas/AccountFetchDetails"
            },
            "type": "array"
          }
        },
        "required": [
          "accountsToFetch"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iGetAccountsSuccessResponse": {
        "properties": {
          "accounts": {
            "items": {
              "$ref": "#/components/schemas/iBitBadgesUserInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "accounts"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUserPermissions": {
        "properties": {
          "canUpdateOutgoingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserOutgoingApprovalPermission"
            },
            "description": "The list of permissions for updating approved outgoing transfers.",
            "type": "array"
          },
          "canUpdateIncomingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserIncomingApprovalPermission"
            },
            "description": "The list of permissions for updating approved incoming transfers.",
            "type": "array"
          },
          "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for updating auto-approving self-initiated outgoing transfers. If auto-approve is enabled, then the user will be approved by default for all outgoing transfers that are self-initiated.",
            "type": "array"
          },
          "canUpdateAutoApproveSelfInitiatedIncomingTransfers": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for updating auto-approving self-initiated incoming transfers. If auto-approve is enabled, then the user will be approved by default for all incoming transfers that are self-initiated.",
            "type": "array"
          },
          "canUpdateAutoApproveAllIncomingTransfers": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for updating auto-approving all incoming transfers. If auto-approve is enabled, then the user will be approved by default for all incoming transfers.",
            "type": "array"
          }
        },
        "required": [
          "canUpdateOutgoingApprovals",
          "canUpdateIncomingApprovals",
          "canUpdateAutoApproveSelfInitiatedOutgoingTransfers",
          "canUpdateAutoApproveSelfInitiatedIncomingTransfers",
          "canUpdateAutoApproveAllIncomingTransfers"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUserOutgoingApprovalPermission": {
        "properties": {
          "toListId": {
            "description": "The list ID of the to addresses of the approved outgoing transfers.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "toList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "initiatedByListId": {
            "description": "The list ID of the initiatedBy addresses of the approved outgoing transfers.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "initiatedByList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "transferTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The transfer times of the approved outgoing transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs of the approved outgoing transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The owned times of the approved outgoing transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "approvalId": {
            "description": "The approval ID of the approved outgoing transfers. Can use \"All\" to represent all IDs, \"!approvalId\" to represent all IDs except approvalId, or \"approvalId\" to represent only approvalId.",
            "type": "string"
          },
          "permanentlyPermittedTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The permitted times of the approved outgoing transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "permanentlyForbiddenTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The forbidden times of the approved outgoing transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          }
        },
        "required": [
          "toListId",
          "toList",
          "initiatedByListId",
          "initiatedByList",
          "transferTimes",
          "tokenIds",
          "ownershipTimes",
          "approvalId",
          "permanentlyPermittedTimes",
          "permanentlyForbiddenTimes"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUserIncomingApprovalPermission": {
        "properties": {
          "fromListId": {
            "description": "The list ID of the from addresses of the approved incoming transfers.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "fromList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "initiatedByListId": {
            "description": "The list ID of the initiatedBy addresses of the approved incoming transfers.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "initiatedByList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "transferTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The transfer times of the approved incoming transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs of the approved incoming transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The owned times of the approved incoming transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "approvalId": {
            "description": "The approval ID of the approved incoming transfers. Can use \"All\" to represent all IDs, \"!approvalId\" to represent all IDs except approvalId, or \"approvalId\" to represent only approvalId.",
            "type": "string"
          },
          "permanentlyPermittedTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The permitted times of the approved incoming transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "permanentlyForbiddenTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The forbidden times of the approved incoming transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          }
        },
        "required": [
          "fromListId",
          "fromList",
          "initiatedByListId",
          "initiatedByList",
          "transferTimes",
          "tokenIds",
          "ownershipTimes",
          "approvalId",
          "permanentlyPermittedTimes",
          "permanentlyForbiddenTimes"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCollectionPermissions": {
        "properties": {
          "canDeleteCollection": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for deleting the collection.",
            "type": "array"
          },
          "canArchiveCollection": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for archiving the collection.",
            "type": "array"
          },
          "canUpdateStandards": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for updating the standards.",
            "type": "array"
          },
          "canUpdateCustomData": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for updating the custom data.",
            "type": "array"
          },
          "canUpdateManager": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for updating the manager.",
            "type": "array"
          },
          "canUpdateCollectionMetadata": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for updating the collection metadata.",
            "type": "array"
          },
          "canUpdateValidTokenIds": {
            "items": {
              "$ref": "#/components/schemas/iTokenIdsActionPermission"
            },
            "description": "The permissions for creating more tokens.",
            "type": "array"
          },
          "canUpdateTokenMetadata": {
            "items": {
              "$ref": "#/components/schemas/iTokenIdsActionPermission"
            },
            "description": "The permissions for updating the token metadata.",
            "type": "array"
          },
          "canUpdateCollectionApprovals": {
            "items": {
              "$ref": "#/components/schemas/iCollectionApprovalPermission"
            },
            "description": "The permissions for updating the collection approved transfers.",
            "type": "array"
          },
          "canAddMoreAliasPaths": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for adding more alias paths to the collection.",
            "type": "array"
          },
          "canAddMoreCosmosCoinWrapperPaths": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "The permissions for adding more cosmos coin wrapper paths to the collection.",
            "type": "array"
          }
        },
        "required": [
          "canDeleteCollection",
          "canArchiveCollection",
          "canUpdateStandards",
          "canUpdateCustomData",
          "canUpdateManager",
          "canUpdateCollectionMetadata",
          "canUpdateValidTokenIds",
          "canUpdateTokenMetadata",
          "canUpdateCollectionApprovals",
          "canAddMoreAliasPaths",
          "canAddMoreCosmosCoinWrapperPaths"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iActionPermission": {
        "properties": {
          "permanentlyPermittedTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The permitted times of the permission.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "permanentlyForbiddenTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The forbidden times of the permission.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          }
        },
        "required": [
          "permanentlyPermittedTimes",
          "permanentlyForbiddenTimes"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iTokenIdsActionPermission": {
        "properties": {
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs that the permission applies to.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "permanentlyPermittedTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The permitted times of the permission.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "permanentlyForbiddenTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The forbidden times of the permission.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          }
        },
        "required": [
          "tokenIds",
          "permanentlyPermittedTimes",
          "permanentlyForbiddenTimes"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCollectionApprovalPermission": {
        "properties": {
          "fromListId": {
            "description": "The list ID of the from addresses of the approved transfers.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "fromList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "toListId": {
            "description": "The list ID of the to addresses of the approved transfers.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "toList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "initiatedByListId": {
            "description": "The list ID of the initiatedBy addresses of the approved transfers.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "initiatedByList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "transferTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The transfer times of the approved transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs of the approved transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The owned times of the approved transfers.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "approvalId": {
            "description": "The approval ID of the approved transfers. Can use \"All\" to represent all IDs, \"!approvalId\" to represent all IDs except approvalId, or \"approvalId\" to represent only approvalId.",
            "type": "string"
          },
          "permanentlyPermittedTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The permitted times of this permission.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "permanentlyForbiddenTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The forbidden times of this permission.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          }
        },
        "required": [
          "fromListId",
          "fromList",
          "toListId",
          "toList",
          "initiatedByListId",
          "initiatedByList",
          "transferTimes",
          "tokenIds",
          "ownershipTimes",
          "approvalId",
          "permanentlyPermittedTimes",
          "permanentlyForbiddenTimes"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPermissionCriteria": {
        "properties": {
          "approvedAddresses": {
            "items": {
              "type": "string"
            },
            "description": "List of approved addresses that can execute this permission.",
            "type": "array"
          }
        },
        "required": [
          "approvedAddresses"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iManagerSplitterPermissions": {
        "properties": {
          "canDeleteCollection": {
            "description": "Permissions related to deleting the collection.",
            "$ref": "#/components/schemas/iPermissionCriteria"
          },
          "canArchiveCollection": {
            "description": "Permissions related to archiving the collection.",
            "$ref": "#/components/schemas/iPermissionCriteria"
          },
          "canUpdateStandards": {
            "description": "Permissions related to updating standards for the collection.",
            "$ref": "#/components/schemas/iPermissionCriteria"
          },
          "canUpdateCustomData": {
            "description": "Permissions related to updating custom data for the collection.",
            "$ref": "#/components/schemas/iPermissionCriteria"
          },
          "canUpdateManager": {
            "description": "Permissions related to updating the collection's manager.",
            "$ref": "#/components/schemas/iPermissionCriteria"
          },
          "canUpdateCollectionMetadata": {
            "description": "Permissions related to updating the metadata of the collection.",
            "$ref": "#/components/schemas/iPermissionCriteria"
          },
          "canUpdateValidTokenIds": {
            "description": "Permissions related to creating more tokens for the collection.",
            "$ref": "#/components/schemas/iPermissionCriteria"
          },
          "canUpdateTokenMetadata": {
            "description": "Permissions related to updating token metadata for specific tokens.",
            "$ref": "#/components/schemas/iPermissionCriteria"
          },
          "canUpdateCollectionApprovals": {
            "description": "Permissions related to updating collection approvals.",
            "$ref": "#/components/schemas/iPermissionCriteria"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iUserBalanceStore": {
        "properties": {
          "balances": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "The user's balances.",
            "type": "array"
          },
          "incomingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserIncomingApproval"
            },
            "description": "The user's incoming approvals.",
            "type": "array"
          },
          "outgoingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserOutgoingApproval"
            },
            "description": "The user's outgoing approvals.",
            "type": "array"
          },
          "userPermissions": {
            "description": "The user's permissions.",
            "$ref": "#/components/schemas/iUserPermissions"
          },
          "autoApproveSelfInitiatedOutgoingTransfers": {
            "description": "Whether the user's self-initiated outgoing transfers are auto-approved. If not, they must be explicitly approved using the outgoing approvals.",
            "type": "boolean"
          },
          "autoApproveSelfInitiatedIncomingTransfers": {
            "description": "Whether the user's self-initiated incoming transfers are auto-approved. If not, they must be explicitly approved using the incoming approvals.",
            "type": "boolean"
          },
          "autoApproveAllIncomingTransfers": {
            "description": "Whether the user's all incoming transfers are auto-approved. If not, they must be explicitly approved using the incoming approvals.",
            "type": "boolean"
          }
        },
        "required": [
          "balances",
          "incomingApprovals",
          "outgoingApprovals",
          "userPermissions",
          "autoApproveSelfInitiatedOutgoingTransfers",
          "autoApproveSelfInitiatedIncomingTransfers",
          "autoApproveAllIncomingTransfers"
        ],
        "additionalProperties": false,
        "description": "This stores everythign about a user's balances for a specific collection ID.\nThis includes their balances, incoming approvals, outgoing approvals, and permissions.",
        "type": "object"
      },
      "iUintRange": {
        "properties": {
          "start": {
            "description": "The start of the range.",
            "$ref": "#/components/schemas/NumberType"
          },
          "end": {
            "description": "The end of the range, inclusive.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "start",
          "end"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iTokenMetadata": {
        "properties": {
          "uri": {
            "description": "The URI where to fetch the token metadata from.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs corresponding to the URI.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "customData": {
            "description": "Arbitrary custom data that can be stored on-chain",
            "type": "string"
          }
        },
        "required": [
          "uri",
          "tokenIds",
          "customData"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCollectionMetadata": {
        "properties": {
          "uri": {
            "description": "The URI where to fetch the collection metadata from.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Arbitrary custom data that can be stored on-chain",
            "type": "string"
          }
        },
        "required": [
          "uri",
          "customData"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPathMetadata": {
        "properties": {
          "uri": {
            "description": "The URI (Uniform Resource Identifier) associated with the path metadata.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Custom data or additional information related to the path metadata.",
            "type": "string"
          }
        },
        "required": [
          "uri",
          "customData"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMustOwnTokens": {
        "properties": {
          "collectionId": {
            "description": "The collection IDs to own.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "amountRange": {
            "description": "The min/max acceptable amount of tokens that must be owned (can be any values, including 0-0).",
            "$ref": "#/components/schemas/iUintRange"
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The range of the times that the tokens must be owned.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The range of the token IDs that must be owned.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "overrideWithCurrentTime": {
            "description": "Whether or not to override the ownershipTimes with the current time.",
            "type": "boolean"
          },
          "mustSatisfyForAllAssets": {
            "description": "Whether or not the user must own all the specified tokens. If false, we will accept if they meet criteria for at least one token.",
            "type": "boolean"
          },
          "ownershipCheckParty": {
            "description": "The party to check ownership for. Options are \"initiator\", \"sender\", or \"recipient\". Defaults to \"initiator\" if empty.",
            "type": "string"
          }
        },
        "required": [
          "collectionId",
          "amountRange",
          "ownershipTimes",
          "tokenIds",
          "overrideWithCurrentTime",
          "mustSatisfyForAllAssets"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iBalance": {
        "properties": {
          "amount": {
            "description": "The amount or balance of the owned token.",
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs corresponding to the balance.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The times that the token is owned from.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          }
        },
        "required": [
          "amount",
          "tokenIds",
          "ownershipTimes"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAddressList": {
        "properties": {
          "listId": {
            "description": "The ID of the address list.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "addresses": {
            "items": {
              "type": "string"
            },
            "description": "The addresses of the address list. If this is a tracker list, the addresses are the tracker IDs.",
            "type": "array"
          },
          "whitelist": {
            "description": "Whether or not to include ONLY the addresses or include all EXCEPT the addresses.",
            "type": "boolean"
          },
          "uri": {
            "description": "The URI where to fetch the address list metadata from.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Arbitrary custom data that can be stored. Leave blank for no custom data.",
            "type": "string"
          },
          "createdBy": {
            "description": "The address that created the address list. Handled internally.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "listId",
          "addresses",
          "whitelist",
          "uri",
          "customData"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iConversionSideAWithDenom": {
        "properties": {
          "amount": {
            "description": "The amount of the cosmos coin (0 decimals).",
            "$ref": "#/components/schemas/NumberType"
          },
          "denom": {
            "description": "The denomination of the cosmos coin.",
            "type": "string"
          }
        },
        "required": [
          "amount",
          "denom"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iConversionSideA": {
        "properties": {
          "amount": {
            "description": "The amount of the cosmos coin (0 decimals).",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "amount"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iConversion": {
        "properties": {
          "sideA": {
            "description": "Side A: The cosmos coin side of the conversion (amount + denom).",
            "$ref": "#/components/schemas/iConversionSideAWithDenom"
          },
          "sideB": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "Side B: The badge balances side of the conversion.",
            "type": "array"
          }
        },
        "required": [
          "sideA",
          "sideB"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iConversionWithoutDenom": {
        "properties": {
          "sideA": {
            "description": "Side A: The cosmos coin amount side of the conversion (amount only, denom stored separately).",
            "$ref": "#/components/schemas/iConversionSideA"
          },
          "sideB": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "Side B: The badge balances side of the conversion.",
            "type": "array"
          }
        },
        "required": [
          "sideA",
          "sideB"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iDenomUnit": {
        "properties": {
          "decimals": {
            "description": "The number of decimal places for this denomination unit.",
            "$ref": "#/components/schemas/NumberType"
          },
          "symbol": {
            "description": "The symbol for this denomination unit.",
            "type": "string"
          },
          "isDefaultDisplay": {
            "description": "Whether this denomination unit is the default display unit.",
            "type": "boolean"
          },
          "metadata": {
            "description": "The metadata for this denomination unit.",
            "$ref": "#/components/schemas/iPathMetadata"
          }
        },
        "required": [
          "decimals",
          "symbol",
          "isDefaultDisplay",
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCosmosCoinWrapperPathAddObject": {
        "properties": {
          "denom": {
            "description": "The denom of the IBC wrapper path.",
            "type": "string"
          },
          "conversion": {
            "description": "The conversion between cosmos coin and badge balances.",
            "$ref": "#/components/schemas/iConversionWithoutDenom"
          },
          "symbol": {
            "description": "The symbol for this IBC wrapper path.",
            "type": "string"
          },
          "denomUnits": {
            "items": {
              "$ref": "#/components/schemas/iDenomUnit"
            },
            "description": "The denomination units for this IBC wrapper path.",
            "type": "array"
          },
          "allowOverrideWithAnyValidToken": {
            "description": "Whether to allow override with any valid token.",
            "type": "boolean"
          },
          "metadata": {
            "description": "The metadata for this wrapper path.",
            "$ref": "#/components/schemas/iPathMetadata"
          }
        },
        "required": [
          "denom",
          "conversion",
          "symbol",
          "denomUnits",
          "allowOverrideWithAnyValidToken",
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCosmosCoinBackedPathAddObject": {
        "properties": {
          "conversion": {
            "description": "The conversion between IBC cosmos coin and badge balances.",
            "$ref": "#/components/schemas/iConversion"
          }
        },
        "required": [
          "conversion"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCosmosCoinBackedPath": {
        "properties": {
          "address": {
            "description": "The address for this IBC backed path.",
            "type": "string"
          },
          "conversion": {
            "description": "The conversion between IBC cosmos coin and badge balances.",
            "$ref": "#/components/schemas/iConversion"
          }
        },
        "required": [
          "address",
          "conversion"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iInvariantsAddObject": {
        "properties": {
          "noCustomOwnershipTimes": {
            "description": "If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.",
            "type": "boolean"
          },
          "maxSupplyPerId": {
            "description": "Maximum supply per token ID. If set, no balance can exceed this amount.\nThis prevents any single token ID from having more than the specified supply.",
            "$ref": "#/components/schemas/NumberType"
          },
          "cosmosCoinBackedPath": {
            "description": "The IBC backed (sdk.coin) path for the collection. Only one path is allowed.\nAddress will be generated by the keeper.",
            "$ref": "#/components/schemas/iCosmosCoinBackedPathAddObject"
          },
          "noForcefulPostMintTransfers": {
            "description": "If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.\nThis prevents forceful post-mint transfers that bypass user-level approvals.",
            "type": "boolean"
          },
          "disablePoolCreation": {
            "description": "If true, disallows pool creation with this collection's assets.\nWhen true, any attempt to create a pool with badges assets from this collection will fail.",
            "type": "boolean"
          }
        },
        "required": [
          "noCustomOwnershipTimes",
          "maxSupplyPerId",
          "noForcefulPostMintTransfers",
          "disablePoolCreation"
        ],
        "additionalProperties": false,
        "description": "InvariantsAddObject is used for adding invariants without specifying addresses.\nAddresses are generated by the keeper and stored in the collection.",
        "type": "object"
      },
      "iAliasPathAddObject": {
        "properties": {
          "denom": {
            "description": "The denomination (denom) to be used for the alias.",
            "type": "string"
          },
          "conversion": {
            "description": "The conversion between cosmos coin and badge balances.",
            "$ref": "#/components/schemas/iConversionWithoutDenom"
          },
          "symbol": {
            "description": "The symbol for the alias (e.g., \"BADGE\", \"NFT\").",
            "type": "string"
          },
          "denomUnits": {
            "items": {
              "$ref": "#/components/schemas/iDenomUnit"
            },
            "description": "Denomination units for the alias. Defines how the coin can be displayed with different decimal places and symbols.",
            "type": "array"
          },
          "metadata": {
            "description": "The metadata for this alias path.",
            "$ref": "#/components/schemas/iPathMetadata"
          }
        },
        "required": [
          "denom",
          "conversion",
          "symbol",
          "denomUnits",
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iTransfer": {
        "properties": {
          "from": {
            "description": "The address to transfer from.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "toAddresses": {
            "items": {
              "$ref": "#/components/schemas/BitBadgesAddress"
            },
            "description": "The addresses to transfer to.",
            "type": "array"
          },
          "balances": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "The balances to transfer.",
            "type": "array"
          },
          "precalculateBalancesFromApproval": {
            "description": "If specified, we will precalculate from this approval and override the balances. This can only be used when the specified approval has predeterminedBalances set.",
            "$ref": "#/components/schemas/iPrecalculateBalancesFromApprovalDetails"
          },
          "merkleProofs": {
            "items": {
              "$ref": "#/components/schemas/iMerkleProof"
            },
            "description": "The merkle proofs that satisfy the mkerkle challenges in the approvals. If the transfer deducts from multiple approvals, we check all the merkle proofs and assert at least one is valid for every challenge.",
            "type": "array"
          },
          "ethSignatureProofs": {
            "items": {
              "$ref": "#/components/schemas/iETHSignatureProof"
            },
            "description": "The ETH signature proofs that satisfy the ETH signature challenges in the approvals. If the transfer deducts from multiple approvals, we check all the ETH signature proofs and assert at least one is valid for every challenge.",
            "type": "array"
          },
          "memo": {
            "description": "Arbitrary memo for the transfer.",
            "type": "string"
          },
          "prioritizedApprovals": {
            "items": {
              "$ref": "#/components/schemas/iApprovalIdentifierDetails"
            },
            "description": "The prioritized approvals to use for the transfer. If specified, we will check these first.",
            "type": "array"
          },
          "onlyCheckPrioritizedCollectionApprovals": {
            "description": "Whether or not to only check the prioritized approvals. If false, we will check all approvals with any prioritized first.\n\nThis only applies to the \"collection\" level approvals specified.",
            "type": "boolean"
          },
          "onlyCheckPrioritizedIncomingApprovals": {
            "description": "Whether or not to only check the prioritized approvals. If false, we will check all approvals with any prioritized first.\n\nThis only applies to the \"incoming\" level approvals specified.",
            "type": "boolean"
          },
          "onlyCheckPrioritizedOutgoingApprovals": {
            "description": "Whether or not to only check the prioritized approvals. If false, we will check all approvals with any prioritized first.\n\nThis only applies to the \"outgoing\" level approvals specified.",
            "type": "boolean"
          }
        },
        "required": [
          "from",
          "toAddresses",
          "balances"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iApprovalIdentifierDetails": {
        "properties": {
          "approvalId": {
            "description": "The approval ID of the approval.",
            "type": "string"
          },
          "approvalLevel": {
            "description": "The approval level of the approval \"collection\", \"incoming\", or \"outgoing\".",
            "type": "string",
            "examples": [
              "collection",
              "incoming",
              "outgoing"
            ]
          },
          "approverAddress": {
            "description": "The address of the approval to check. If approvalLevel is \"collection\", this is blank \"\".",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "version": {
            "description": "The version of the approval.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "approvalId",
          "approvalLevel",
          "approverAddress",
          "version"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPrecalculationOptions": {
        "properties": {
          "overrideTimestamp": {
            "description": "The timestamp to use for the transfer.",
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenIdsOverride": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs to use for the transfer.",
            "type": "array"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iPrecalculateBalancesFromApprovalDetails": {
        "properties": {
          "approvalId": {
            "description": "The approval ID of the approval.",
            "type": "string"
          },
          "approvalLevel": {
            "description": "The approval level of the approval \"collection\", \"incoming\", or \"outgoing\".",
            "type": "string",
            "examples": [
              "collection",
              "incoming",
              "outgoing"
            ]
          },
          "approverAddress": {
            "description": "The address of the approval to check. If approvalLevel is \"collection\", this is blank \"\".",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "version": {
            "description": "The version of the approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "precalculationOptions": {
            "description": "The options for precalculating the balances.",
            "$ref": "#/components/schemas/iPrecalculationOptions"
          }
        },
        "required": [
          "approvalId",
          "approvalLevel",
          "approverAddress",
          "version"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCoinTransfer": {
        "properties": {
          "to": {
            "description": "The recipient of the coin transfer. This should be a Bech32 BitBadges address.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "coins": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The coins",
            "type": "array"
          },
          "overrideFromWithApproverAddress": {
            "description": "Whether or not to override the from address with the approver address.",
            "type": "boolean"
          },
          "overrideToWithInitiator": {
            "description": "Whether or not to override the to address with the initiator of the transaction.",
            "type": "boolean"
          }
        },
        "required": [
          "to",
          "coins",
          "overrideFromWithApproverAddress",
          "overrideToWithInitiator"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "CollectionId": {
        "type": "string"
      },
      "iAmountTrackerIdDetails": {
        "properties": {
          "collectionId": {
            "description": "The collection ID for the approval.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "approvalId": {
            "description": "The approval ID",
            "type": "string"
          },
          "amountTrackerId": {
            "description": "The amount tracker ID of the approval.",
            "type": "string"
          },
          "approvalLevel": {
            "description": "The approval level of the approval \"collection\", \"incoming\", or \"outgoing\".",
            "type": "string",
            "examples": [
              "collection",
              "incoming",
              "outgoing"
            ]
          },
          "approverAddress": {
            "description": "The address of the approval to check.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "trackerType": {
            "description": "The type of tracker to check \"overall\", \"to\", \"from\", or \"initiatedBy\".",
            "type": "string"
          },
          "approvedAddress": {
            "description": "The address to check for the approval.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "collectionId",
          "approvalId",
          "amountTrackerId",
          "approvalLevel",
          "approverAddress",
          "trackerType",
          "approvedAddress"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMustOwnToken": {
        "properties": {
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "amountRange": {
            "description": "The range of amounts the user must own (min to max).",
            "$ref": "#/components/schemas/iUintRange"
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The time ranges during which the user must own the tokens.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs the user must own.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "overrideWithCurrentTime": {
            "description": "If true, override ownershipTimes with the current time.",
            "type": "boolean"
          },
          "mustSatisfyForAllAssets": {
            "description": "If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.",
            "type": "boolean"
          },
          "ownershipCheckParty": {
            "description": "The party to check ownership for. Options are \"initiator\", \"sender\", or \"recipient\". Defaults to \"initiator\" if empty.",
            "type": "string"
          }
        },
        "required": [
          "collectionId",
          "amountRange",
          "ownershipTimes",
          "tokenIds",
          "overrideWithCurrentTime",
          "mustSatisfyForAllAssets"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMerkleChallenge": {
        "properties": {
          "root": {
            "description": "The root of the merkle tree.",
            "type": "string"
          },
          "expectedProofLength": {
            "description": "The expected proof length of the merkle proof.",
            "$ref": "#/components/schemas/NumberType"
          },
          "useCreatorAddressAsLeaf": {
            "description": "Whether or not to override any leaf value and use the creator address as the leaf. Used for whitelist trees.",
            "type": "boolean"
          },
          "maxUsesPerLeaf": {
            "description": "Whether or not to enforce max uses per leaf. Used to prevent replay attacks.",
            "$ref": "#/components/schemas/NumberType"
          },
          "uri": {
            "description": "The URI where to fetch the merkle challenge metadata from.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Arbitrary custom data that can be stored on-chain.",
            "type": "string"
          },
          "challengeTrackerId": {
            "description": "Tracker ID details for the merkle challenge.",
            "type": "string"
          },
          "leafSigner": {
            "description": "The signer of the leaf. Currently only supports ETH addresses.",
            "type": "string"
          }
        },
        "required": [
          "root",
          "expectedProofLength",
          "useCreatorAddressAsLeaf",
          "maxUsesPerLeaf",
          "uri",
          "customData",
          "challengeTrackerId",
          "leafSigner"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMerklePathItem": {
        "properties": {
          "aunt": {
            "description": "The aunt of the merkle path item.",
            "type": "string"
          },
          "onRight": {
            "description": "Indicates whether the aunt node is on the right side of the path.",
            "type": "boolean"
          }
        },
        "required": [
          "aunt",
          "onRight"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMerkleProof": {
        "properties": {
          "aunts": {
            "items": {
              "$ref": "#/components/schemas/iMerklePathItem"
            },
            "description": "The aunts of the merkle proof.",
            "type": "array"
          },
          "leaf": {
            "description": "The leaf of the merkle proof. If useCreatorAddressAsLeaf is true, this will be populated with the creator BitBadges address.",
            "type": "string"
          },
          "leafSignature": {
            "description": "The signature for the leaf. With an ETH message signature, sign(leaf + \"-\" + intendedBitBadgesAddress).",
            "type": "string"
          }
        },
        "required": [
          "aunts",
          "leaf",
          "leafSignature"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iETHSignatureChallenge": {
        "properties": {
          "signer": {
            "description": "The Ethereum address that must sign the nonce for verification.",
            "type": "string",
            "examples": [
              "0x...",
              "8d42172..."
            ]
          },
          "challengeTrackerId": {
            "description": "The ID of this ETH signature challenge for tracking the number of uses per signature.",
            "type": "string"
          },
          "uri": {
            "description": "The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Arbitrary custom data associated with this ETH signature challenge.",
            "type": "string"
          }
        },
        "required": [
          "signer",
          "challengeTrackerId",
          "uri",
          "customData"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iETHSignatureProof": {
        "properties": {
          "nonce": {
            "description": "The nonce that was signed. The signature scheme is ETHSign(nonce + \"-\" + creatorAddress).",
            "type": "string"
          },
          "signature": {
            "description": "The Ethereum signature of the nonce.",
            "type": "string",
            "examples": [
              "0x...",
              "8d42172..."
            ]
          }
        },
        "required": [
          "nonce",
          "signature"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iVoter": {
        "properties": {
          "address": {
            "description": "The address of the voter.",
            "type": "string"
          },
          "weight": {
            "description": "The weight of this voter's vote.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "address",
          "weight"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iVotingChallenge": {
        "properties": {
          "proposalId": {
            "description": "The ID of this voting challenge for tracking votes (scoped like challengeTrackerId).\nFormat: collectionId-approverAddress-approvalLevel-approvalId-challengeId",
            "type": "string"
          },
          "quorumThreshold": {
            "description": "The quorum threshold as a percentage (0-100) of total possible weight that must vote \"yes\".\nExample: 50 means 50% of total voter weight must vote yes for approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "voters": {
            "items": {
              "$ref": "#/components/schemas/iVoter"
            },
            "description": "List of voters with their weights. Each voter can cast a weighted vote.",
            "type": "array"
          },
          "uri": {
            "description": "The URI associated with this voting challenge.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Arbitrary custom data associated with this voting challenge.",
            "type": "string"
          }
        },
        "required": [
          "proposalId",
          "quorumThreshold",
          "voters"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iVoteProof": {
        "properties": {
          "proposalId": {
            "description": "The proposal ID this vote is for.",
            "type": "string"
          },
          "voter": {
            "description": "The address of the voter casting the vote.",
            "type": "string"
          },
          "yesWeight": {
            "description": "The percentage weight (0-100) allocated to \"yes\" vote.\nThe remaining percentage (100 - yesWeight) is allocated to \"no\" vote.\nExample: yesWeight=70 means 70% yes, 30% no.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "proposalId",
          "voter",
          "yesWeight"
        ],
        "additionalProperties": false,
        "description": "VoteProof represents a vote cast for a voting challenge.",
        "type": "object"
      },
      "iDynamicStore": {
        "properties": {
          "storeId": {
            "description": "The unique identifier for this dynamic store. This is assigned by the blockchain.",
            "$ref": "#/components/schemas/NumberType"
          },
          "createdBy": {
            "description": "The address of the creator of this dynamic store.",
            "type": "string"
          },
          "defaultValue": {
            "description": "The default value for uninitialized addresses (true/false).",
            "type": "boolean"
          },
          "globalEnabled": {
            "description": "Global kill switch state (defaults to true on creation, can be toggled via UpdateDynamicStore).\nWhen false, all approvals using this store via DynamicStoreChallenge will fail immediately.",
            "type": "boolean"
          },
          "uri": {
            "description": "URI for additional metadata or resources associated with this dynamic store.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Custom data field for storing arbitrary data associated with this dynamic store.",
            "type": "string"
          }
        },
        "required": [
          "storeId",
          "createdBy",
          "defaultValue",
          "globalEnabled",
          "uri",
          "customData"
        ],
        "additionalProperties": false,
        "description": "DynamicStore is a flexible storage object that can store arbitrary data.\nIt is identified by a unique ID assigned by the blockchain, which is a uint64 that increments.\nDynamic stores are created by users and can only be updated or deleted by their creator.\nThey provide a way to store custom data on-chain with proper access control.",
        "type": "object"
      },
      "iDynamicStoreValue": {
        "properties": {
          "storeId": {
            "description": "The unique identifier for this dynamic store.",
            "$ref": "#/components/schemas/NumberType"
          },
          "address": {
            "description": "The address for which this value is stored.",
            "type": "string"
          },
          "value": {
            "description": "The boolean value (true/false).",
            "type": "boolean"
          }
        },
        "required": [
          "storeId",
          "address",
          "value"
        ],
        "additionalProperties": false,
        "description": "DynamicStoreValue stores a boolean value for a specific address in a dynamic store.\nThis allows the creator to set true/false values per address that can be checked during approval.",
        "type": "object"
      },
      "iCollectionInvariants": {
        "properties": {
          "noCustomOwnershipTimes": {
            "description": "If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.",
            "type": "boolean"
          },
          "maxSupplyPerId": {
            "description": "Maximum supply per token ID. If set, no balance can exceed this amount.\nThis prevents any single token ID from having more than the specified supply.",
            "$ref": "#/components/schemas/NumberType"
          },
          "cosmosCoinBackedPath": {
            "description": "The IBC backed (sdk.coin) path for the collection. Only one path is allowed.",
            "$ref": "#/components/schemas/iCosmosCoinBackedPath"
          },
          "noForcefulPostMintTransfers": {
            "description": "If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.\nThis prevents forceful post-mint transfers that bypass user-level approvals.",
            "type": "boolean"
          },
          "disablePoolCreation": {
            "description": "If true, disallows pool creation with this collection's assets.\nWhen true, any attempt to create a pool with badges assets from this collection will fail.",
            "type": "boolean"
          }
        },
        "required": [
          "noCustomOwnershipTimes",
          "maxSupplyPerId",
          "noForcefulPostMintTransfers",
          "disablePoolCreation"
        ],
        "additionalProperties": false,
        "description": "CollectionInvariants defines the invariants that apply to a collection.\nThese are set upon genesis and cannot be modified.",
        "type": "object"
      },
      "iDynamicStoreChallenge": {
        "properties": {
          "storeId": {
            "description": "The ID of the dynamic store to check.",
            "$ref": "#/components/schemas/NumberType"
          },
          "ownershipCheckParty": {
            "description": "The party to check ownership for. Options are \"initiator\", \"sender\", \"recipient\", or any valid bb1 address. If a valid bb1 address is provided, ownership will be checked for that specific address. This enables use cases like halt tokens where ownership is checked for an arbitrary address (e.g., halt token owner). Defaults to \"initiator\" if empty or if the value is not a recognized option or valid bb1 address.",
            "type": "string"
          }
        },
        "required": [
          "storeId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAddressChecks": {
        "properties": {
          "mustBeWasmContract": {
            "description": "Require the address to be a WASM contract.",
            "type": "boolean"
          },
          "mustNotBeWasmContract": {
            "description": "Require the address to not be a WASM contract.",
            "type": "boolean"
          },
          "mustBeLiquidityPool": {
            "description": "Require the address to be a liquidity pool.",
            "type": "boolean"
          },
          "mustNotBeLiquidityPool": {
            "description": "Require the address to not be a liquidity pool.",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iAltTimeChecks": {
        "properties": {
          "offlineHours": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "Hours (0-23) when transfers should be denied. Uses UTC timezone.",
            "type": "array"
          },
          "offlineDays": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "Days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied. Uses UTC timezone.",
            "type": "array"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iUserOutgoingApproval": {
        "properties": {
          "toListId": {
            "description": "The list ID for the user(s) who is sending the tokens. The ID is either registered on-chain for reusability or follows the reserved ID system.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "toList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "initiatedByListId": {
            "description": "The list ID for the user(s) who initiate the transfer. The ID is either registered on-chain for reusability or follows the reserved ID system.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "initiatedByList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "transferTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The times allowed for the transfer transaction.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs to be transferred.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The ownership times of the tokens being transferred.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "approvalId": {
            "description": "The ID of the approval. Must not be a duplicate of another approval ID in the same timeline.",
            "type": "string"
          },
          "uri": {
            "description": "The URI of the approval.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Arbitrary custom data of the approval",
            "type": "string"
          },
          "approvalCriteria": {
            "description": "The criteria to be met. These represent the restrictions that must be obeyed such as the total amount approved, max num transfers, merkle challenges, must own tokens, etc.",
            "$ref": "#/components/schemas/iOutgoingApprovalCriteria"
          },
          "version": {
            "description": "The version of the approval.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "toListId",
          "toList",
          "initiatedByListId",
          "initiatedByList",
          "transferTimes",
          "tokenIds",
          "ownershipTimes",
          "approvalId",
          "version"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iOutgoingApprovalCriteria": {
        "properties": {
          "coinTransfers": {
            "items": {
              "$ref": "#/components/schemas/iCoinTransfer"
            },
            "description": "The BADGE or sdk.coin transfers to be executed upon every approval.",
            "type": "array"
          },
          "mustOwnTokens": {
            "items": {
              "$ref": "#/components/schemas/iMustOwnToken"
            },
            "description": "The list of must own tokens that need valid proofs to be approved.",
            "type": "array"
          },
          "merkleChallenges": {
            "items": {
              "$ref": "#/components/schemas/iMerkleChallenge"
            },
            "description": "The list of merkle challenges that need valid proofs to be approved.",
            "type": "array"
          },
          "predeterminedBalances": {
            "description": "The predetermined balances for each transfer. These allow approvals to use predetermined balance amounts rather than an incrementing tally system.",
            "$ref": "#/components/schemas/iPredeterminedBalances"
          },
          "approvalAmounts": {
            "description": "The maximum approved amounts for this approval.",
            "$ref": "#/components/schemas/iApprovalAmounts"
          },
          "maxNumTransfers": {
            "description": "The max num transfers for this approval.",
            "$ref": "#/components/schemas/iMaxNumTransfers"
          },
          "requireToEqualsInitiatedBy": {
            "description": "Whether the to address must equal the initiatedBy address.",
            "type": "boolean"
          },
          "requireToDoesNotEqualInitiatedBy": {
            "description": "Whether the to address must not equal the initiatedBy  address.",
            "type": "boolean"
          },
          "autoDeletionOptions": {
            "description": "Whether the approval should be deleted after one use.",
            "$ref": "#/components/schemas/iAutoDeletionOptions"
          },
          "dynamicStoreChallenges": {
            "items": {
              "$ref": "#/components/schemas/iDynamicStoreChallenge"
            },
            "description": "The list of dynamic store challenges that the initiator must pass for approval.",
            "type": "array"
          },
          "ethSignatureChallenges": {
            "items": {
              "$ref": "#/components/schemas/iETHSignatureChallenge"
            },
            "description": "The list of ETH signature challenges that the initiator must pass for approval.",
            "type": "array"
          },
          "recipientChecks": {
            "description": "Address checks for recipient",
            "$ref": "#/components/schemas/iAddressChecks"
          },
          "initiatorChecks": {
            "description": "Address checks for initiator",
            "$ref": "#/components/schemas/iAddressChecks"
          },
          "altTimeChecks": {
            "description": "Alternative time-based checks for approval denial (offline hours/days).",
            "$ref": "#/components/schemas/iAltTimeChecks"
          },
          "mustPrioritize": {
            "description": "If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.",
            "type": "boolean"
          },
          "votingChallenges": {
            "items": {
              "$ref": "#/components/schemas/iVotingChallenge"
            },
            "description": "The list of voting challenges that must be satisfied for approval.",
            "type": "array"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iPredeterminedBalances": {
        "properties": {
          "manualBalances": {
            "items": {
              "$ref": "#/components/schemas/iManualBalances"
            },
            "description": "Manually define the balances for each transfer. Cannot be used with incrementedBalances. Order number corresponds to the index of the balance in the array.",
            "type": "array"
          },
          "incrementedBalances": {
            "description": "Define a starting balance and increment the token IDs and owned times by a certain amount after each transfer. Cannot be used with manualBalances. Order number corresponds to number of times we increment.",
            "$ref": "#/components/schemas/iIncrementedBalances"
          },
          "orderCalculationMethod": {
            "description": "The order calculation method.",
            "$ref": "#/components/schemas/iPredeterminedOrderCalculationMethod"
          }
        },
        "required": [
          "manualBalances",
          "incrementedBalances",
          "orderCalculationMethod"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iManualBalances": {
        "properties": {
          "balances": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "The list of balances for each transfer. Order number corresponds to the index of the balance in the array.",
            "type": "array"
          }
        },
        "required": [
          "balances"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iRecurringOwnershipTimes": {
        "properties": {
          "startTime": {
            "description": "The start time of the recurring ownership times.",
            "$ref": "#/components/schemas/NumberType"
          },
          "intervalLength": {
            "description": "The interval length of the recurring ownership times.",
            "$ref": "#/components/schemas/NumberType"
          },
          "chargePeriodLength": {
            "description": "Grace period length of when this is valid.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "startTime",
          "intervalLength",
          "chargePeriodLength"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iIncrementedBalances": {
        "properties": {
          "startBalances": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "The starting balances for each transfer. Order number corresponds to the number of times we increment.",
            "type": "array"
          },
          "incrementTokenIdsBy": {
            "description": "The amount to increment the token IDs by after each transfer.",
            "$ref": "#/components/schemas/NumberType"
          },
          "incrementOwnershipTimesBy": {
            "description": "The amount to increment the owned times by after each transfer. Incompatible with durationFromTimestamp.",
            "$ref": "#/components/schemas/NumberType"
          },
          "durationFromTimestamp": {
            "description": "The number of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.",
            "$ref": "#/components/schemas/NumberType"
          },
          "allowOverrideTimestamp": {
            "description": "Whether to allow the override timestamp to be used.",
            "type": "boolean"
          },
          "recurringOwnershipTimes": {
            "description": "The recurring ownership times for the approval.",
            "$ref": "#/components/schemas/iRecurringOwnershipTimes"
          },
          "allowOverrideWithAnyValidToken": {
            "description": "Whether to allow the override with any valid ID.",
            "type": "boolean"
          }
        },
        "required": [
          "startBalances",
          "incrementTokenIdsBy",
          "incrementOwnershipTimesBy",
          "durationFromTimestamp",
          "allowOverrideTimestamp",
          "recurringOwnershipTimes",
          "allowOverrideWithAnyValidToken"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iPredeterminedOrderCalculationMethod": {
        "properties": {
          "useOverallNumTransfers": {
            "description": "Use the overall number of transfers this approval has been used with as the order number. Ex: If this approval has been used 2 times by ANY address, then the order number for the next transfer will be 3.",
            "type": "boolean"
          },
          "usePerToAddressNumTransfers": {
            "description": "Use the number of times this approval has been used by each to address as the order number. Ex: If this approval has been used 2 times by to address A, then the order number for the next transfer by to address A will be 3.",
            "type": "boolean"
          },
          "usePerFromAddressNumTransfers": {
            "description": "Use the number of times this approval has been used by each from address as the order number. Ex: If this approval has been used 2 times by from address A, then the order number for the next transfer by from address A will be 3.",
            "type": "boolean"
          },
          "usePerInitiatedByAddressNumTransfers": {
            "description": "Use the number of times this approval has been used by each initiated by address as the order number. Ex: If this approval has been used 2 times by initiated by address A, then the order number for the next transfer by initiated by address A will be 3.",
            "type": "boolean"
          },
          "useMerkleChallengeLeafIndex": {
            "description": "Use the merkle challenge leaf index as the order number. Must specify ONE merkle challenge with the useLeafIndexForTransferOrder flag set to true. If so, we will use the leaf index of each merkle proof to calculate the order number. This is used to reserve specific balances for specific leaves (such as codes or whitelist address leafs)",
            "type": "boolean"
          },
          "challengeTrackerId": {
            "description": "Use the merkle challenge leaf index as the order number. Must specify ONE merkle challenge with the useLeafIndexForTransferOrder flag set to true. If so, we will use the leaf index of each merkle proof to calculate the order number. This is used to reserve specific balances for specific leaves (such as codes or whitelist address leafs)",
            "type": "string"
          }
        },
        "required": [
          "useOverallNumTransfers",
          "usePerToAddressNumTransfers",
          "usePerFromAddressNumTransfers",
          "usePerInitiatedByAddressNumTransfers",
          "useMerkleChallengeLeafIndex",
          "challengeTrackerId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iResetTimeIntervals": {
        "properties": {
          "startTime": {
            "description": "The start time of the first interval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "intervalLength": {
            "description": "The length of the interval.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "startTime",
          "intervalLength"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iApprovalAmounts": {
        "properties": {
          "overallApprovalAmount": {
            "description": "The overall maximum amount approved for the tokenIDs and ownershipTimes. Running tally that includes all transfers that match this approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "perToAddressApprovalAmount": {
            "description": "The maximum amount approved for the tokenIDs and ownershipTimes for each to address. Running tally that includes all transfers from each unique to address that match this approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "perFromAddressApprovalAmount": {
            "description": "The maximum amount approved for the tokenIDs and ownershipTimes for each from address. Running tally that includes all transfers from each unique from address that match this approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "perInitiatedByAddressApprovalAmount": {
            "description": "The maximum amount approved for the tokenIDs and ownershipTimes for each initiated by address. Running tally that includes all transfers from each unique initiated by address that match this approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "amountTrackerId": {
            "description": "The ID of the approval tracker. This is the key used to track tallies.",
            "type": "string"
          },
          "resetTimeIntervals": {
            "description": "The time intervals to reset the tracker at.",
            "$ref": "#/components/schemas/iResetTimeIntervals"
          }
        },
        "required": [
          "overallApprovalAmount",
          "perToAddressApprovalAmount",
          "perFromAddressApprovalAmount",
          "perInitiatedByAddressApprovalAmount",
          "amountTrackerId",
          "resetTimeIntervals"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iAutoDeletionOptions": {
        "properties": {
          "afterOneUse": {
            "description": "Whether the approval should be deleted after one use.",
            "type": "boolean"
          },
          "afterOverallMaxNumTransfers": {
            "description": "Whether the approval should be deleted after the overall max number of transfers threshold is met.",
            "type": "boolean"
          },
          "allowCounterpartyPurge": {
            "description": "Allow counterparty to purge this approval if they are the only initiator",
            "type": "boolean"
          },
          "allowPurgeIfExpired": {
            "description": "Allow others to call PurgeApprovals on behalf of this approval owner",
            "type": "boolean"
          }
        },
        "required": [
          "afterOneUse",
          "afterOverallMaxNumTransfers",
          "allowCounterpartyPurge",
          "allowPurgeIfExpired"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMaxNumTransfers": {
        "properties": {
          "overallMaxNumTransfers": {
            "description": "The overall maximum number of transfers for the tokenIDs and ownershipTimes. Running tally that includes all transfers that match this approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "perToAddressMaxNumTransfers": {
            "description": "The maximum number of transfers for the tokenIDs and ownershipTimes for each to address. Running tally that includes all transfers from each unique to address that match this approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "perFromAddressMaxNumTransfers": {
            "description": "The maximum number of transfers for the tokenIDs and ownershipTimes for each from address. Running tally that includes all transfers from each unique from address that match this approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "perInitiatedByAddressMaxNumTransfers": {
            "description": "The maximum number of transfers for the tokenIDs and ownershipTimes for each initiated by address. Running tally that includes all transfers from each unique initiated by address that match this approval.",
            "$ref": "#/components/schemas/NumberType"
          },
          "amountTrackerId": {
            "description": "The ID of the approval tracker. This is the key used to track tallies.",
            "type": "string"
          },
          "resetTimeIntervals": {
            "description": "The time intervals to reset the tracker at.",
            "$ref": "#/components/schemas/iResetTimeIntervals"
          }
        },
        "required": [
          "overallMaxNumTransfers",
          "perToAddressMaxNumTransfers",
          "perFromAddressMaxNumTransfers",
          "perInitiatedByAddressMaxNumTransfers",
          "amountTrackerId",
          "resetTimeIntervals"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iUserIncomingApproval": {
        "properties": {
          "fromListId": {
            "description": "The list ID for the user(s) who is sending the tokens. The ID is either registered on-chain for reusability or follows the reserved ID system.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "fromList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "initiatedByListId": {
            "description": "The list ID for the user(s) who initiate the transfer. The ID is either registered on-chain for reusability or follows the reserved ID system.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "initiatedByList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "transferTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The times allowed for the transfer transaction.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs to be transferred.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The ownership times of the tokens being transferred.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "approvalId": {
            "description": "The ID of the approval. Must not be a duplicate of another approval ID in the same timeline.",
            "type": "string"
          },
          "uri": {
            "description": "The URI of the approval.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Arbitrary custom data of the approval",
            "type": "string"
          },
          "approvalCriteria": {
            "description": "The criteria to be met. These represent the restrictions that must be obeyed such as the total amount approved, max num transfers, merkle challenges, must own tokens, etc.",
            "$ref": "#/components/schemas/iIncomingApprovalCriteria"
          },
          "version": {
            "description": "The version of the approval.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "fromListId",
          "fromList",
          "initiatedByListId",
          "initiatedByList",
          "transferTimes",
          "tokenIds",
          "ownershipTimes",
          "approvalId",
          "version"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iIncomingApprovalCriteria": {
        "properties": {
          "coinTransfers": {
            "items": {
              "$ref": "#/components/schemas/iCoinTransfer"
            },
            "description": "The BADGE or sdk.coin transfers to be executed upon every approval.",
            "type": "array"
          },
          "merkleChallenges": {
            "items": {
              "$ref": "#/components/schemas/iMerkleChallenge"
            },
            "description": "The list of merkle challenges that need valid proofs to be approved.",
            "type": "array"
          },
          "mustOwnTokens": {
            "items": {
              "$ref": "#/components/schemas/iMustOwnToken"
            },
            "description": "The list of must own tokens that need valid proofs to be approved.",
            "type": "array"
          },
          "predeterminedBalances": {
            "description": "The predetermined balances for each transfer using this approval.",
            "$ref": "#/components/schemas/iPredeterminedBalances"
          },
          "approvalAmounts": {
            "description": "The maximum approved amounts for this approval.",
            "$ref": "#/components/schemas/iApprovalAmounts"
          },
          "maxNumTransfers": {
            "description": "The max num transfers for this approval.",
            "$ref": "#/components/schemas/iMaxNumTransfers"
          },
          "autoDeletionOptions": {
            "description": "Whether the approval should be deleted after one use.",
            "$ref": "#/components/schemas/iAutoDeletionOptions"
          },
          "requireFromEqualsInitiatedBy": {
            "description": "Whether the from address must equal the initiatedBy address.",
            "type": "boolean"
          },
          "requireFromDoesNotEqualInitiatedBy": {
            "description": "Whether the from address must not equal the initiatedBy address.",
            "type": "boolean"
          },
          "dynamicStoreChallenges": {
            "items": {
              "$ref": "#/components/schemas/iDynamicStoreChallenge"
            },
            "description": "The list of dynamic store challenges that the initiator must pass for approval.",
            "type": "array"
          },
          "ethSignatureChallenges": {
            "items": {
              "$ref": "#/components/schemas/iETHSignatureChallenge"
            },
            "description": "The list of ETH signature challenges that the initiator must pass for approval.",
            "type": "array"
          },
          "senderChecks": {
            "description": "Address checks for sender",
            "$ref": "#/components/schemas/iAddressChecks"
          },
          "initiatorChecks": {
            "description": "Address checks for initiator",
            "$ref": "#/components/schemas/iAddressChecks"
          },
          "altTimeChecks": {
            "description": "Alternative time-based checks for approval denial (offline hours/days).",
            "$ref": "#/components/schemas/iAltTimeChecks"
          },
          "mustPrioritize": {
            "description": "If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.",
            "type": "boolean"
          },
          "votingChallenges": {
            "items": {
              "$ref": "#/components/schemas/iVotingChallenge"
            },
            "description": "The list of voting challenges that must be satisfied for approval.",
            "type": "array"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iCollectionApproval": {
        "properties": {
          "toListId": {
            "description": "The list ID for the user(s) who is receiving the tokens. The ID is either registered on-chain for reusability or follows the reserved ID system.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "toList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "fromListId": {
            "description": "The list ID for the user(s) who is sending the tokens. The ID is either registered on-chain for reusability or follows the reserved ID system.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "fromList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "initiatedByListId": {
            "description": "The list ID for the user(s) who initiate the transfer. The ID is either registered on-chain for reusability or follows the reserved ID system.",
            "type": "string",
            "examples": [
              "customOrReservedListId",
              "Mint",
              "All",
              "bb1..."
            ]
          },
          "initiatedByList": {
            "$ref": "#/components/schemas/iAddressList"
          },
          "transferTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The times allowed for the transfer transaction.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The token IDs to be transferred.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "ownershipTimes": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The ownership times of the tokens being transferred.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "approvalId": {
            "description": "The ID of the approval. Must not be a duplicate of another approval ID in the same timeline.",
            "type": "string"
          },
          "uri": {
            "description": "The URI of the approval.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Arbitrary custom data of the approval",
            "type": "string"
          },
          "approvalCriteria": {
            "description": "The criteria to be met. These represent the restrictions that must be obeyed such as the total amount approved, max num transfers, merkle challenges, must own tokens, etc.",
            "$ref": "#/components/schemas/iApprovalCriteria"
          },
          "version": {
            "description": "The version of the approval.0",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "toListId",
          "toList",
          "fromListId",
          "fromList",
          "initiatedByListId",
          "initiatedByList",
          "transferTimes",
          "tokenIds",
          "ownershipTimes",
          "approvalId",
          "version"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iApprovalCriteria": {
        "properties": {
          "coinTransfers": {
            "items": {
              "$ref": "#/components/schemas/iCoinTransfer"
            },
            "description": "The BADGE or sdk.coin transfers to be executed upon every approval.",
            "type": "array"
          },
          "merkleChallenges": {
            "items": {
              "$ref": "#/components/schemas/iMerkleChallenge"
            },
            "description": "The list of merkle challenges that need valid proofs to be approved.",
            "type": "array"
          },
          "mustOwnTokens": {
            "items": {
              "$ref": "#/components/schemas/iMustOwnToken"
            },
            "description": "The list of must own tokens that need valid proofs to be approved.",
            "type": "array"
          },
          "predeterminedBalances": {
            "description": "The predetermined balances for each transfer. These allow approvals to use predetermined balance amounts rather than an incrementing tally system.",
            "$ref": "#/components/schemas/iPredeterminedBalances"
          },
          "approvalAmounts": {
            "description": "The maximum approved amounts for this approval.",
            "$ref": "#/components/schemas/iApprovalAmounts"
          },
          "maxNumTransfers": {
            "description": "The max num transfers for this approval.",
            "$ref": "#/components/schemas/iMaxNumTransfers"
          },
          "autoDeletionOptions": {
            "description": "Whether the approval should be deleted after one use.",
            "$ref": "#/components/schemas/iAutoDeletionOptions"
          },
          "requireToEqualsInitiatedBy": {
            "description": "Whether the to address must equal the initiatedBy address.",
            "type": "boolean"
          },
          "requireFromEqualsInitiatedBy": {
            "description": "Whether the from address must equal the initiatedBy address.",
            "type": "boolean"
          },
          "requireToDoesNotEqualInitiatedBy": {
            "description": "Whether the to address must not equal the initiatedBy address.",
            "type": "boolean"
          },
          "requireFromDoesNotEqualInitiatedBy": {
            "description": "Whether the from address must not equal the initiatedBy address.",
            "type": "boolean"
          },
          "overridesFromOutgoingApprovals": {
            "description": "Whether this approval overrides the from address's approved outgoing transfers.",
            "type": "boolean"
          },
          "overridesToIncomingApprovals": {
            "description": "Whether this approval overrides the to address's approved incoming transfers.",
            "type": "boolean"
          },
          "userRoyalties": {
            "description": "The royalties to apply to the transfer.",
            "$ref": "#/components/schemas/iUserRoyalties"
          },
          "dynamicStoreChallenges": {
            "items": {
              "$ref": "#/components/schemas/iDynamicStoreChallenge"
            },
            "description": "The list of dynamic store challenges that the initiator must pass for approval.",
            "type": "array"
          },
          "ethSignatureChallenges": {
            "items": {
              "$ref": "#/components/schemas/iETHSignatureChallenge"
            },
            "description": "The list of ETH signature challenges that the initiator must pass for approval.",
            "type": "array"
          },
          "senderChecks": {
            "description": "Address checks for sender",
            "$ref": "#/components/schemas/iAddressChecks"
          },
          "recipientChecks": {
            "description": "Address checks for recipient",
            "$ref": "#/components/schemas/iAddressChecks"
          },
          "initiatorChecks": {
            "description": "Address checks for initiator",
            "$ref": "#/components/schemas/iAddressChecks"
          },
          "altTimeChecks": {
            "description": "Alternative time-based checks for approval denial (offline hours/days).",
            "$ref": "#/components/schemas/iAltTimeChecks"
          },
          "mustPrioritize": {
            "description": "If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.",
            "type": "boolean"
          },
          "votingChallenges": {
            "items": {
              "$ref": "#/components/schemas/iVotingChallenge"
            },
            "description": "The list of voting challenges that must be satisfied for approval.",
            "type": "array"
          },
          "allowBackedMinting": {
            "description": "If true, this collection approval allows backed minting operations (CosmosCoinBackedPath). When false, this approval cannot be used for transfers involving backed minting addresses. This prevents accidental allowances when toListIds is \"All\".",
            "type": "boolean"
          },
          "allowSpecialWrapping": {
            "description": "If true, this collection approval allows special wrapping operations (CosmosCoinWrapperPath). When false, this approval cannot be used for transfers involving wrapping addresses. This prevents accidental allowances when toListIds is \"All\".",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iUserRoyalties": {
        "properties": {
          "percentage": {
            "description": "The percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.",
            "$ref": "#/components/schemas/NumberType"
          },
          "payoutAddress": {
            "description": "The payout address for the royalties.",
            "type": "string"
          }
        },
        "required": [
          "percentage",
          "payoutAddress"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "UniversalPermission": {
        "properties": {
          "tokenIds": {
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "timelineTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "transferTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "ownershipTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "toList": {},
          "fromList": {},
          "initiatedByList": {},
          "approvalIdList": {},
          "permanentlyPermittedTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "permanentlyForbiddenTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "usesTokenIds": {
            "type": "boolean"
          },
          "usesTimelineTimes": {
            "type": "boolean"
          },
          "usesTransferTimes": {
            "type": "boolean"
          },
          "usesToList": {
            "type": "boolean"
          },
          "usesFromList": {
            "type": "boolean"
          },
          "usesInitiatedByList": {
            "type": "boolean"
          },
          "usesOwnershipTimes": {
            "type": "boolean"
          },
          "usesApprovalIdList": {
            "type": "boolean"
          },
          "arbitraryValue": {}
        },
        "required": [
          "tokenIds",
          "timelineTimes",
          "transferTimes",
          "ownershipTimes",
          "toList",
          "fromList",
          "initiatedByList",
          "approvalIdList",
          "permanentlyPermittedTimes",
          "permanentlyForbiddenTimes",
          "usesTokenIds",
          "usesTimelineTimes",
          "usesTransferTimes",
          "usesToList",
          "usesFromList",
          "usesInitiatedByList",
          "usesOwnershipTimes",
          "usesApprovalIdList",
          "arbitraryValue"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "UniversalPermissionDetails": {
        "properties": {
          "tokenId": {
            "$ref": "#/components/schemas/UintRange"
          },
          "timelineTime": {
            "$ref": "#/components/schemas/UintRange"
          },
          "transferTime": {
            "$ref": "#/components/schemas/UintRange"
          },
          "ownershipTime": {
            "$ref": "#/components/schemas/UintRange"
          },
          "toList": {},
          "fromList": {},
          "initiatedByList": {},
          "approvalIdList": {},
          "permanentlyPermittedTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "permanentlyForbiddenTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "arbitraryValue": {}
        },
        "required": [
          "tokenId",
          "timelineTime",
          "transferTime",
          "ownershipTime",
          "toList",
          "fromList",
          "initiatedByList",
          "approvalIdList",
          "permanentlyPermittedTimes",
          "permanentlyForbiddenTimes",
          "arbitraryValue"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "Overlap": {
        "properties": {
          "overlap": {
            "$ref": "#/components/schemas/UniversalPermissionDetails"
          },
          "firstDetails": {
            "$ref": "#/components/schemas/UniversalPermissionDetails"
          },
          "secondDetails": {
            "$ref": "#/components/schemas/UniversalPermissionDetails"
          }
        },
        "required": [
          "overlap",
          "firstDetails",
          "secondDetails"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "UsedFlags": {
        "properties": {
          "usesTokenIds": {
            "type": "boolean"
          },
          "usesTimelineTimes": {
            "type": "boolean"
          },
          "usesTransferTimes": {
            "type": "boolean"
          },
          "usesToList": {
            "type": "boolean"
          },
          "usesFromList": {
            "type": "boolean"
          },
          "usesInitiatedByList": {
            "type": "boolean"
          },
          "usesOwnershipTimes": {
            "type": "boolean"
          },
          "usesApprovalIdList": {
            "type": "boolean"
          },
          "usesAmountTrackerIdList": {
            "type": "boolean"
          },
          "usesChallengeTrackerIdList": {
            "type": "boolean"
          }
        },
        "required": [
          "usesTokenIds",
          "usesTimelineTimes",
          "usesTransferTimes",
          "usesToList",
          "usesFromList",
          "usesInitiatedByList",
          "usesOwnershipTimes",
          "usesApprovalIdList",
          "usesAmountTrackerIdList",
          "usesChallengeTrackerIdList"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "MergedUniversalPermissionDetails": {
        "properties": {
          "tokenIds": {
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          },
          "timelineTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "transferTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "ownershipTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "toList": {},
          "fromList": {},
          "initiatedByList": {},
          "approvalIdList": {},
          "permanentlyPermittedTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "permanentlyForbiddenTimes": {
            "examples": [
              [
                {
                  "start": "1713301889",
                  "end": "2000000000"
                }
              ],
              [
                {
                  "start": "1",
                  "end": "18446744073709551615"
                }
              ]
            ]
          },
          "arbitraryValue": {}
        },
        "required": [
          "tokenIds",
          "timelineTimes",
          "transferTimes",
          "ownershipTimes",
          "toList",
          "fromList",
          "initiatedByList",
          "approvalIdList",
          "permanentlyPermittedTimes",
          "permanentlyForbiddenTimes",
          "arbitraryValue"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iCosmosCoin": {
        "properties": {
          "amount": {
            "description": "The amount of the coin.",
            "$ref": "#/components/schemas/NumberType"
          },
          "denom": {
            "description": "The denomination of the coin (e.g. \"ubadge\").",
            "type": "string"
          }
        },
        "required": [
          "amount",
          "denom"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "PermissionNameString": {
        "enum": [
          "canDeleteCollection",
          "canArchiveCollection",
          "canUpdateTokenMetadata",
          "canUpdateCollectionMetadata",
          "canUpdateValidTokenIds",
          "canUpdateCollectionApprovals",
          "canUpdateAutoApproveSelfInitiatedIncomingTransfers",
          "canUpdateAutoApproveSelfInitiatedOutgoingTransfers",
          "canUpdateAutoApproveAllIncomingTransfers",
          "canUpdateStandards",
          "canUpdateCustomData",
          "canUpdateManager",
          "canAddMoreAliasPaths",
          "canAddMoreCosmosCoinWrapperPaths"
        ],
        "type": "string"
      },
      "iChallengeDetails": {
        "properties": {
          "leaves": {
            "items": {
              "type": "string"
            },
            "description": "The leaves of the Merkle tree. Leaves should be considered public. Use preimages for the private codes + isHashed. For whitelist trees, these can be the plaintext BitBadges addresses.",
            "type": "array"
          },
          "isHashed": {
            "description": "True if the leaves are hashed. Hash(preimage[i]) = leaves[i]",
            "type": "boolean"
          },
          "preimages": {
            "items": {
              "type": "string"
            },
            "description": "The preimages of the leaves (only used if isHashed = true). Oftentimes, this is used for private codes so should not be present when user-facing.",
            "type": "array"
          },
          "seedCode": {
            "description": "Seed code for generating the leaves",
            "type": "string"
          },
          "tree": {
            "description": "The Merkle tree"
          },
          "treeOptions": {
            "description": "The Merkle tree options for how to build it"
          },
          "numLeaves": {
            "description": "The number of leaves in the Merkle tree. This takes priority over leaves.length if defined (used for buffer time between leaf generation and leaf length select)",
            "$ref": "#/components/schemas/NumberType"
          },
          "currCode": {
            "description": "The current code being used for the challenge. Used behind the scenes",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "leaves",
          "isHashed"
        ],
        "additionalProperties": false,
        "examples": [
          "Codes\n1. Generate N codes privately\n2. Hash each code\n3. Store the hashed codes publicly on IPFS via this struct\n4. When a user enters a code, we hash it and check if it matches any of the hashed codes. This way, the codes are never stored publicly on IPFS and only known by the generator of the codes.",
          "Whitelist\nFor storing a public whitelist of addresses (with useCreatorAddressAsLeaf = true), hashing complicates everything because the whitelist can be stored publicly.\n1. Generate N whitelist addresses\n2. Store the addresses publicly on IPFS via this struct\n3. When a user enters an address, we check if it matches any of the addresses."
        ],
        "type": "object"
      },
      "iChallengeInfoDetails": {
        "properties": {
          "challengeDetails": {
            "description": "The challenge details of the claim / approval",
            "$ref": "#/components/schemas/iChallengeDetails"
          },
          "claim": {
            "$ref": "#/components/schemas/iClaimDetails"
          }
        },
        "required": [
          "challengeDetails"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iChallengeInfoDetailsUpdate": {
        "properties": {
          "challengeDetails": {
            "description": "The challenge details of the claim / approval",
            "$ref": "#/components/schemas/iChallengeDetails"
          },
          "claim": {
            "$ref": "#/components/schemas/CreateClaimRequest"
          }
        },
        "required": [
          "challengeDetails"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iApprovalInfoDetails": {
        "properties": {
          "name": {
            "type": "string",
            "examples": [
              "Name"
            ]
          },
          "description": {
            "type": "string",
            "examples": [
              "Brief description."
            ]
          },
          "image": {
            "type": "string",
            "examples": [
              "https://example.com/image.png",
              "ipfs://Qm..."
            ]
          }
        },
        "required": [
          "name",
          "description",
          "image"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iOffChainBalancesMap": {
        "additionalProperties": {
          "items": {
            "$ref": "#/components/schemas/iBalance"
          },
          "type": "array"
        },
        "type": "object"
      },
      "OffChainBalancesMap": {
        "additionalProperties": {},
        "description": "\n@typedef OffChainBalancesMap is a map of BitBadges addresses or listIDs to an array of balances. This is the expected format\nfor collections with off-chain balances. Host this on your server in JSON format.",
        "type": "object"
      },
      "iTransferWithIncrements": {
        "properties": {
          "from": {
            "description": "The address to transfer from.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "toAddresses": {
            "items": {
              "$ref": "#/components/schemas/BitBadgesAddress"
            },
            "description": "The addresses to transfer to.",
            "type": "array"
          },
          "balances": {
            "items": {
              "$ref": "#/components/schemas/iBalance"
            },
            "description": "The balances to transfer.",
            "type": "array"
          },
          "precalculateBalancesFromApproval": {
            "description": "If specified, we will precalculate from this approval and override the balances. This can only be used when the specified approval has predeterminedBalances set.",
            "$ref": "#/components/schemas/iPrecalculateBalancesFromApprovalDetails"
          },
          "merkleProofs": {
            "items": {
              "$ref": "#/components/schemas/iMerkleProof"
            },
            "description": "The merkle proofs that satisfy the mkerkle challenges in the approvals. If the transfer deducts from multiple approvals, we check all the merkle proofs and assert at least one is valid for every challenge.",
            "type": "array"
          },
          "ethSignatureProofs": {
            "items": {
              "$ref": "#/components/schemas/iETHSignatureProof"
            },
            "description": "The ETH signature proofs that satisfy the ETH signature challenges in the approvals. If the transfer deducts from multiple approvals, we check all the ETH signature proofs and assert at least one is valid for every challenge.",
            "type": "array"
          },
          "memo": {
            "description": "Arbitrary memo for the transfer.",
            "type": "string"
          },
          "prioritizedApprovals": {
            "items": {
              "$ref": "#/components/schemas/iApprovalIdentifierDetails"
            },
            "description": "The prioritized approvals to use for the transfer. If specified, we will check these first.",
            "type": "array"
          },
          "onlyCheckPrioritizedCollectionApprovals": {
            "description": "Whether or not to only check the prioritized approvals. If false, we will check all approvals with any prioritized first.\n\nThis only applies to the \"collection\" level approvals specified.",
            "type": "boolean"
          },
          "onlyCheckPrioritizedIncomingApprovals": {
            "description": "Whether or not to only check the prioritized approvals. If false, we will check all approvals with any prioritized first.\n\nThis only applies to the \"incoming\" level approvals specified.",
            "type": "boolean"
          },
          "onlyCheckPrioritizedOutgoingApprovals": {
            "description": "Whether or not to only check the prioritized approvals. If false, we will check all approvals with any prioritized first.\n\nThis only applies to the \"outgoing\" level approvals specified.",
            "type": "boolean"
          },
          "toAddressesLength": {
            "description": "The number of addresses to send the tokens to. This takes priority over toAddresses.length (used when you don't know exact addresses (i.e. you know number of codes)).",
            "$ref": "#/components/schemas/NumberType"
          },
          "incrementTokenIdsBy": {
            "description": "The number to increment the tokenIDs by for each transfer.",
            "$ref": "#/components/schemas/NumberType"
          },
          "incrementOwnershipTimesBy": {
            "description": "The number to increment the ownershipTimes by for each transfer.",
            "$ref": "#/components/schemas/NumberType"
          },
          "durationFromTimestamp": {
            "description": "The number of unix milliseconds to approve starting from now.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "from",
          "toAddresses",
          "balances"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iBatchTokenDetails": {
        "properties": {
          "collectionId": {
            "description": "The collection ID of this element's token details.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "tokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The corresponding token IDs for this collection ID.",
            "type": "array",
            "examples": [
              [
                {
                  "start": "1",
                  "end": "10"
                }
              ]
            ]
          }
        },
        "required": [
          "collectionId",
          "tokenIds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSiwbbChallenge": {
        "properties": {
          "address": {
            "description": "The user's address",
            "type": "string"
          },
          "chain": {
            "description": "The chain of the address",
            "$ref": "#/components/schemas/SupportedChain"
          },
          "ownershipRequirements": {
            "description": "The ownership requirements for the user",
            "$ref": "#/components/schemas/AssetConditionGroup"
          },
          "bitbadgesAddress": {
            "description": "The converted BitBadges address of params.address. This can be used as the\nunique identifier for the user (e.g. avoid duplicate sign ins from equivalent 0x and bb1 addresses).",
            "examples": [
              "bb1..."
            ],
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "verificationResponse": {
            "properties": {
              "success": {
                "description": "Returns whether the current (message, signature) pair is valid and verified (i.e. signature is valid and any assets are owned).",
                "type": "boolean"
              },
              "errorMessage": {
                "description": "Returns the response message returned from verification.",
                "type": "string"
              }
            },
            "required": [
              "success"
            ],
            "additionalProperties": false,
            "description": "Verification response",
            "type": "object"
          }
        },
        "required": [
          "address",
          "chain",
          "bitbadgesAddress"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "VerifySIWBBOptions": {
        "properties": {
          "issuedAtTimeWindowMs": {
            "description": "How recent the challenge must be in milliseconds. Defaults to 10 minutes. If 0, we will not check the time.",
            "type": "number"
          },
          "skipAssetVerification": {
            "description": "Skip asset verification. This may be useful for simulations or testing.\n@deprecated Please do not use. Check requirements a claim or other means.",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "AdditionalQueryParams": {
        "properties": {
          "claimId": {
            "description": "We will display this claim on the authorize screen. Just for display purpses. This is still to be checked by you post-authentication.",
            "type": "string"
          },
          "hideIfAlreadyClaimed": {
            "description": "For the claimId, we will hide the claim if the user has already completed it (successCount >= 1).",
            "type": "boolean"
          },
          "expectVerifySuccess": {
            "description": "We will expect the claim verification to succeed. If false, we will not let user attempt to sign in.\n\nNote: This is not a replacement for checking the claim on your side because users can manipulate the client-side URL parameters.",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "CodeGenQueryParams": {
        "properties": {
          "claimId": {
            "description": "We will display this claim on the authorize screen. Just for display purpses. This is still to be checked by you post-authentication.",
            "type": "string"
          },
          "hideIfAlreadyClaimed": {
            "description": "For the claimId, we will hide the claim if the user has already completed it (successCount >= 1).",
            "type": "boolean"
          },
          "expectVerifySuccess": {
            "description": "We will expect the claim verification to succeed. If false, we will not let user attempt to sign in.\n\nNote: This is not a replacement for checking the claim on your side because users can manipulate the client-side URL parameters.",
            "type": "boolean"
          },
          "redirect_uri": {
            "description": "The redirect URI to redirect to after the user signs in. Must match the one in developer portal.",
            "type": "string"
          },
          "client_id": {
            "description": "The client ID to use for the SIWBB request. Must match the one in developer portal.",
            "type": "string"
          },
          "state": {
            "description": "The state to use for the SIWBB request.",
            "type": "string"
          },
          "scope": {
            "description": "The scopes to request (e.g. `completeClaims,approveSignInWithBitBadges`).",
            "type": "string"
          }
        },
        "required": [
          "client_id"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "ParsedQs": {
        "additionalProperties": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "$ref": "#/components/schemas/ParsedQs"
            },
            {
              "items": {
                "$ref": "#/components/schemas/ParsedQs"
              },
              "type": "array"
            }
          ]
        },
        "type": "object"
      },
      "ConvertOptions": {
        "properties": {
          "keepOriginalObject": {
            "description": "Same object as the one passed in the convert function.\n\nBy default, we create a deep copy of the object, but you can specify this if you are okay updating in-place.\nThis increases performance by a lot at scale since we don't need to deep copy the object.",
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "NumberType": {
        "$ref": "#/components/schemas/NumberType"
      },
      "JSPrimitiveNumberType": {
        "$ref": "#/components/schemas/NumberType"
      },
      "SupportedChainType": {
        "enum": [
          "Cosmos",
          "Unknown"
        ],
        "description": "Safe adds two uints and returns an error if the result is invalid. Keeps the right type.",
        "type": "string"
      },
      "CoinDetails": {
        "properties": {
          "skipGoSupported": {
            "type": "boolean"
          },
          "label": {
            "type": "string"
          },
          "symbol": {
            "type": "string"
          },
          "decimals": {
            "type": "string"
          },
          "baseDenom": {
            "type": "string"
          },
          "image": {
            "type": "string",
            "examples": [
              "https://example.com/image.png",
              "ipfs://Qm..."
            ]
          }
        },
        "required": [
          "label",
          "symbol",
          "decimals",
          "baseDenom",
          "image"
        ],
        "additionalProperties": false,
        "description": "Coin details interface for the coins registry.",
        "type": "object"
      },
      "EncodeObject": {
        "properties": {
          "typeUrl": {
            "type": "string"
          },
          "value": {}
        },
        "required": [
          "typeUrl",
          "value"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "AminoConverter": {
        "properties": {
          "aminoType": {
            "type": "string"
          },
          "toAmino": {},
          "fromAmino": {}
        },
        "required": [
          "aminoType",
          "toAmino",
          "fromAmino"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "AminoConverters": {
        "description": "A map from protobuf type URL to the AminoConverter implementation if supported on chain"
      },
      "TxContext": {
        "properties": {
          "testnet": {
            "description": "Use the BitBadges testnet? Usee mainnet by default.",
            "type": "boolean"
          },
          "chainIdOverride": {
            "description": "Override the chain ID to a custom value. Uses BitBadges mainnet by default.",
            "type": "string"
          },
          "sender": {
            "properties": {
              "address": {
                "$ref": "#/components/schemas/NativeAddress"
              },
              "sequence": {
                "type": "number"
              },
              "accountNumber": {
                "type": "number"
              },
              "publicKey": {
                "type": "string",
                "examples": [
                  "AksB.... (base64)"
                ]
              }
            },
            "required": [
              "address",
              "sequence",
              "accountNumber",
              "publicKey"
            ],
            "additionalProperties": false,
            "description": "Details about the sender of this transaction. Address must be a BitBadges address (bb-prefixed).\n\nPublic key is required for Cosmos signatures.",
            "type": "object"
          },
          "fee": {
            "$ref": "#/components/schemas/Fee"
          },
          "memo": {
            "type": "string"
          }
        },
        "required": [
          "sender",
          "fee"
        ],
        "additionalProperties": false,
        "description": "LegacyTxContext is the transaction context for the transaction payload.",
        "type": "object"
      },
      "TransactionPayload": {
        "properties": {
          "legacyAmino": {
            "properties": {
              "body": {},
              "authInfo": {},
              "signBytes": {
                "type": "string"
              }
            },
            "required": [
              "body",
              "authInfo",
              "signBytes"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "signDirect": {
            "properties": {
              "body": {},
              "authInfo": {},
              "signBytes": {
                "type": "string"
              }
            },
            "required": [
              "body",
              "authInfo",
              "signBytes"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "legacyAmino",
          "signDirect"
        ],
        "additionalProperties": false,
        "description": "A transaction payload is the payload for a given transaction context and messages.\nFor Cosmos, the payload can be signed in Amino or Sign Direct format, so the payload.signDirect and\npayload.legacyAmino are the payloads to sign.",
        "type": "object"
      },
      "iMsgInstantiateContractCompat": {
        "properties": {
          "sender": {
            "description": "The sender of the transaction.",
            "type": "string"
          },
          "codeId": {
            "description": "The code ID of the contract to instantiate.",
            "type": "string"
          },
          "label": {
            "description": "The human-readable label of the contract.",
            "type": "string"
          },
          "funds": {
            "description": "The amount of funds to send to the contract on instantiation.",
            "type": "string"
          }
        },
        "required": [
          "sender",
          "codeId",
          "label",
          "funds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgStoreCodeCompat": {
        "properties": {
          "sender": {
            "description": "The sender of the transaction.",
            "type": "string"
          },
          "hexWasmByteCode": {
            "description": "The contract byte code in hexadecimal format. See BitBadges CosmWASM tutorial for more details.",
            "type": "string"
          }
        },
        "required": [
          "sender",
          "hexWasmByteCode"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgExecuteContractCompat": {
        "properties": {
          "sender": {
            "description": "The sender of the transaction.",
            "type": "string"
          },
          "contract": {
            "description": "The contract address to execute.",
            "type": "string"
          },
          "msg": {
            "description": "The message to pass to the contract. Must be a valid JSON string.",
            "type": "string"
          },
          "funds": {
            "description": "The funds to send to the contract. Must be a valid JSON string.",
            "type": "string"
          }
        },
        "required": [
          "sender",
          "contract",
          "msg",
          "funds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iValueStore": {
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "lastSetBy": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "key",
          "value",
          "lastSetBy"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMapUpdateCriteria": {
        "properties": {
          "managerOnly": {
            "type": "boolean"
          },
          "collectionId": {
            "type": "string"
          },
          "creatorOnly": {
            "type": "boolean"
          },
          "firstComeFirstServe": {
            "type": "boolean"
          }
        },
        "required": [
          "managerOnly",
          "collectionId",
          "creatorOnly",
          "firstComeFirstServe"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iValueOptions": {
        "properties": {
          "noDuplicates": {
            "type": "boolean"
          },
          "permanentOnceSet": {
            "type": "boolean"
          },
          "expectUint": {
            "type": "boolean"
          },
          "expectBoolean": {
            "type": "boolean"
          },
          "expectAddress": {
            "type": "boolean"
          },
          "expectUri": {
            "type": "boolean"
          }
        },
        "required": [
          "noDuplicates",
          "permanentOnceSet",
          "expectUint",
          "expectBoolean",
          "expectAddress",
          "expectUri"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMapPermissions": {
        "properties": {
          "canUpdateMetadata": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "type": "array"
          },
          "canUpdateManager": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "type": "array"
          },
          "canDeleteMap": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "type": "array"
          }
        },
        "required": [
          "canUpdateMetadata",
          "canUpdateManager",
          "canDeleteMap"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMap": {
        "properties": {
          "creator": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "mapId": {
            "type": "string"
          },
          "inheritManagerFrom": {
            "$ref": "#/components/schemas/NumberType"
          },
          "manager": {
            "type": "string"
          },
          "updateCriteria": {
            "$ref": "#/components/schemas/iMapUpdateCriteria"
          },
          "valueOptions": {
            "$ref": "#/components/schemas/iValueOptions"
          },
          "defaultValue": {
            "type": "string"
          },
          "permissions": {
            "$ref": "#/components/schemas/iMapPermissions"
          },
          "metadata": {
            "$ref": "#/components/schemas/iCollectionMetadata"
          }
        },
        "required": [
          "creator",
          "mapId",
          "inheritManagerFrom",
          "manager",
          "updateCriteria",
          "valueOptions",
          "defaultValue",
          "permissions",
          "metadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgCreateMap": {
        "properties": {
          "creator": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "mapId": {
            "type": "string"
          },
          "inheritManagerFrom": {
            "$ref": "#/components/schemas/NumberType"
          },
          "manager": {
            "type": "string"
          },
          "updateCriteria": {
            "$ref": "#/components/schemas/iMapUpdateCriteria"
          },
          "valueOptions": {
            "$ref": "#/components/schemas/iValueOptions"
          },
          "defaultValue": {
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/iCollectionMetadata"
          },
          "permissions": {
            "$ref": "#/components/schemas/iMapPermissions"
          }
        },
        "required": [
          "creator",
          "mapId",
          "inheritManagerFrom",
          "manager",
          "updateCriteria",
          "valueOptions",
          "defaultValue",
          "metadata",
          "permissions"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgUpdateMap": {
        "properties": {
          "creator": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "mapId": {
            "type": "string"
          },
          "updateManager": {
            "type": "boolean"
          },
          "manager": {
            "type": "string"
          },
          "updateMetadata": {
            "type": "boolean"
          },
          "metadata": {
            "$ref": "#/components/schemas/iCollectionMetadata"
          },
          "updatePermissions": {
            "type": "boolean"
          },
          "permissions": {
            "$ref": "#/components/schemas/iMapPermissions"
          }
        },
        "required": [
          "creator",
          "mapId",
          "updateManager",
          "manager",
          "updateMetadata",
          "metadata",
          "updatePermissions",
          "permissions"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgDeleteMap": {
        "properties": {
          "creator": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "mapId": {
            "type": "string"
          }
        },
        "required": [
          "creator",
          "mapId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetValue": {
        "properties": {
          "creator": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "mapId": {
            "type": "string"
          },
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "options": {
            "$ref": "#/components/schemas/iSetOptions"
          }
        },
        "required": [
          "creator",
          "mapId",
          "key",
          "value",
          "options"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iSetOptions": {
        "properties": {
          "useMostRecentCollectionId": {
            "type": "boolean"
          }
        },
        "required": [
          "useMostRecentCollectionId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgCreateAddressLists": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "addressLists": {
            "items": {
              "$ref": "#/components/schemas/iAddressList"
            },
            "description": "The address lists to create.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "addressLists"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgCreateCollection": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "defaultBalances": {
            "description": "The default balances for users who have not interacted with the collection yet. Only can be set on initial creation. Only used if collection has \"Standard\" balance type.",
            "$ref": "#/components/schemas/iUserBalanceStore"
          },
          "validTokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The tokens to create. Newly created tokens will be sent to the \"Mint\" address. Must have necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. Only used if collection has \"Standard\" balance type.",
            "type": "array"
          },
          "collectionPermissions": {
            "description": "The new collection permissions. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "$ref": "#/components/schemas/iCollectionPermissions"
          },
          "manager": {
            "description": "The new manager. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionMetadata": {
            "description": "The new collection metadata. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "$ref": "#/components/schemas/iCollectionMetadata"
          },
          "tokenMetadata": {
            "items": {
              "$ref": "#/components/schemas/iTokenMetadata"
            },
            "description": "The new token metadata. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. Note we take first-match only for token IDs, so do not define duplicates.",
            "type": "array"
          },
          "customData": {
            "description": "The new custom data. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "type": "string"
          },
          "collectionApprovals": {
            "items": {
              "$ref": "#/components/schemas/iCollectionApproval"
            },
            "description": "The new collection approved transfers. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "type": "array"
          },
          "standards": {
            "items": {
              "type": "string"
            },
            "description": "The new standards. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "type": "array"
          },
          "isArchived": {
            "description": "The new is archived flag. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "type": "boolean"
          },
          "mintEscrowCoinsToTransfer": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The coins to mint to the transfer address. Only used if collection has \"Non-Public\" balance type.",
            "type": "array"
          },
          "cosmosCoinWrapperPathsToAdd": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoinWrapperPathAddObject"
            },
            "description": "The IBC wrapper paths to add.",
            "type": "array"
          },
          "aliasPathsToAdd": {
            "items": {
              "$ref": "#/components/schemas/iAliasPathAddObject"
            },
            "description": "The alias (non-wrapping) paths to add.",
            "type": "array"
          },
          "invariants": {
            "description": "Collection-level invariants that cannot be broken. These are set upon genesis and cannot be modified. Addresses are generated by the keeper.",
            "$ref": "#/components/schemas/iInvariantsAddObject"
          }
        },
        "required": [
          "creator"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgDeleteCollection": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection to delete.",
            "$ref": "#/components/schemas/CollectionId"
          }
        },
        "required": [
          "creator",
          "collectionId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgTransferTokens": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection to transfer tokens from.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "transfers": {
            "items": {
              "$ref": "#/components/schemas/iTransfer"
            },
            "description": "The transfers to perform.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "transfers"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgUniversalUpdateCollection": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "defaultBalances": {
            "description": "The default balances for users who have not interacted with the collection yet. Only can be set on initial creation. Only used if collection has \"Standard\" balance type.",
            "$ref": "#/components/schemas/iUserBalanceStore"
          },
          "validTokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "The tokens to create. Newly created tokens will be sent to the \"Mint\" address. Must have necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. Only used if collection has \"Standard\" balance type.",
            "type": "array"
          },
          "collectionPermissions": {
            "description": "The new collection permissions. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "$ref": "#/components/schemas/iCollectionPermissions"
          },
          "manager": {
            "description": "The new manager. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionMetadata": {
            "description": "The new collection metadata. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "$ref": "#/components/schemas/iCollectionMetadata"
          },
          "tokenMetadata": {
            "items": {
              "$ref": "#/components/schemas/iTokenMetadata"
            },
            "description": "The new token metadata. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. Note we take first-match only for token IDs, so do not define duplicates.",
            "type": "array"
          },
          "customData": {
            "description": "The new custom data. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "type": "string"
          },
          "collectionApprovals": {
            "items": {
              "$ref": "#/components/schemas/iCollectionApproval"
            },
            "description": "The new collection approved transfers. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "type": "array"
          },
          "standards": {
            "items": {
              "type": "string"
            },
            "description": "The new standards. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "type": "array"
          },
          "isArchived": {
            "description": "The new is archived flag. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg.",
            "type": "boolean"
          },
          "mintEscrowCoinsToTransfer": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoin"
            },
            "description": "The coins to mint to the transfer address. Only used if collection has \"Non-Public\" balance type.",
            "type": "array"
          },
          "cosmosCoinWrapperPathsToAdd": {
            "items": {
              "$ref": "#/components/schemas/iCosmosCoinWrapperPathAddObject"
            },
            "description": "The IBC wrapper paths to add.",
            "type": "array"
          },
          "aliasPathsToAdd": {
            "items": {
              "$ref": "#/components/schemas/iAliasPathAddObject"
            },
            "description": "The alias (non-wrapping) paths to add.",
            "type": "array"
          },
          "invariants": {
            "description": "Collection-level invariants that cannot be broken. These are set upon genesis and cannot be modified. Addresses are generated by the keeper.",
            "$ref": "#/components/schemas/iInvariantsAddObject"
          },
          "collectionId": {
            "description": "The ID of the collection to update.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "updateCollectionPermissions": {
            "description": "Whether or not to update the collection permissions.",
            "type": "boolean"
          },
          "updateManager": {
            "description": "Whether or not to update the manager.",
            "type": "boolean"
          },
          "updateCollectionMetadata": {
            "description": "Whether or not to update the collection metadata.",
            "type": "boolean"
          },
          "updateTokenMetadata": {
            "description": "Whether or not to update the token metadata.",
            "type": "boolean"
          },
          "updateCustomData": {
            "description": "Whether or not to update the custom data.",
            "type": "boolean"
          },
          "updateCollectionApprovals": {
            "description": "Whether or not to update the collection approved transfers.",
            "type": "boolean"
          },
          "updateStandards": {
            "description": "Whether or not to update the standards.",
            "type": "boolean"
          },
          "updateIsArchived": {
            "description": "Whether or not to update the is archived flag.",
            "type": "boolean"
          },
          "updateValidTokenIds": {
            "description": "Whether or not to update the valid token IDs.",
            "type": "boolean"
          }
        },
        "required": [
          "creator",
          "collectionId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgUpdateCollection": {
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgUpdateUserApprovals": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection to transfer tokens from.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "updateOutgoingApprovals": {
            "description": "Whether or not to update the outgoing approvals.",
            "type": "boolean"
          },
          "outgoingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserOutgoingApproval"
            },
            "description": "The new outgoing approvals. Must have the necessary permissions to update.",
            "type": "array"
          },
          "updateIncomingApprovals": {
            "description": "Whether or not to update the incoming approvals.",
            "type": "boolean"
          },
          "incomingApprovals": {
            "items": {
              "$ref": "#/components/schemas/iUserIncomingApproval"
            },
            "description": "The new incoming approvals. Must have the necessary permissions to update.",
            "type": "array"
          },
          "updateAutoApproveSelfInitiatedOutgoingTransfers": {
            "description": "Whether or not to update the auto approve self initiated outgoing transfers (i.e. from == the user and initiator == the user).",
            "type": "boolean"
          },
          "autoApproveSelfInitiatedOutgoingTransfers": {
            "description": "The new auto approve self initiated outgoing transfers. Must have the necessary permissions to update.",
            "type": "boolean"
          },
          "updateAutoApproveSelfInitiatedIncomingTransfers": {
            "description": "Whether or not to update the auto approve self initiated incoming transfers (i.e. to == the user and initiator == the user).",
            "type": "boolean"
          },
          "autoApproveSelfInitiatedIncomingTransfers": {
            "description": "The new auto approve self initiated incoming transfers. Must have the necessary permissions to update.",
            "type": "boolean"
          },
          "updateAutoApproveAllIncomingTransfers": {
            "description": "Whether or not to update the auto approve all incoming transfers.",
            "type": "boolean"
          },
          "autoApproveAllIncomingTransfers": {
            "description": "The new auto approve all incoming transfers. Must have the necessary permissions to update.",
            "type": "boolean"
          },
          "updateUserPermissions": {
            "description": "Whether or not to update the user permissions.",
            "type": "boolean"
          },
          "userPermissions": {
            "description": "The new user permissions. Must have the necessary permissions to update.",
            "$ref": "#/components/schemas/iUserPermissions"
          }
        },
        "required": [
          "creator",
          "collectionId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgCreateDynamicStore": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "defaultValue": {
            "description": "The default value for uninitialized addresses (true/false).",
            "type": "boolean"
          },
          "uri": {
            "description": "URI for additional metadata or resources associated with this dynamic store.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Custom data field for storing arbitrary data associated with this dynamic store.",
            "type": "string"
          }
        },
        "required": [
          "creator",
          "defaultValue"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgUpdateDynamicStore": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "storeId": {
            "description": "The ID of the dynamic store to update.",
            "$ref": "#/components/schemas/NumberType"
          },
          "defaultValue": {
            "description": "The new default value for uninitialized addresses (true/false).",
            "type": "boolean"
          },
          "globalEnabled": {
            "description": "The global kill switch state (true = enabled, false = disabled/halted). Callers should query the current value first if they want to keep it unchanged.",
            "type": "boolean"
          },
          "uri": {
            "description": "URI for additional metadata or resources associated with this dynamic store.",
            "type": "string",
            "examples": [
              "https://example.com",
              "ipfs://Qm..."
            ]
          },
          "customData": {
            "description": "Custom data field for storing arbitrary data associated with this dynamic store.",
            "type": "string"
          }
        },
        "required": [
          "creator",
          "storeId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgDeleteDynamicStore": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "storeId": {
            "description": "The ID of the dynamic store to delete.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "creator",
          "storeId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetDynamicStoreValue": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "storeId": {
            "description": "The ID of the dynamic store.",
            "$ref": "#/components/schemas/NumberType"
          },
          "address": {
            "description": "The address for which to set the value.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "value": {
            "description": "The boolean value to set (true/false).",
            "type": "boolean"
          }
        },
        "required": [
          "creator",
          "storeId",
          "address",
          "value"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetIncomingApproval": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "approval": {
            "description": "The incoming approval to set.",
            "$ref": "#/components/schemas/iUserIncomingApproval"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "approval"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgDeleteIncomingApproval": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "approvalId": {
            "description": "The ID of the approval to delete.",
            "type": "string"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "approvalId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetOutgoingApproval": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "approval": {
            "description": "The outgoing approval to set.",
            "$ref": "#/components/schemas/iUserOutgoingApproval"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "approval"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgDeleteOutgoingApproval": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "approvalId": {
            "description": "The ID of the approval to delete.",
            "type": "string"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "approvalId"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgPurgeApprovals": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/CollectionId"
          },
          "purgeExpired": {
            "description": "Whether to purge expired approvals (approvals with no future valid transfer times).",
            "type": "boolean"
          },
          "approverAddress": {
            "description": "Address of the user whose approvals to purge. If empty, defaults to creator.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "purgeCounterpartyApprovals": {
            "description": "Whether to purge counterparty approvals (approvals where the creator is the only initiator).",
            "type": "boolean"
          },
          "approvalsToPurge": {
            "items": {
              "$ref": "#/components/schemas/iApprovalIdentifierDetails"
            },
            "description": "Specific approvals to purge. If empty, purges all applicable approvals based on other flags.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "purgeExpired",
          "approverAddress",
          "purgeCounterpartyApprovals",
          "approvalsToPurge"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetValidTokenIds": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/NumberType"
          },
          "validTokenIds": {
            "items": {
              "$ref": "#/components/schemas/iUintRange"
            },
            "description": "New token IDs to add to this collection.",
            "type": "array"
          },
          "canUpdateValidTokenIds": {
            "items": {
              "$ref": "#/components/schemas/iTokenIdsActionPermission"
            },
            "description": "Permission to update valid token IDs.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "validTokenIds",
          "canUpdateValidTokenIds"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetManager": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/NumberType"
          },
          "manager": {
            "description": "New manager to set.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "canUpdateManager": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "Permission to update manager.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "manager",
          "canUpdateManager"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetCollectionMetadata": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/NumberType"
          },
          "collectionMetadata": {
            "description": "New collection metadata to set.",
            "$ref": "#/components/schemas/iCollectionMetadata"
          },
          "canUpdateCollectionMetadata": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "Permission to update collection metadata.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "collectionMetadata",
          "canUpdateCollectionMetadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetTokenMetadata": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/NumberType"
          },
          "tokenMetadata": {
            "items": {
              "$ref": "#/components/schemas/iTokenMetadata"
            },
            "description": "New token metadata to set.",
            "type": "array"
          },
          "canUpdateTokenMetadata": {
            "items": {
              "$ref": "#/components/schemas/iTokenIdsActionPermission"
            },
            "description": "Permission to update token metadata.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "tokenMetadata",
          "canUpdateTokenMetadata"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetCustomData": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/NumberType"
          },
          "customData": {
            "description": "New custom data to set.",
            "type": "string"
          },
          "canUpdateCustomData": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "Permission to update custom data.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "customData",
          "canUpdateCustomData"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetStandards": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/NumberType"
          },
          "standards": {
            "items": {
              "type": "string"
            },
            "description": "New standards to set.",
            "type": "array"
          },
          "canUpdateStandards": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "Permission to update standards.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "standards",
          "canUpdateStandards"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetCollectionApprovals": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/NumberType"
          },
          "collectionApprovals": {
            "items": {
              "$ref": "#/components/schemas/iCollectionApproval"
            },
            "description": "New collection approvals to set.",
            "type": "array"
          },
          "canUpdateCollectionApprovals": {
            "items": {
              "$ref": "#/components/schemas/iCollectionApprovalPermission"
            },
            "description": "Permission to update collection approvals.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "collectionApprovals",
          "canUpdateCollectionApprovals"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgSetIsArchived": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The ID of the collection.",
            "$ref": "#/components/schemas/NumberType"
          },
          "isArchived": {
            "description": "New isArchived flag to set.",
            "type": "boolean"
          },
          "canArchiveCollection": {
            "items": {
              "$ref": "#/components/schemas/iActionPermission"
            },
            "description": "Permission to archive collection.",
            "type": "array"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "isArchived",
          "canArchiveCollection"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgCastVote": {
        "properties": {
          "creator": {
            "description": "The creator of the transaction.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "collectionId": {
            "description": "The collection ID for the voting challenge.",
            "$ref": "#/components/schemas/NumberType"
          },
          "approvalLevel": {
            "description": "The approval level (\"collection\", \"incoming\", or \"outgoing\").",
            "type": "string",
            "examples": [
              "collection",
              "incoming",
              "outgoing"
            ]
          },
          "approverAddress": {
            "description": "The approver address (empty string for collection-level approvals).",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "approvalId": {
            "description": "The approval ID.",
            "type": "string"
          },
          "proposalId": {
            "description": "The proposal ID (challenge ID) from the VotingChallenge.",
            "type": "string"
          },
          "yesWeight": {
            "description": "The percentage weight (0-100) allocated to \"yes\" vote. The remaining percentage (100 - yesWeight) is allocated to \"no\" vote.",
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "creator",
          "collectionId",
          "approvalLevel",
          "approverAddress",
          "approvalId",
          "proposalId",
          "yesWeight"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgCreateManagerSplitter": {
        "properties": {
          "admin": {
            "description": "The admin address creating the entity.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "permissions": {
            "description": "Permissions mapping each CollectionPermission field to execution criteria.",
            "$ref": "#/components/schemas/iManagerSplitterPermissions"
          }
        },
        "required": [
          "admin",
          "permissions"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgUpdateManagerSplitter": {
        "properties": {
          "admin": {
            "description": "The admin address updating the entity.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "address": {
            "description": "Address of the manager splitter to update.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "permissions": {
            "description": "New permissions to set.",
            "$ref": "#/components/schemas/iManagerSplitterPermissions"
          }
        },
        "required": [
          "admin",
          "address",
          "permissions"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgDeleteManagerSplitter": {
        "properties": {
          "admin": {
            "description": "The admin address deleting the entity.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "address": {
            "description": "Address of the manager splitter to delete.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          }
        },
        "required": [
          "admin",
          "address"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "iMsgExecuteUniversalUpdateCollection": {
        "properties": {
          "executor": {
            "description": "Address executing the message (must be approved or admin).",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "managerSplitterAddress": {
            "description": "Address of the manager splitter to execute through.",
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "universalUpdateCollectionMsg": {
            "description": "The UniversalUpdateCollection message to execute.",
            "$ref": "#/components/schemas/iMsgUniversalUpdateCollection"
          }
        },
        "required": [
          "executor",
          "managerSplitterAddress",
          "universalUpdateCollectionMsg"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "Fee": {
        "properties": {
          "amount": {
            "type": "string"
          },
          "denom": {
            "type": "string"
          },
          "gas": {
            "type": "string"
          }
        },
        "required": [
          "amount",
          "denom",
          "gas"
        ],
        "additionalProperties": false,
        "description": "Fee represents a Cosmos SDK transaction fee object.",
        "type": "object"
      },
      "Sender": {
        "properties": {
          "accountAddress": {
            "$ref": "#/components/schemas/BitBadgesAddress"
          },
          "sequence": {
            "type": "number"
          },
          "accountNumber": {
            "type": "number"
          },
          "pubkey": {
            "type": "string"
          }
        },
        "required": [
          "accountAddress",
          "sequence",
          "accountNumber",
          "pubkey"
        ],
        "additionalProperties": false,
        "description": "Sender represents a Cosmos SDK Transaction signer.\n@remarks A sender object is used to populate the Cosmos SDK's SignerInfo field,\nwhich is used to declare transaction signers.",
        "type": "object"
      },
      "Chain": {
        "properties": {
          "chainId": {
            "type": "number"
          },
          "cosmosChainId": {
            "type": "string"
          },
          "chain": {
            "$ref": "#/components/schemas/SupportedChain"
          }
        },
        "required": [
          "chainId",
          "cosmosChainId",
          "chain"
        ],
        "additionalProperties": false,
        "description": "Chain represents the base chain's chainID.",
        "type": "object"
      },
      "AminoMsg": {
        "properties": {
          "type": {
            "type": "string"
          },
          "value": {}
        },
        "required": [
          "type",
          "value"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "StdFee": {
        "properties": {
          "amount": {},
          "gas": {
            "type": "string"
          },
          "granter": {
            "description": "The granter address that is used for paying with feegrants",
            "type": "string"
          },
          "payer": {
            "description": "The fee payer address. The payer must have signed the transaction.",
            "type": "string"
          }
        },
        "required": [
          "amount",
          "gas"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "StdSignDoc": {
        "properties": {
          "chain_id": {
            "type": "string"
          },
          "account_number": {
            "type": "string"
          },
          "sequence": {
            "type": "string"
          },
          "fee": {
            "$ref": "#/components/schemas/StdFee"
          },
          "msgs": {},
          "memo": {
            "type": "string"
          },
          "timeout_height": {
            "type": "string"
          }
        },
        "required": [
          "chain_id",
          "account_number",
          "sequence",
          "fee",
          "msgs",
          "memo"
        ],
        "additionalProperties": false,
        "description": "The document to be signed\n\n@see https ://docs.cosmos.network/master/modules/auth/03_types.html#stdsigndoc",
        "type": "object"
      },
      "UintRange": {
        "properties": {
          "start": {
            "$ref": "#/components/schemas/NumberType"
          },
          "end": {
            "$ref": "#/components/schemas/NumberType"
          }
        },
        "required": [
          "start",
          "end"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "AccountResponse": {
        "properties": {
          "account": {
            "properties": {
              "'@type'": {
                "type": "string"
              },
              "base_account": {
                "properties": {
                  "address": {
                    "type": "string"
                  },
                  "pub_key": {
                    "properties": {
                      "'@type'": {
                        "type": "string"
                      },
                      "key": {
                        "type": "string"
                      }
                    },
                    "required": [
                      "'@type'",
                      "key"
                    ],
                    "additionalProperties": false,
                    "type": "object"
                  },
                  "account_number": {
                    "type": "string"
                  },
                  "sequence": {
                    "type": "string"
                  }
                },
                "required": [
                  "address",
                  "account_number",
                  "sequence"
                ],
                "additionalProperties": false,
                "type": "object"
              }
            },
            "required": [
              "'@type'",
              "base_account"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "account"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "CounterParty": {
        "properties": {
          "port_id": {
            "type": "string"
          },
          "channel_id": {
            "type": "string"
          }
        },
        "required": [
          "port_id",
          "channel_id"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "Channel": {
        "properties": {
          "state": {
            "type": "string"
          },
          "ordering": {
            "type": "string"
          },
          "counterparty": {
            "$ref": "#/components/schemas/CounterParty"
          },
          "connection_hops": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "version": {
            "type": "string"
          },
          "port_id": {
            "type": "string"
          },
          "channel_id": {
            "type": "string"
          }
        },
        "required": [
          "state",
          "ordering",
          "counterparty",
          "connection_hops",
          "version",
          "port_id",
          "channel_id"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "ChannelsResponse": {
        "properties": {
          "channels": {
            "items": {
              "$ref": "#/components/schemas/Channel"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "next_key": {
                "type": "string"
              },
              "total": {
                "type": "string"
              }
            },
            "required": [
              "total"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "height": {
            "properties": {
              "revision_number": {
                "type": "string"
              },
              "revision_height": {
                "type": "string"
              }
            },
            "required": [
              "revision_number",
              "revision_height"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "channels",
          "pagination",
          "height"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "TxToSend": {
        "properties": {
          "message": {
            "properties": {
              "toBinary": {}
            },
            "required": [
              "toBinary"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "path": {
            "type": "string"
          }
        },
        "required": [
          "message",
          "path"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "BroadcastPostBody": {
        "properties": {
          "tx_bytes": {},
          "mode": {
            "type": "string"
          }
        },
        "required": [
          "tx_bytes",
          "mode"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "BalancesResponse": {
        "properties": {
          "balances": {
            "items": {},
            "type": "array"
          },
          "pagination": {
            "properties": {
              "next_key": {
                "type": "string"
              },
              "total": {
                "type": "number"
              }
            },
            "required": [
              "next_key",
              "total"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "balances",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "Reward": {
        "properties": {
          "validator_address": {
            "type": "string"
          },
          "reward": {
            "items": {},
            "type": "array"
          }
        },
        "required": [
          "validator_address",
          "reward"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "DistributionRewardsResponse": {
        "properties": {
          "rewards": {
            "items": {
              "$ref": "#/components/schemas/Reward"
            },
            "type": "array"
          },
          "total": {
            "items": {},
            "type": "array"
          }
        },
        "required": [
          "rewards",
          "total"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "Validator": {
        "properties": {
          "commission": {
            "properties": {
              "commission_rates": {
                "properties": {
                  "max_change_rate": {
                    "type": "string"
                  },
                  "max_rate": {
                    "type": "string"
                  },
                  "rate": {
                    "type": "string"
                  }
                },
                "required": [
                  "max_change_rate",
                  "max_rate",
                  "rate"
                ],
                "additionalProperties": false,
                "type": "object"
              },
              "update_time": {
                "type": "string"
              }
            },
            "required": [
              "commission_rates",
              "update_time"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "consensus_pubkey": {
            "properties": {
              "'@type'": {
                "type": "string"
              },
              "key": {
                "type": "string"
              }
            },
            "required": [
              "'@type'",
              "key"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "delegator_shares": {
            "type": "string"
          },
          "description": {
            "properties": {
              "details": {
                "type": "string"
              },
              "identity": {
                "type": "string"
              },
              "moniker": {
                "type": "string"
              },
              "security_contact": {
                "type": "string"
              },
              "website": {
                "type": "string"
              }
            },
            "required": [
              "details",
              "identity",
              "moniker",
              "security_contact",
              "website"
            ],
            "additionalProperties": false,
            "type": "object",
            "examples": [
              "Brief description."
            ]
          },
          "jailed": {
            "type": "boolean"
          },
          "min_self_delegation": {
            "type": "string"
          },
          "operator_address": {
            "type": "string"
          },
          "status": {
            "type": "string"
          },
          "tokens": {
            "type": "string"
          },
          "unbonding_height": {
            "type": "string"
          },
          "unbonding_time": {
            "type": "string"
          }
        },
        "required": [
          "commission",
          "consensus_pubkey",
          "delegator_shares",
          "description",
          "jailed",
          "min_self_delegation",
          "operator_address",
          "status",
          "tokens",
          "unbonding_height",
          "unbonding_time"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "GetValidatorsResponse": {
        "properties": {
          "validators": {
            "items": {
              "$ref": "#/components/schemas/Validator"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "next_key": {
                "type": "string"
              },
              "total": {
                "type": "number"
              }
            },
            "required": [
              "next_key",
              "total"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "validators",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "DelegationResponse": {
        "properties": {
          "balance": {},
          "delegation": {
            "properties": {
              "delegator_address": {
                "type": "string"
              },
              "shares": {
                "type": "string"
              },
              "validator_address": {
                "type": "string"
              }
            },
            "required": [
              "delegator_address",
              "shares",
              "validator_address"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "balance",
          "delegation"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "GetDelegationsResponse": {
        "properties": {
          "delegation_responses": {
            "items": {
              "$ref": "#/components/schemas/DelegationResponse"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "next_key": {
                "type": "string"
              },
              "total": {
                "type": "number"
              }
            },
            "required": [
              "next_key",
              "total"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "delegation_responses",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "UndelegationResponse": {
        "properties": {
          "delegator_address": {
            "type": "string"
          },
          "validator_address": {
            "type": "string"
          },
          "entries": {
            "items": [
              {
                "properties": {
                  "creation_height": {
                    "type": "string"
                  },
                  "completion_time": {
                    "type": "string"
                  },
                  "initial_balance": {
                    "type": "string"
                  },
                  "balance": {
                    "type": "string"
                  }
                },
                "required": [
                  "creation_height",
                  "completion_time",
                  "initial_balance",
                  "balance"
                ],
                "additionalProperties": false,
                "type": "object"
              }
            ],
            "additionalItems": false,
            "minItems": 1,
            "type": "array"
          }
        },
        "required": [
          "delegator_address",
          "validator_address",
          "entries"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "GetUndelegationsResponse": {
        "properties": {
          "unbonding_responses": {
            "items": {
              "$ref": "#/components/schemas/UndelegationResponse"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "next_key": {
                "type": "string"
              },
              "total": {
                "type": "string"
              }
            },
            "required": [
              "next_key",
              "total"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "unbonding_responses",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "Proposal": {
        "properties": {
          "proposal_id": {
            "type": "string"
          },
          "content": {
            "properties": {
              "'@type'": {
                "type": "string"
              },
              "title": {
                "type": "string"
              },
              "description": {
                "type": "string",
                "examples": [
                  "Brief description."
                ]
              }
            },
            "required": [
              "'@type'",
              "title",
              "description"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "status": {
            "type": "string"
          },
          "final_tally_result": {
            "properties": {
              "yes": {
                "type": "string"
              },
              "abstain": {
                "type": "string"
              },
              "no": {
                "type": "string"
              },
              "no_with_veto": {
                "type": "string"
              }
            },
            "required": [
              "yes",
              "abstain",
              "no",
              "no_with_veto"
            ],
            "additionalProperties": false,
            "type": "object"
          },
          "submit_time": {
            "type": "string"
          },
          "deposit_end_time": {
            "type": "string"
          },
          "total_deposit": {
            "items": {},
            "type": "array"
          },
          "voting_start_time": {
            "type": "string"
          },
          "voting_end_time": {
            "type": "string"
          }
        },
        "required": [
          "proposal_id",
          "content",
          "status",
          "final_tally_result",
          "submit_time",
          "deposit_end_time",
          "total_deposit",
          "voting_start_time",
          "voting_end_time"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "ProposalsResponse": {
        "properties": {
          "proposals": {
            "items": {
              "$ref": "#/components/schemas/Proposal"
            },
            "type": "array"
          },
          "pagination": {
            "properties": {
              "next_key": {
                "type": "string"
              },
              "total": {
                "type": "number"
              }
            },
            "required": [
              "next_key",
              "total"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "proposals",
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "TallyResponse": {
        "properties": {
          "tally": {
            "properties": {
              "yes": {
                "type": "string"
              },
              "abstain": {
                "type": "string"
              },
              "no": {
                "type": "string"
              },
              "no_with_veto": {
                "type": "string"
              }
            },
            "required": [
              "yes",
              "abstain",
              "no",
              "no_with_veto"
            ],
            "additionalProperties": false,
            "type": "object"
          }
        },
        "required": [
          "tally"
        ],
        "additionalProperties": false,
        "type": "object"
      },
      "SkipGoMessage": {
        "properties": {
          "multi_chain_msg": {
            "$ref": "#/components/schemas/MultiChainMsg"
          },
          "evm_tx": {
            "$ref": "#/components/schemas/EvmTx"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "OauthAppName": {
        "enum": [
          "twitter",
          "github",
          "google",
          "email",
          "discord",
          "twitch",
          "strava",
          "youtube",
          "reddit",
          "facebook",
          "mailchimp",
          "bluesky",
          "googleCalendar",
          "telegram",
          "farcaster",
          "slack",
          "linkedIn",
          "shopify"
        ],
        "type": "string"
      },
      "iBaseQueryParams": {
        "properties": {
          "bookmark": {
            "type": "string"
          },
          "oldestFirst": {
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "type": "object"
      },
      "iBaseSuccessResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationInfo"
          }
        },
        "required": [
          "pagination"
        ],
        "additionalProperties": false,
        "type": "object"
      }
    }
  }
}