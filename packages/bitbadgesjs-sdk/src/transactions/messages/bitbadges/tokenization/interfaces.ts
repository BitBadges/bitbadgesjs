import type { BitBadgesAddress } from '@/api-indexer/docs-types/interfaces.js';
import type { NumberType } from '@/common/string-numbers.js';
import type { iCosmosCoin } from '@/core/coin.js';
import type { iCollectionApproval, iUserIncomingApproval, iUserOutgoingApproval } from '../../../../interfaces/types/approvals.js';
import type {
  CollectionId,
  iAddressList,
  iApprovalIdentifierDetails,
  iCollectionMetadata,
  iAliasPathAddObject,
  iCosmosCoinWrapperPathAddObject,
  iInvariantsAddObject,
  iTokenMetadata,
  iTransfer,
  iUintRange
} from '../../../../interfaces/types/core.js';
import type {
  iActionPermission,
  iCollectionApprovalPermission,
  iCollectionPermissions,
  iTokenIdsActionPermission,
  iUserPermissions
} from '../../../../interfaces/types/permissions.js';
import type { iUserBalanceStore } from '../../../../interfaces/types/userBalances.js';

/**
 * @category Interfaces
 */
export interface iMsgCreateAddressLists {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The address lists to create. */
  addressLists: iAddressList[];
}

/**
 * @category Interfaces
 */
export interface iMsgCreateCollection<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;

  /** The default balances for users who have not interacted with the collection yet. Only can be set on initial creation. Only used if collection has "Standard" balance type. */
  defaultBalances?: iUserBalanceStore<T>;

  /** The tokens to create. Newly created tokens will be sent to the "Mint" address. Must have necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. Only used if collection has "Standard" balance type. */
  validTokenIds?: iUintRange<T>[];

  /** The new collection permissions. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. */
  collectionPermissions?: iCollectionPermissions<T>;

  /** The new manager. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. */
  manager?: BitBadgesAddress;

  /** The new collection metadata. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. */
  collectionMetadata?: iCollectionMetadata;

  /** The new token metadata. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. Note we take first-match only for token IDs, so do not define duplicates. */
  tokenMetadata?: iTokenMetadata<T>[];

  /** The new custom data. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. */
  customData?: string;

  /** The new collection approved transfers. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. */
  collectionApprovals?: iCollectionApproval<T>[];

  /** The new standards. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. */
  standards?: string[];

  /** The new is archived flag. Must have the necessary permissions in future transactions to update. However, no restrictions in this genesis Msg. */
  isArchived?: boolean;

  /** The coins to mint to the transfer address. Only used if collection has "Non-Public" balance type. */
  mintEscrowCoinsToTransfer?: iCosmosCoin<T>[];

  /** The IBC wrapper paths to add. */
  cosmosCoinWrapperPathsToAdd?: iCosmosCoinWrapperPathAddObject<T>[];

  /** The alias (non-wrapping) paths to add. */
  aliasPathsToAdd?: iAliasPathAddObject<T>[];

  /** Collection-level invariants that cannot be broken. These are set upon genesis and cannot be modified. Addresses are generated by the keeper. */
  invariants?: iInvariantsAddObject<T>;
}

/**
 * @category Interfaces
 */
export interface iMsgDeleteCollection<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection to delete. */
  collectionId: CollectionId;
}

/**
 * @category Interfaces
 */
export interface iMsgTransferTokens<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection to transfer tokens from. */
  collectionId: CollectionId;
  /** The transfers to perform. */
  transfers: iTransfer<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgUniversalUpdateCollection<T extends NumberType> extends iMsgCreateCollection<T> {
  /** The ID of the collection to update. */
  collectionId: CollectionId;
  /** Whether or not to update the collection permissions. */
  updateCollectionPermissions?: boolean;
  /** Whether or not to update the manager. */
  updateManager?: boolean;
  /** Whether or not to update the collection metadata. */
  updateCollectionMetadata?: boolean;
  /** Whether or not to update the token metadata. */
  updateTokenMetadata?: boolean;
  /** Whether or not to update the custom data. */
  updateCustomData?: boolean;
  /** Whether or not to update the collection approved transfers. */
  updateCollectionApprovals?: boolean;
  /** Whether or not to update the standards. */
  updateStandards?: boolean;
  /** Whether or not to update the is archived flag. */
  updateIsArchived?: boolean;
  /** Whether or not to update the valid token IDs. */
  updateValidTokenIds?: boolean;
}

/**
 * @category Interfaces
 */
export interface iMsgUpdateCollection<T extends NumberType> extends Omit<iMsgUniversalUpdateCollection<T>, 'defaultBalances'> {}

/**
 * @category Interfaces
 */
export interface iMsgUpdateUserApprovals<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection to transfer tokens from. */
  collectionId: CollectionId;
  /** Whether or not to update the outgoing approvals. */
  updateOutgoingApprovals?: boolean;
  /** The new outgoing approvals. Must have the necessary permissions to update.  */
  outgoingApprovals?: iUserOutgoingApproval<T>[];
  /** Whether or not to update the incoming approvals. */
  updateIncomingApprovals?: boolean;
  /** The new incoming approvals. Must have the necessary permissions to update. */
  incomingApprovals?: iUserIncomingApproval<T>[];
  /** Whether or not to update the auto approve self initiated outgoing transfers (i.e. from == the user and initiator == the user). */
  updateAutoApproveSelfInitiatedOutgoingTransfers?: boolean;
  /** The new auto approve self initiated outgoing transfers. Must have the necessary permissions to update. */
  autoApproveSelfInitiatedOutgoingTransfers?: boolean;
  /** Whether or not to update the auto approve self initiated incoming transfers (i.e. to == the user and initiator == the user). */
  updateAutoApproveSelfInitiatedIncomingTransfers?: boolean;
  /** The new auto approve self initiated incoming transfers. Must have the necessary permissions to update. */
  autoApproveSelfInitiatedIncomingTransfers?: boolean;
  /** Whether or not to update the auto approve all incoming transfers. */
  updateAutoApproveAllIncomingTransfers?: boolean;
  /** The new auto approve all incoming transfers. Must have the necessary permissions to update. */
  autoApproveAllIncomingTransfers?: boolean;
  /** Whether or not to update the user permissions. */
  updateUserPermissions?: boolean;
  /** The new user permissions. Must have the necessary permissions to update. */
  userPermissions?: iUserPermissions<T>;
}

/**
 * @category Interfaces
 */
export interface iMsgCreateDynamicStore {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The default value for uninitialized addresses (true/false). */
  defaultValue: boolean;
  /** URI for additional metadata or resources associated with this dynamic store. */
  uri?: string;
  /** Custom data field for storing arbitrary data associated with this dynamic store. */
  customData?: string;
}

/**
 * @category Interfaces
 */
export interface iMsgUpdateDynamicStore<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the dynamic store to update. */
  storeId: T;
  /** The new default value for uninitialized addresses (true/false). */
  defaultValue?: boolean;
  /** The global kill switch state (true = enabled, false = disabled/halted). Callers should query the current value first if they want to keep it unchanged. */
  globalEnabled?: boolean;
  /** URI for additional metadata or resources associated with this dynamic store. */
  uri?: string;
  /** Custom data field for storing arbitrary data associated with this dynamic store. */
  customData?: string;
}

/**
 * @category Interfaces
 */
export interface iMsgDeleteDynamicStore<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the dynamic store to delete. */
  storeId: T;
}

/**
 * @category Interfaces
 */
export interface iMsgSetDynamicStoreValue<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the dynamic store. */
  storeId: T;
  /** The address for which to set the value. */
  address: BitBadgesAddress;
  /** The boolean value to set (true/false). */
  value: boolean;
}

/**
 * @category Interfaces
 */
export interface iMsgSetIncomingApproval<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: CollectionId;
  /** The incoming approval to set. */
  approval: iUserIncomingApproval<T>;
}

/**
 * @category Interfaces
 */
export interface iMsgDeleteIncomingApproval {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: CollectionId;
  /** The ID of the approval to delete. */
  approvalId: string;
}

/**
 * @category Interfaces
 */
export interface iMsgSetOutgoingApproval<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: CollectionId;
  /** The outgoing approval to set. */
  approval: iUserOutgoingApproval<T>;
}

/**
 * @category Interfaces
 */
export interface iMsgDeleteOutgoingApproval {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: CollectionId;
  /** The ID of the approval to delete. */
  approvalId: string;
}

/**
 * @category Interfaces
 */
export interface iMsgPurgeApprovals<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: CollectionId;
  /** Whether to purge expired approvals (approvals with no future valid transfer times). */
  purgeExpired: boolean;
  /** Address of the user whose approvals to purge. If empty, defaults to creator. */
  approverAddress: BitBadgesAddress;
  /** Whether to purge counterparty approvals (approvals where the creator is the only initiator). */
  purgeCounterpartyApprovals: boolean;
  /** Specific approvals to purge. If empty, purges all applicable approvals based on other flags. */
  approvalsToPurge: iApprovalIdentifierDetails<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgSetValidTokenIds<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: T;
  /** New token IDs to add to this collection. */
  validTokenIds: iUintRange<T>[];
  /** Permission to update valid token IDs. */
  canUpdateValidTokenIds: iTokenIdsActionPermission<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgSetManager<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: T;
  /** New manager to set. */
  manager: BitBadgesAddress;
  /** Permission to update manager. */
  canUpdateManager: iActionPermission<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgSetCollectionMetadata<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: T;
  /** New collection metadata to set. */
  collectionMetadata: iCollectionMetadata;
  /** Permission to update collection metadata. */
  canUpdateCollectionMetadata: iActionPermission<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgSetTokenMetadata<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: T;
  /** New token metadata to set. */
  tokenMetadata: iTokenMetadata<T>[];
  /** Permission to update token metadata. */
  canUpdateTokenMetadata: iTokenIdsActionPermission<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgSetCustomData<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: T;
  /** New custom data to set. */
  customData: string;
  /** Permission to update custom data. */
  canUpdateCustomData: iActionPermission<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgSetStandards<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: T;
  /** New standards to set. */
  standards: string[];
  /** Permission to update standards. */
  canUpdateStandards: iActionPermission<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgSetCollectionApprovals<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: T;
  /** New collection approvals to set. */
  collectionApprovals: iCollectionApproval<T>[];
  /** Permission to update collection approvals. */
  canUpdateCollectionApprovals: iCollectionApprovalPermission<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgSetIsArchived<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The ID of the collection. */
  collectionId: T;
  /** New isArchived flag to set. */
  isArchived: boolean;
  /** Permission to archive collection. */
  canArchiveCollection: iActionPermission<T>[];
}

/**
 * @category Interfaces
 */
export interface iMsgCastVote<T extends NumberType> {
  /** The creator of the transaction. */
  creator: BitBadgesAddress;
  /** The collection ID for the voting challenge. */
  collectionId: T;
  /** The approval level ("collection", "incoming", or "outgoing"). */
  approvalLevel: string;
  /** The approver address (empty string for collection-level approvals). */
  approverAddress: BitBadgesAddress;
  /** The approval ID. */
  approvalId: string;
  /** The proposal ID (challenge ID) from the VotingChallenge. */
  proposalId: string;
  /** The percentage weight (0-100) allocated to "yes" vote. The remaining percentage (100 - yesWeight) is allocated to "no" vote. */
  yesWeight: T;
}
