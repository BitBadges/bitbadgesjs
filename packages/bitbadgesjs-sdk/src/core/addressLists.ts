import { CustomTypeClass } from '@/common/base';
import type { iAddressList } from '@/interfaces/badges/core';
import * as proto from '@/proto';
import type { JsonReadOptions, JsonValue } from '@bufbuild/protobuf';
import { convertToCosmosAddress, isAddressValid } from '../address-converter/converter';

/**
 * AddressLists represent a list of addresses, identified by a unique ID.
 *
 * Some list IDs are reserved and auto generated by the blockchain.
 * Otherwise, the list can be created on-chain via MsgCreateAddressLists.
 *
 * For the BitBadges indexer / API, we also allow users to create off-chain lists hosted in a centralized manner.
 *
 * On-chain lists are stored on the blockchain, are permanent, non editable, non deletable, and can be used for defining permissions and approvals.
 * Off-chain lists are stored off-chain, are mutable, and can be edited / deleted at any time by the creator.
 *
 * @category Address Lists
 */
export class AddressList extends CustomTypeClass<AddressList> implements iAddressList {
  listId: string;
  addresses: string[];
  whitelist: boolean;
  uri: string;
  customData: string;
  createdBy?: string;
  aliasAddress?: string;

  constructor(addressList: iAddressList) {
    super();
    this.listId = addressList.listId;
    this.addresses = addressList.addresses;
    this.whitelist = addressList.whitelist;
    this.uri = addressList.uri;
    this.customData = addressList.customData;
    this.createdBy = addressList.createdBy;
    this.aliasAddress = addressList.aliasAddress;
  }

  /**
   * Checks if a specific account is in the given address list. This means added to a whitelist or NOT included in a blacklist.
   *
   * @remarks
   * The double negative may get confusing.
   */
  checkAddress(address: string): boolean {
    let found = this.addresses.includes(address);

    if (!this.whitelist) {
      found = !found;
    }

    return found;
  }

  isEmpty(): boolean {
    return this.addresses.length === 0 && this.whitelist;
  }

  /**
   * Inverts the list in-place. Simply done by invert the whitelist property.
   */
  invert(): this {
    this.whitelist = !this.whitelist;
    return this;
  }

  /**
   * Returns a new list with the addresses inverted.
   */
  toInverted(): AddressList {
    return this.clone().invert();
  }

  /**
   * Removes addresses from the list in-place.
   *
   * If this is a whitelist, the address will be removed (if it is currently added).
   * If this is a blacklist, the address will be added (if it is not currently added).
   * Otherwise, it is a no-op since it is already removed.
   */
  remove(addresses: string | iAddressList): this {
    if (typeof addresses === 'string') {
      return this.remove(
        new AddressList({
          listId: '',
          addresses: [addresses],
          whitelist: true,
          uri: '',
          customData: '',
          createdBy: ''
        })
      );
    }

    const [remaining] = AddressList.getOverlapDetails(addresses, this);
    this.addresses = remaining.addresses;
    this.whitelist = remaining.whitelist;
    return this;
  }

  /**
   * Wrapper for {@link remove} that returns a new list instead of modifying the current one.
   */
  toRemoved(addresses: string | iAddressList): AddressList {
    return this.clone().remove(addresses);
  }

  /**
   * Gets the addresses that are in both lists.
   *
   * Note the returned value can be a whitelist or a blacklist, depending on the input lists.
   * For example, all addresses except Bob (blacklist) overlap or just Bob (whitelist) overlap.
   */
  getOverlaps(addressList: iAddressList): AddressList {
    const [, removed] = AddressList.getOverlapDetails(this, addressList);
    return removed;
  }

  /**
   * Gets the overlap details for two address lists. Returns [inFirstListButNotSecond, inBothLists, inSecondListButNotFirst].
   */
  getOverlapDetails(addressList: iAddressList): [AddressList, AddressList, AddressList] {
    const [remaining, removed] = AddressList.getOverlapDetails(this, addressList);
    const [remaining2] = AddressList.getOverlapDetails(addressList, this);
    return [remaining, removed, remaining2];
  }

  /**
   * Returns the reserved 'All' address list.
   */
  static AllAddresses(): AddressList {
    return AddressList.getReservedAddressList('All');
  }

  /**
   * Returns a reserved address list by ID.
   */
  static Reserved(addressListId: string): AddressList {
    return AddressList.getReservedAddressList(addressListId);
  }

  private static getRemainingAndRemoved(addressesToRemove: iAddressList, addressList: iAddressList) {
    const duplicates = [];
    const inToRemoveButNotList = [];
    const inListButNotToRemove = [];

    for (const address of addressesToRemove.addresses) {
      // Check if address is in addressList.addresses
      const found = addressList.addresses.includes(address);

      if (found) {
        duplicates.push(address);
      } else {
        inToRemoveButNotList.push(address);
      }
    }

    for (const address of addressList.addresses) {
      // Check if address is in addressesToRemove.addresses
      const found = addressesToRemove.addresses.includes(address);

      if (!found) {
        inListButNotToRemove.push(address);
      }
    }

    const removed = new AddressList({
      addresses: [],
      whitelist: false,
      listId: '',
      uri: '',
      customData: '',
      createdBy: ''
    });

    const remaining = new AddressList({
      addresses: [],
      whitelist: false,
      listId: '',
      uri: '',
      customData: '',
      createdBy: ''
    });

    if (addressesToRemove.whitelist && addressList.whitelist) {
      // Case 1
      removed.whitelist = true;
      removed.addresses = duplicates;

      remaining.whitelist = true;
      remaining.addresses = inListButNotToRemove;
    } else if (!addressesToRemove.whitelist && addressList.whitelist) {
      // Case 2
      removed.whitelist = true;
      removed.addresses = inListButNotToRemove;

      remaining.whitelist = true;
      remaining.addresses = duplicates;
    } else if (addressesToRemove.whitelist && !addressList.whitelist) {
      // Case 3
      removed.whitelist = true;
      removed.addresses = inToRemoveButNotList;

      remaining.whitelist = false;
      remaining.addresses = [...inListButNotToRemove, ...inToRemoveButNotList, ...duplicates];
    } else if (!addressesToRemove.whitelist && !addressList.whitelist) {
      // Case 4
      removed.whitelist = false;
      removed.addresses = [...inListButNotToRemove, ...inToRemoveButNotList, ...duplicates];

      remaining.whitelist = true;
      remaining.addresses = inToRemoveButNotList;
    }

    return [remaining, removed];
  }

  /**
   * Gets the overlap details between two address lists. Returns [inFirstButNotSecond, overlaps, inSecondButNotFirst].
   */
  static getOverlapDetails(firstList: iAddressList, secondList: iAddressList): [AddressList, AddressList, AddressList] {
    const [inFirstButNotSecond, overlaps] = AddressList.getRemainingAndRemoved(secondList, firstList);
    const [inSecondButNotFirst] = AddressList.getRemainingAndRemoved(firstList, secondList);
    return [inFirstButNotSecond, overlaps, inSecondButNotFirst];
  }

  /**
   * Returns the tracker list for a tracker ID list. Little different logic because tracker ID lists can only be reserved IDs (no storage)
   * and can be nonvalid addresses
   */
  static getReservedTrackerList(trackerListId: string) {
    return AddressList.getReservedList(trackerListId, true);
  }

  /**
   * Returns the address list for a list ID, if it is a reserved ID (i.e. Mint, Manager, All, None, validly formatted address, ...)
   */
  static getReservedAddressList(addressListId: string): AddressList {
    return AddressList.getReservedList(addressListId);
  }

  private static getReservedList(addressListId: string, allowAliases?: boolean): AddressList {
    let inverted = false;
    let addressList: AddressList | undefined = undefined;
    const addressListIdCopy = addressListId;

    if (addressListId[0] === '!' && !addressListId.startsWith('!(')) {
      inverted = true;
      addressListId = addressListId.slice(1);
    } else if (addressListId.startsWith('!(') && addressListId.endsWith(')')) {
      inverted = true;
      addressListId = addressListId.slice(2, -1);
    }

    if (addressListId === 'Mint') {
      addressList = new AddressList({
        listId: 'Mint',
        addresses: ['Mint'],
        whitelist: true,
        uri: '',
        customData: '',
        createdBy: ''
      });
    } else if (addressListId.startsWith('AllWithout')) {
      addressList = new AddressList({
        listId: addressListId,
        addresses: [],
        whitelist: false,
        uri: '',
        customData: '',
        createdBy: ''
      });

      const addresses = addressListId.slice(10).split(':');

      for (const address of addresses) {
        addressList.addresses.push(address);
      }
    } else if (addressListId === 'AllWithMint' || addressListId === 'All') {
      addressList = new AddressList({
        listId: addressListId,
        addresses: [],
        whitelist: false,
        uri: '',
        customData: '',
        createdBy: ''
      });
    } else if (addressListId === 'None') {
      addressList = new AddressList({
        listId: 'None',
        addresses: [],
        whitelist: true,
        uri: '',
        customData: '',
        createdBy: ''
      });
    } else {
      //split by :
      const addressesToCheck = addressListId.split(':');
      let allAreValid = true;
      //For tracker IDs, we allow aliasses(aka non valid addresses)
      if (!allowAliases) {
        for (const address of addressesToCheck) {
          if (address != 'Mint' && !convertToCosmosAddress(address)) {
            allAreValid = false;
          }
        }
      }

      if (allAreValid) {
        addressList = new AddressList({
          listId: addressListId,
          addresses: addressesToCheck,
          whitelist: true,
          uri: '',
          customData: '',
          createdBy: ''
        });
      }
    }

    if (inverted && addressList) {
      addressList.whitelist = !addressList.whitelist;
    }

    if (!addressList) {
      throw new Error(`Invalid address list ID: ${addressListId}`);
    }

    return new AddressList({
      ...addressList,
      listId: addressListIdCopy
    });
  }

  /**
   * Generates a list ID for a given address list.
   *
   * @param {AddressList} addressList - The address list to generate the ID for
   */
  static generateReservedListId = (addressList: iAddressList): string => {
    let listId = '';

    // Logic to determine the listId based on the properties of addressList
    if (addressList.whitelist) {
      if (addressList.addresses.length > 0) {
        const addresses = addressList.addresses.map((x) => (isAddressValid(x) ? convertToCosmosAddress(x) : x)).join(':');
        listId = `${addresses}`;
      } else {
        listId = 'None';
      }
    } else {
      if (addressList.addresses.length > 0) {
        const addresses = addressList.addresses.map((x) => (isAddressValid(x) ? convertToCosmosAddress(x) : x)).join(':');
        listId = `!(${addresses})`;
      } else {
        listId = 'All';
      }
    }

    return listId;
  };

  toProto(): proto.badges.AddressList {
    return new proto.badges.AddressList(this.clone().toJson());
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddressList {
    return AddressList.fromProto(proto.badges.AddressList.fromJson(jsonValue, options));
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddressList {
    return AddressList.fromProto(proto.badges.AddressList.fromJsonString(jsonString, options));
  }

  static fromProto(item: proto.badges.AddressList): AddressList {
    return new AddressList({ ...item });
  }
}

/**
 * {@inheritDoc AddressList.generateReservedListId}
 *
 * @category Address Lists
 *
 */
export const generateReservedListId = AddressList.generateReservedListId;

/**
 * {@inheritDoc AddressList.getReservedAddressList}
 *
 * @category Address Lists
 *
 */
export const getReservedAddressList = AddressList.getReservedAddressList;

/**
 * {@inheritDoc AddressList.getOverlapDetails}
 *
 * @category Address Lists
 *
 */
export const getOverlapDetails = AddressList.getOverlapDetails;

/**
 * {@inheritDoc AddressList.getReservedTrackerList}
 *
 * @category Address Lists
 *
 */
export const getReservedTrackerList = AddressList.getReservedTrackerList;
