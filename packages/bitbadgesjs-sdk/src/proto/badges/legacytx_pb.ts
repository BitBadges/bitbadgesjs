// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file badges/legacytx.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { CollectionApproval, UserIncomingApproval, UserOutgoingApproval } from "./approvals_pb.js";
import { Balance, UintRange } from "./balances_pb.js";
import { CollectionMetadataTimeline, ContractAddressTimeline, CustomDataTimeline, IsArchivedTimeline, ManagerTimeline, StandardsTimeline, TokenMetadataTimeline } from "./timelines_pb.js";
import { CollectionPermissions, UserPermissions } from "./permissions_pb.js";
import { Transfer } from "./transfers_pb.js";
import { AddressList } from "./address_lists_pb.js";
import { AliasPathAddObject, CosmosCoinWrapperPathAddObject, InvariantsAddObject } from "./tx_pb.js";

/**
 * The types defined in these files are used to define the MsgServer types for all requests and responses for Msgs of the tokens module.
 *
 * @generated from message badges.UserOutgoingApprovalTimeline
 */
export class UserOutgoingApprovalTimeline extends Message<UserOutgoingApprovalTimeline> {
  /**
   * @generated from field: repeated badges.UserOutgoingApproval outgoingApprovals = 1;
   */
  outgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * @generated from field: repeated badges.UintRange timelineTimes = 2;
   */
  timelineTimes: UintRange[] = [];

  constructor(data?: PartialMessage<UserOutgoingApprovalTimeline>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserOutgoingApprovalTimeline";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "outgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 2, name: "timelineTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserOutgoingApprovalTimeline {
    return new UserOutgoingApprovalTimeline().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserOutgoingApprovalTimeline {
    return new UserOutgoingApprovalTimeline().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserOutgoingApprovalTimeline {
    return new UserOutgoingApprovalTimeline().fromJsonString(jsonString, options);
  }

  static equals(a: UserOutgoingApprovalTimeline | PlainMessage<UserOutgoingApprovalTimeline> | undefined, b: UserOutgoingApprovalTimeline | PlainMessage<UserOutgoingApprovalTimeline> | undefined): boolean {
    return proto3.util.equals(UserOutgoingApprovalTimeline, a, b);
  }
}

/**
 * @generated from message badges.UserIncomingApprovalTimeline
 */
export class UserIncomingApprovalTimeline extends Message<UserIncomingApprovalTimeline> {
  /**
   * @generated from field: repeated badges.UserIncomingApproval incomingApprovals = 1;
   */
  incomingApprovals: UserIncomingApproval[] = [];

  /**
   * @generated from field: repeated badges.UintRange timelineTimes = 2;
   */
  timelineTimes: UintRange[] = [];

  constructor(data?: PartialMessage<UserIncomingApprovalTimeline>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserIncomingApprovalTimeline";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "incomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 2, name: "timelineTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserIncomingApprovalTimeline {
    return new UserIncomingApprovalTimeline().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserIncomingApprovalTimeline {
    return new UserIncomingApprovalTimeline().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserIncomingApprovalTimeline {
    return new UserIncomingApprovalTimeline().fromJsonString(jsonString, options);
  }

  static equals(a: UserIncomingApprovalTimeline | PlainMessage<UserIncomingApprovalTimeline> | undefined, b: UserIncomingApprovalTimeline | PlainMessage<UserIncomingApprovalTimeline> | undefined): boolean {
    return proto3.util.equals(UserIncomingApprovalTimeline, a, b);
  }
}

/**
 * @generated from message badges.CollectionApprovalTimeline
 */
export class CollectionApprovalTimeline extends Message<CollectionApprovalTimeline> {
  /**
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 1;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * @generated from field: repeated badges.UintRange timelineTimes = 2;
   */
  timelineTimes: UintRange[] = [];

  constructor(data?: PartialMessage<CollectionApprovalTimeline>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionApprovalTimeline";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 2, name: "timelineTimes", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionApprovalTimeline {
    return new CollectionApprovalTimeline().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionApprovalTimeline {
    return new CollectionApprovalTimeline().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionApprovalTimeline {
    return new CollectionApprovalTimeline().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionApprovalTimeline | PlainMessage<CollectionApprovalTimeline> | undefined, b: CollectionApprovalTimeline | PlainMessage<CollectionApprovalTimeline> | undefined): boolean {
    return proto3.util.equals(CollectionApprovalTimeline, a, b);
  }
}

/**
 * @generated from message badges.MsgNewCollection
 */
export class MsgNewCollection extends Message<MsgNewCollection> {
  /**
   * See collections.proto for more details about these MsgNewBadge fields. Defines the token details. Leave unneeded fields empty.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 2;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * @generated from field: repeated badges.TokenMetadataTimeline tokenMetadataTimeline = 3;
   */
  tokenMetadataTimeline: TokenMetadataTimeline[] = [];

  /**
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 4;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 5;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * @generated from field: badges.CollectionPermissions permissions = 6;
   */
  permissions?: CollectionPermissions;

  /**
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 7;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Token supplys and amounts to create. For each idx, we create amounts[idx] badges each with a supply of supplys[idx].
   * If supply[idx] == 0, we assume default supply. amountsToCreate[idx] can't equal 0.
   *
   * @generated from field: repeated badges.Balance tokensToCreate = 8;
   */
  tokensToCreate: Balance[] = [];

  /**
   * @generated from field: repeated badges.Transfer transfers = 9;
   */
  transfers: Transfer[] = [];

  /**
   * @generated from field: repeated badges.ContractAddressTimeline contractAddressTimeline = 10;
   */
  contractAddressTimeline: ContractAddressTimeline[] = [];

  /**
   * @generated from field: repeated badges.AddressList addressLists = 11;
   */
  addressLists: AddressList[] = [];

  /**
   * The user's approved transfers for each token ID.
   *
   * @generated from field: repeated badges.UserOutgoingApproval defaultOutgoingApprovals = 12;
   */
  defaultOutgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * The user's approved incoming transfers for each token ID.
   *
   * @generated from field: repeated badges.UserIncomingApproval defaultIncomingApprovals = 13;
   */
  defaultIncomingApprovals: UserIncomingApproval[] = [];

  /**
   * @generated from field: bool defaultDisapproveSelfInitiated = 14;
   */
  defaultDisapproveSelfInitiated = false;

  /**
   * The default balances for the user
   *
   * @generated from field: repeated badges.Balance defaultBalances = 15;
   */
  defaultBalances: Balance[] = [];

  /**
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 16;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   * These are set upon genesis and cannot be modified.
   * Addresses are generated by the keeper and stored in the collection.
   *
   * @generated from field: badges.InvariantsAddObject invariants = 17;
   */
  invariants?: InvariantsAddObject;

  /**
   * @generated from field: repeated badges.AliasPathAddObject aliasPathsToAdd = 18;
   */
  aliasPathsToAdd: AliasPathAddObject[] = [];

  constructor(data?: PartialMessage<MsgNewCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgNewCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 3, name: "tokenMetadataTimeline", kind: "message", T: TokenMetadataTimeline, repeated: true },
    { no: 4, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 5, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 6, name: "permissions", kind: "message", T: CollectionPermissions },
    { no: 7, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 8, name: "tokensToCreate", kind: "message", T: Balance, repeated: true },
    { no: 9, name: "transfers", kind: "message", T: Transfer, repeated: true },
    { no: 10, name: "contractAddressTimeline", kind: "message", T: ContractAddressTimeline, repeated: true },
    { no: 11, name: "addressLists", kind: "message", T: AddressList, repeated: true },
    { no: 12, name: "defaultOutgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 13, name: "defaultIncomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 14, name: "defaultDisapproveSelfInitiated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "defaultBalances", kind: "message", T: Balance, repeated: true },
    { no: 16, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
    { no: 17, name: "invariants", kind: "message", T: InvariantsAddObject },
    { no: 18, name: "aliasPathsToAdd", kind: "message", T: AliasPathAddObject, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgNewCollection {
    return new MsgNewCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgNewCollection {
    return new MsgNewCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgNewCollection {
    return new MsgNewCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgNewCollection | PlainMessage<MsgNewCollection> | undefined, b: MsgNewCollection | PlainMessage<MsgNewCollection> | undefined): boolean {
    return proto3.util.equals(MsgNewCollection, a, b);
  }
}

/**
 * @generated from message badges.MsgNewCollectionResponse
 */
export class MsgNewCollectionResponse extends Message<MsgNewCollectionResponse> {
  /**
   * ID of created badge collecon
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgNewCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgNewCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgNewCollectionResponse {
    return new MsgNewCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgNewCollectionResponse {
    return new MsgNewCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgNewCollectionResponse {
    return new MsgNewCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgNewCollectionResponse | PlainMessage<MsgNewCollectionResponse> | undefined, b: MsgNewCollectionResponse | PlainMessage<MsgNewCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgNewCollectionResponse, a, b);
  }
}

/**
 * This handles both minting more of existing badges and creating new tokens.
 *
 * @generated from message badges.MsgMintAndDistributeTokens
 */
export class MsgMintAndDistributeTokens extends Message<MsgMintAndDistributeTokens> {
  /**
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * @generated from field: repeated badges.Balance tokensToCreate = 3;
   */
  tokensToCreate: Balance[] = [];

  /**
   * @generated from field: repeated badges.Transfer transfers = 4;
   */
  transfers: Transfer[] = [];

  /**
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 5;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * @generated from field: repeated badges.TokenMetadataTimeline tokenMetadataTimeline = 6;
   */
  tokenMetadataTimeline: TokenMetadataTimeline[] = [];

  /**
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 7;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * @generated from field: repeated badges.AddressList addressLists = 8;
   */
  addressLists: AddressList[] = [];

  constructor(data?: PartialMessage<MsgMintAndDistributeTokens>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgMintAndDistributeTokens";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "tokensToCreate", kind: "message", T: Balance, repeated: true },
    { no: 4, name: "transfers", kind: "message", T: Transfer, repeated: true },
    { no: 5, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 6, name: "tokenMetadataTimeline", kind: "message", T: TokenMetadataTimeline, repeated: true },
    { no: 7, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 8, name: "addressLists", kind: "message", T: AddressList, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgMintAndDistributeTokens {
    return new MsgMintAndDistributeTokens().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgMintAndDistributeTokens {
    return new MsgMintAndDistributeTokens().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgMintAndDistributeTokens {
    return new MsgMintAndDistributeTokens().fromJsonString(jsonString, options);
  }

  static equals(a: MsgMintAndDistributeTokens | PlainMessage<MsgMintAndDistributeTokens> | undefined, b: MsgMintAndDistributeTokens | PlainMessage<MsgMintAndDistributeTokens> | undefined): boolean {
    return proto3.util.equals(MsgMintAndDistributeTokens, a, b);
  }
}

/**
 * @generated from message badges.MsgMintAndDistributeTokensResponse
 */
export class MsgMintAndDistributeTokensResponse extends Message<MsgMintAndDistributeTokensResponse> {
  constructor(data?: PartialMessage<MsgMintAndDistributeTokensResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgMintAndDistributeTokensResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgMintAndDistributeTokensResponse {
    return new MsgMintAndDistributeTokensResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgMintAndDistributeTokensResponse {
    return new MsgMintAndDistributeTokensResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgMintAndDistributeTokensResponse {
    return new MsgMintAndDistributeTokensResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgMintAndDistributeTokensResponse | PlainMessage<MsgMintAndDistributeTokensResponse> | undefined, b: MsgMintAndDistributeTokensResponse | PlainMessage<MsgMintAndDistributeTokensResponse> | undefined): boolean {
    return proto3.util.equals(MsgMintAndDistributeTokensResponse, a, b);
  }
}

/**
 * @generated from message badges.MsgUniversalUpdateCollectionApprovals
 */
export class MsgUniversalUpdateCollectionApprovals extends Message<MsgUniversalUpdateCollectionApprovals> {
  /**
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 3;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * @generated from field: repeated badges.AddressList addressLists = 4;
   */
  addressLists: AddressList[] = [];

  constructor(data?: PartialMessage<MsgUniversalUpdateCollectionApprovals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollectionApprovals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 4, name: "addressLists", kind: "message", T: AddressList, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollectionApprovals {
    return new MsgUniversalUpdateCollectionApprovals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionApprovals {
    return new MsgUniversalUpdateCollectionApprovals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionApprovals {
    return new MsgUniversalUpdateCollectionApprovals().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollectionApprovals | PlainMessage<MsgUniversalUpdateCollectionApprovals> | undefined, b: MsgUniversalUpdateCollectionApprovals | PlainMessage<MsgUniversalUpdateCollectionApprovals> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollectionApprovals, a, b);
  }
}

/**
 * @generated from message badges.MsgUniversalUpdateCollectionApprovalsResponse
 */
export class MsgUniversalUpdateCollectionApprovalsResponse extends Message<MsgUniversalUpdateCollectionApprovalsResponse> {
  constructor(data?: PartialMessage<MsgUniversalUpdateCollectionApprovalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollectionApprovalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollectionApprovalsResponse {
    return new MsgUniversalUpdateCollectionApprovalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionApprovalsResponse {
    return new MsgUniversalUpdateCollectionApprovalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionApprovalsResponse {
    return new MsgUniversalUpdateCollectionApprovalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollectionApprovalsResponse | PlainMessage<MsgUniversalUpdateCollectionApprovalsResponse> | undefined, b: MsgUniversalUpdateCollectionApprovalsResponse | PlainMessage<MsgUniversalUpdateCollectionApprovalsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollectionApprovalsResponse, a, b);
  }
}

/**
 * Update badge Uris with new URI object, if permitted.
 *
 * @generated from message badges.MsgUpdateMetadata
 */
export class MsgUpdateMetadata extends Message<MsgUpdateMetadata> {
  /**
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 3;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * @generated from field: repeated badges.TokenMetadataTimeline tokenMetadataTimeline = 4;
   */
  tokenMetadataTimeline: TokenMetadataTimeline[] = [];

  /**
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 5;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * @generated from field: repeated badges.ContractAddressTimeline contractAddressTimeline = 6;
   */
  contractAddressTimeline: ContractAddressTimeline[] = [];

  /**
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 7;
   */
  standardsTimeline: StandardsTimeline[] = [];

  constructor(data?: PartialMessage<MsgUpdateMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 4, name: "tokenMetadataTimeline", kind: "message", T: TokenMetadataTimeline, repeated: true },
    { no: 5, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 6, name: "contractAddressTimeline", kind: "message", T: ContractAddressTimeline, repeated: true },
    { no: 7, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateMetadata {
    return new MsgUpdateMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateMetadata {
    return new MsgUpdateMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateMetadata {
    return new MsgUpdateMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateMetadata | PlainMessage<MsgUpdateMetadata> | undefined, b: MsgUpdateMetadata | PlainMessage<MsgUpdateMetadata> | undefined): boolean {
    return proto3.util.equals(MsgUpdateMetadata, a, b);
  }
}

/**
 * @generated from message badges.MsgUpdateMetadataResponse
 */
export class MsgUpdateMetadataResponse extends Message<MsgUpdateMetadataResponse> {
  constructor(data?: PartialMessage<MsgUpdateMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateMetadataResponse {
    return new MsgUpdateMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateMetadataResponse {
    return new MsgUpdateMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateMetadataResponse {
    return new MsgUpdateMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateMetadataResponse | PlainMessage<MsgUpdateMetadataResponse> | undefined, b: MsgUpdateMetadataResponse | PlainMessage<MsgUpdateMetadataResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateMetadataResponse, a, b);
  }
}

/**
 * Update badge permissions with new permissions, if permitted.
 *
 * @generated from message badges.MsgUniversalUpdateCollectionPermissions
 */
export class MsgUniversalUpdateCollectionPermissions extends Message<MsgUniversalUpdateCollectionPermissions> {
  /**
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * @generated from field: badges.CollectionPermissions permissions = 3;
   */
  permissions?: CollectionPermissions;

  /**
   * @generated from field: repeated badges.AddressList addressLists = 4;
   */
  addressLists: AddressList[] = [];

  constructor(data?: PartialMessage<MsgUniversalUpdateCollectionPermissions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollectionPermissions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "permissions", kind: "message", T: CollectionPermissions },
    { no: 4, name: "addressLists", kind: "message", T: AddressList, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollectionPermissions {
    return new MsgUniversalUpdateCollectionPermissions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionPermissions {
    return new MsgUniversalUpdateCollectionPermissions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionPermissions {
    return new MsgUniversalUpdateCollectionPermissions().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollectionPermissions | PlainMessage<MsgUniversalUpdateCollectionPermissions> | undefined, b: MsgUniversalUpdateCollectionPermissions | PlainMessage<MsgUniversalUpdateCollectionPermissions> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollectionPermissions, a, b);
  }
}

/**
 * @generated from message badges.MsgUniversalUpdateCollectionPermissionsResponse
 */
export class MsgUniversalUpdateCollectionPermissionsResponse extends Message<MsgUniversalUpdateCollectionPermissionsResponse> {
  constructor(data?: PartialMessage<MsgUniversalUpdateCollectionPermissionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollectionPermissionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollectionPermissionsResponse {
    return new MsgUniversalUpdateCollectionPermissionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionPermissionsResponse {
    return new MsgUniversalUpdateCollectionPermissionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionPermissionsResponse {
    return new MsgUniversalUpdateCollectionPermissionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollectionPermissionsResponse | PlainMessage<MsgUniversalUpdateCollectionPermissionsResponse> | undefined, b: MsgUniversalUpdateCollectionPermissionsResponse | PlainMessage<MsgUniversalUpdateCollectionPermissionsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollectionPermissionsResponse, a, b);
  }
}

/**
 * @generated from message badges.MsgUpdateUserPermissions
 */
export class MsgUpdateUserPermissions extends Message<MsgUpdateUserPermissions> {
  /**
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * @generated from field: badges.UserPermissions permissions = 3;
   */
  permissions?: UserPermissions;

  /**
   * @generated from field: repeated badges.AddressList addressLists = 4;
   */
  addressLists: AddressList[] = [];

  constructor(data?: PartialMessage<MsgUpdateUserPermissions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserPermissions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "permissions", kind: "message", T: UserPermissions },
    { no: 4, name: "addressLists", kind: "message", T: AddressList, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserPermissions {
    return new MsgUpdateUserPermissions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserPermissions {
    return new MsgUpdateUserPermissions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserPermissions {
    return new MsgUpdateUserPermissions().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserPermissions | PlainMessage<MsgUpdateUserPermissions> | undefined, b: MsgUpdateUserPermissions | PlainMessage<MsgUpdateUserPermissions> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserPermissions, a, b);
  }
}

/**
 * @generated from message badges.MsgUpdateUserPermissionsResponse
 */
export class MsgUpdateUserPermissionsResponse extends Message<MsgUpdateUserPermissionsResponse> {
  constructor(data?: PartialMessage<MsgUpdateUserPermissionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserPermissionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserPermissionsResponse {
    return new MsgUpdateUserPermissionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserPermissionsResponse {
    return new MsgUpdateUserPermissionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserPermissionsResponse {
    return new MsgUpdateUserPermissionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserPermissionsResponse | PlainMessage<MsgUpdateUserPermissionsResponse> | undefined, b: MsgUpdateUserPermissionsResponse | PlainMessage<MsgUpdateUserPermissionsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserPermissionsResponse, a, b);
  }
}

/**
 * Transfer manager to this address. Recipient must have made a request.
 *
 * @generated from message badges.MsgUpdateManager
 */
export class MsgUpdateManager extends Message<MsgUpdateManager> {
  /**
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 3;
   */
  managerTimeline: ManagerTimeline[] = [];

  constructor(data?: PartialMessage<MsgUpdateManager>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateManager";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateManager {
    return new MsgUpdateManager().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateManager {
    return new MsgUpdateManager().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateManager {
    return new MsgUpdateManager().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateManager | PlainMessage<MsgUpdateManager> | undefined, b: MsgUpdateManager | PlainMessage<MsgUpdateManager> | undefined): boolean {
    return proto3.util.equals(MsgUpdateManager, a, b);
  }
}

/**
 * @generated from message badges.MsgUpdateManagerResponse
 */
export class MsgUpdateManagerResponse extends Message<MsgUpdateManagerResponse> {
  constructor(data?: PartialMessage<MsgUpdateManagerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateManagerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateManagerResponse {
    return new MsgUpdateManagerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateManagerResponse {
    return new MsgUpdateManagerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateManagerResponse {
    return new MsgUpdateManagerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateManagerResponse | PlainMessage<MsgUpdateManagerResponse> | undefined, b: MsgUpdateManagerResponse | PlainMessage<MsgUpdateManagerResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateManagerResponse, a, b);
  }
}

/**
 * @generated from message badges.MsgArchiveCollection
 */
export class MsgArchiveCollection extends Message<MsgArchiveCollection> {
  /**
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 3;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  constructor(data?: PartialMessage<MsgArchiveCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgArchiveCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgArchiveCollection {
    return new MsgArchiveCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgArchiveCollection {
    return new MsgArchiveCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgArchiveCollection {
    return new MsgArchiveCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgArchiveCollection | PlainMessage<MsgArchiveCollection> | undefined, b: MsgArchiveCollection | PlainMessage<MsgArchiveCollection> | undefined): boolean {
    return proto3.util.equals(MsgArchiveCollection, a, b);
  }
}

/**
 * @generated from message badges.MsgArchiveCollectionResponse
 */
export class MsgArchiveCollectionResponse extends Message<MsgArchiveCollectionResponse> {
  constructor(data?: PartialMessage<MsgArchiveCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgArchiveCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgArchiveCollectionResponse {
    return new MsgArchiveCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgArchiveCollectionResponse {
    return new MsgArchiveCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgArchiveCollectionResponse {
    return new MsgArchiveCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgArchiveCollectionResponse | PlainMessage<MsgArchiveCollectionResponse> | undefined, b: MsgArchiveCollectionResponse | PlainMessage<MsgArchiveCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgArchiveCollectionResponse, a, b);
  }
}

