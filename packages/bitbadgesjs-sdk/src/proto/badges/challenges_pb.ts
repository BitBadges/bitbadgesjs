// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file badges/challenges.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 *
 * Challenges define a rule for the approval in the form of a Merkle challenge.
 *
 * A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
 * then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.
 *
 * IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.
 *
 * IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
 * If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
 * We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
 *
 * @generated from message badges.MerkleChallenge
 */
export class MerkleChallenge extends Message<MerkleChallenge> {
  /**
   * The root hash of the Merkle tree to which the Merkle path must lead for verification.
   *
   * @generated from field: string root = 1;
   */
  root = "";

  /**
   * The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
   *
   * @generated from field: string expectedProofLength = 2;
   */
  expectedProofLength = "";

  /**
   * If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.
   *
   * @generated from field: bool useCreatorAddressAsLeaf = 3;
   */
  useCreatorAddressAsLeaf = false;

  /**
   * The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
   *
   * @generated from field: string maxUsesPerLeaf = 4;
   */
  maxUsesPerLeaf = "";

  /**
   * The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
   *
   * @generated from field: string uri = 5;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this Merkle challenge.
   *
   * @generated from field: string customData = 6;
   */
  customData = "";

  /**
   * The ID of this Merkle challenge for tracking the number of uses per leaf.
   *
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * Ethereum address that must sign the leaf. Used to protect against man-in-the-middle attacks.
   * Signature scheme: sign(leaf + "-" + creatorAddress), verified using elliptic curve signature verification.
   *
   * @generated from field: string leafSigner = 8;
   */
  leafSigner = "";

  constructor(data?: PartialMessage<MerkleChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expectedProofLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "useCreatorAddressAsLeaf", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "maxUsesPerLeaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "leafSigner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined, b: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined): boolean {
    return proto3.util.equals(MerkleChallenge, a, b);
  }
}

/**
 *
 * ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.
 *
 * An ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.
 * The signature scheme is ETHSign(nonce + "-" + creatorAddress) and each signature can only be used once.
 * All challenges must be met with valid solutions for the transfer to be approved.
 *
 * IMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.
 * If you update the challenge ID, then the used signatures tracker will reset and start a new tally.
 * We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
 *
 * @generated from message badges.ETHSignatureChallenge
 */
export class ETHSignatureChallenge extends Message<ETHSignatureChallenge> {
  /**
   * The Ethereum address that must sign the nonce for verification.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * The ID of this ETH signature challenge for tracking the number of uses per signature.
   *
   * @generated from field: string challengeTrackerId = 2;
   */
  challengeTrackerId = "";

  /**
   * The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.
   *
   * @generated from field: string uri = 3;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this ETH signature challenge.
   *
   * @generated from field: string customData = 4;
   */
  customData = "";

  constructor(data?: PartialMessage<ETHSignatureChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ETHSignatureChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ETHSignatureChallenge {
    return new ETHSignatureChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ETHSignatureChallenge {
    return new ETHSignatureChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ETHSignatureChallenge {
    return new ETHSignatureChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: ETHSignatureChallenge | PlainMessage<ETHSignatureChallenge> | undefined, b: ETHSignatureChallenge | PlainMessage<ETHSignatureChallenge> | undefined): boolean {
    return proto3.util.equals(ETHSignatureChallenge, a, b);
  }
}

/**
 * MerklePathItem represents an item in a Merkle path.
 *
 * @generated from message badges.MerklePathItem
 */
export class MerklePathItem extends Message<MerklePathItem> {
  /**
   * The hash of the sibling node (aunt) in the Merkle path.
   *
   * @generated from field: string aunt = 1;
   */
  aunt = "";

  /**
   * Indicates whether the aunt node is on the right side of the path.
   *
   * @generated from field: bool onRight = 2;
   */
  onRight = false;

  constructor(data?: PartialMessage<MerklePathItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerklePathItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aunt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "onRight", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerklePathItem {
    return new MerklePathItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJsonString(jsonString, options);
  }

  static equals(a: MerklePathItem | PlainMessage<MerklePathItem> | undefined, b: MerklePathItem | PlainMessage<MerklePathItem> | undefined): boolean {
    return proto3.util.equals(MerklePathItem, a, b);
  }
}

/**
 * MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
 *
 * @generated from message badges.MerkleProof
 */
export class MerkleProof extends Message<MerkleProof> {
  /**
   * The hash of the leaf node for which the proof is generated.
   *
   * @generated from field: string leaf = 1;
   */
  leaf = "";

  /**
   * List of Merkle path items (aunts) that make up the proof.
   *
   * @generated from field: repeated badges.MerklePathItem aunts = 2;
   */
  aunts: MerklePathItem[] = [];

  /**
   * The signature of the leaf node tying the address to the leaf node.
   *
   * @generated from field: string leafSignature = 3;
   */
  leafSignature = "";

  constructor(data?: PartialMessage<MerkleProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "leaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "aunts", kind: "message", T: MerklePathItem, repeated: true },
    { no: 3, name: "leafSignature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleProof {
    return new MerkleProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleProof | PlainMessage<MerkleProof> | undefined, b: MerkleProof | PlainMessage<MerkleProof> | undefined): boolean {
    return proto3.util.equals(MerkleProof, a, b);
  }
}

/**
 * ETHSignatureProof represents an Ethereum signature proof for a challenge.
 *
 * @generated from message badges.ETHSignatureProof
 */
export class ETHSignatureProof extends Message<ETHSignatureProof> {
  /**
   * The nonce that was signed. The signature scheme is ETHSign(nonce + "-" + creatorAddress).
   *
   * @generated from field: string nonce = 1;
   */
  nonce = "";

  /**
   * The Ethereum signature of the nonce.
   *
   * @generated from field: string signature = 2;
   */
  signature = "";

  constructor(data?: PartialMessage<ETHSignatureProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ETHSignatureProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ETHSignatureProof {
    return new ETHSignatureProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ETHSignatureProof {
    return new ETHSignatureProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ETHSignatureProof {
    return new ETHSignatureProof().fromJsonString(jsonString, options);
  }

  static equals(a: ETHSignatureProof | PlainMessage<ETHSignatureProof> | undefined, b: ETHSignatureProof | PlainMessage<ETHSignatureProof> | undefined): boolean {
    return proto3.util.equals(ETHSignatureProof, a, b);
  }
}

