// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file badges/challenges.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 *
 * Challenges define a rule for the approval in the form of a Merkle challenge.
 *
 * A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
 * then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.
 *
 * IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.
 *
 * IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
 * If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
 * We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
 *
 * @generated from message badges.MerkleChallenge
 */
export class MerkleChallenge extends Message<MerkleChallenge> {
  /**
   * The root hash of the Merkle tree to which the Merkle path must lead for verification.
   *
   * @generated from field: string root = 1;
   */
  root = "";

  /**
   * The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
   *
   * @generated from field: string expectedProofLength = 2;
   */
  expectedProofLength = "";

  /**
   * If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.
   *
   * @generated from field: bool useCreatorAddressAsLeaf = 3;
   */
  useCreatorAddressAsLeaf = false;

  /**
   * The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
   *
   * @generated from field: string maxUsesPerLeaf = 4;
   */
  maxUsesPerLeaf = "";

  /**
   * The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
   *
   * @generated from field: string uri = 5;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this Merkle challenge.
   *
   * @generated from field: string customData = 6;
   */
  customData = "";

  /**
   * The ID of this Merkle challenge for tracking the number of uses per leaf.
   *
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * Ethereum address that must sign the leaf. Used to protect against man-in-the-middle attacks.
   * Signature scheme: sign(leaf + "-" + creatorAddress), verified using elliptic curve signature verification.
   *
   * @generated from field: string leafSigner = 8;
   */
  leafSigner = "";

  constructor(data?: PartialMessage<MerkleChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expectedProofLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "useCreatorAddressAsLeaf", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "maxUsesPerLeaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "leafSigner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined, b: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined): boolean {
    return proto3.util.equals(MerkleChallenge, a, b);
  }
}

/**
 *
 * ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.
 *
 * An ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.
 * The signature scheme is ETHSign(nonce + "-" + initiatorAddress + "-" + collectionId + "-" + approverAddress + "-" + approvalLevel + "-" + approvalId + "-" + challengeId) and each signature can only be used once.
 * All challenges must be met with valid solutions for the transfer to be approved.
 *
 * IMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.
 * If you update the challenge ID, then the used signatures tracker will reset and start a new tally.
 * We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
 *
 * @generated from message badges.ETHSignatureChallenge
 */
export class ETHSignatureChallenge extends Message<ETHSignatureChallenge> {
  /**
   * The Ethereum address that must sign the nonce for verification.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * The ID of this ETH signature challenge for tracking the number of uses per signature.
   *
   * @generated from field: string challengeTrackerId = 2;
   */
  challengeTrackerId = "";

  /**
   * The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.
   *
   * @generated from field: string uri = 3;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this ETH signature challenge.
   *
   * @generated from field: string customData = 4;
   */
  customData = "";

  constructor(data?: PartialMessage<ETHSignatureChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ETHSignatureChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ETHSignatureChallenge {
    return new ETHSignatureChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ETHSignatureChallenge {
    return new ETHSignatureChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ETHSignatureChallenge {
    return new ETHSignatureChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: ETHSignatureChallenge | PlainMessage<ETHSignatureChallenge> | undefined, b: ETHSignatureChallenge | PlainMessage<ETHSignatureChallenge> | undefined): boolean {
    return proto3.util.equals(ETHSignatureChallenge, a, b);
  }
}

/**
 * MerklePathItem represents an item in a Merkle path.
 *
 * @generated from message badges.MerklePathItem
 */
export class MerklePathItem extends Message<MerklePathItem> {
  /**
   * The hash of the sibling node (aunt) in the Merkle path.
   *
   * @generated from field: string aunt = 1;
   */
  aunt = "";

  /**
   * Indicates whether the aunt node is on the right side of the path.
   *
   * @generated from field: bool onRight = 2;
   */
  onRight = false;

  constructor(data?: PartialMessage<MerklePathItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerklePathItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aunt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "onRight", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerklePathItem {
    return new MerklePathItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJsonString(jsonString, options);
  }

  static equals(a: MerklePathItem | PlainMessage<MerklePathItem> | undefined, b: MerklePathItem | PlainMessage<MerklePathItem> | undefined): boolean {
    return proto3.util.equals(MerklePathItem, a, b);
  }
}

/**
 * MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
 *
 * @generated from message badges.MerkleProof
 */
export class MerkleProof extends Message<MerkleProof> {
  /**
   * The hash of the leaf node for which the proof is generated.
   *
   * @generated from field: string leaf = 1;
   */
  leaf = "";

  /**
   * List of Merkle path items (aunts) that make up the proof.
   *
   * @generated from field: repeated badges.MerklePathItem aunts = 2;
   */
  aunts: MerklePathItem[] = [];

  /**
   * The signature of the leaf node tying the address to the leaf node.
   *
   * @generated from field: string leafSignature = 3;
   */
  leafSignature = "";

  constructor(data?: PartialMessage<MerkleProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "leaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "aunts", kind: "message", T: MerklePathItem, repeated: true },
    { no: 3, name: "leafSignature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleProof {
    return new MerkleProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleProof | PlainMessage<MerkleProof> | undefined, b: MerkleProof | PlainMessage<MerkleProof> | undefined): boolean {
    return proto3.util.equals(MerkleProof, a, b);
  }
}

/**
 * ETHSignatureProof represents an Ethereum signature proof for a challenge.
 *
 * @generated from message badges.ETHSignatureProof
 */
export class ETHSignatureProof extends Message<ETHSignatureProof> {
  /**
   * The nonce that was signed. The signature scheme is ETHSign(nonce + "-" + initiatorAddress + "-" + collectionId + "-" + approverAddress + "-" + approvalLevel + "-" + approvalId + "-" + challengeId).
   *
   * @generated from field: string nonce = 1;
   */
  nonce = "";

  /**
   * The Ethereum signature of the nonce.
   *
   * @generated from field: string signature = 2;
   */
  signature = "";

  constructor(data?: PartialMessage<ETHSignatureProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ETHSignatureProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ETHSignatureProof {
    return new ETHSignatureProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ETHSignatureProof {
    return new ETHSignatureProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ETHSignatureProof {
    return new ETHSignatureProof().fromJsonString(jsonString, options);
  }

  static equals(a: ETHSignatureProof | PlainMessage<ETHSignatureProof> | undefined, b: ETHSignatureProof | PlainMessage<ETHSignatureProof> | undefined): boolean {
    return proto3.util.equals(ETHSignatureProof, a, b);
  }
}

/**
 *
 * VotingChallenge defines a rule for approval in the form of a voting/multi-sig challenge.
 * Requires a weighted quorum threshold to be met through votes from specified voters.
 * All challenges must be met with valid solutions for the transfer to be approved.
 *
 * IMPORTANT: Votes are stored separately and can be updated. The threshold is calculated as a percentage
 * of total possible weight (all voters), not just voted weight. If you update the proposal ID, then the
 * vote tracker will reset and start a new tally. We recommend using a unique proposal ID for each challenge
 * to prevent overlap and unexpected behavior.
 *
 * @generated from message badges.VotingChallenge
 */
export class VotingChallenge extends Message<VotingChallenge> {
  /**
   * The ID of this voting challenge for tracking votes (scoped like challengeTrackerId).
   * Format: collectionId-approverAddress-approvalLevel-approvalId-challengeId
   *
   * @generated from field: string proposalId = 1;
   */
  proposalId = "";

  /**
   * The quorum threshold as a percentage (0-100) of total possible weight that must vote "yes".
   * Example: 50 means 50% of total voter weight must vote yes for approval.
   *
   * @generated from field: string quorumThreshold = 2;
   */
  quorumThreshold = "";

  /**
   * List of voters with their weights. Each voter can cast a weighted vote.
   *
   * @generated from field: repeated badges.Voter voters = 3;
   */
  voters: Voter[] = [];

  /**
   * The URI associated with this voting challenge.
   *
   * @generated from field: string uri = 4;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this voting challenge.
   *
   * @generated from field: string customData = 5;
   */
  customData = "";

  constructor(data?: PartialMessage<VotingChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.VotingChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quorumThreshold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "voters", kind: "message", T: Voter, repeated: true },
    { no: 4, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VotingChallenge {
    return new VotingChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VotingChallenge {
    return new VotingChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VotingChallenge {
    return new VotingChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: VotingChallenge | PlainMessage<VotingChallenge> | undefined, b: VotingChallenge | PlainMessage<VotingChallenge> | undefined): boolean {
    return proto3.util.equals(VotingChallenge, a, b);
  }
}

/**
 * Voter defines a voter with their address and weight.
 *
 * @generated from message badges.Voter
 */
export class Voter extends Message<Voter> {
  /**
   * The address of the voter.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * The weight of this voter's vote.
   *
   * @generated from field: string weight = 2;
   */
  weight = "";

  constructor(data?: PartialMessage<Voter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.Voter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Voter {
    return new Voter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Voter {
    return new Voter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Voter {
    return new Voter().fromJsonString(jsonString, options);
  }

  static equals(a: Voter | PlainMessage<Voter> | undefined, b: Voter | PlainMessage<Voter> | undefined): boolean {
    return proto3.util.equals(Voter, a, b);
  }
}

/**
 * VoteProof represents a vote cast for a voting challenge.
 *
 * @generated from message badges.VoteProof
 */
export class VoteProof extends Message<VoteProof> {
  /**
   * The proposal ID this vote is for.
   *
   * @generated from field: string proposalId = 1;
   */
  proposalId = "";

  /**
   * The address of the voter casting the vote.
   *
   * @generated from field: string voter = 2;
   */
  voter = "";

  /**
   * The percentage weight (0-100) allocated to "yes" vote.
   * The remaining percentage (100 - yesWeight) is allocated to "no" vote.
   * Example: yesWeight=70 means 70% yes, 30% no.
   *
   * @generated from field: string yesWeight = 3;
   */
  yesWeight = "";

  constructor(data?: PartialMessage<VoteProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.VoteProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "voter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "yesWeight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoteProof {
    return new VoteProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoteProof {
    return new VoteProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoteProof {
    return new VoteProof().fromJsonString(jsonString, options);
  }

  static equals(a: VoteProof | PlainMessage<VoteProof> | undefined, b: VoteProof | PlainMessage<VoteProof> | undefined): boolean {
    return proto3.util.equals(VoteProof, a, b);
  }
}

