// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file badges/collections.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { BadgeMetadataTimeline, CollectionMetadataTimeline, CustomDataTimeline, IsArchivedTimeline, ManagerTimeline, OffChainBalancesMetadataTimeline, StandardsTimeline } from "./timelines_pb.js";
import { CollectionPermissions } from "./permissions_pb.js";
import { CollectionApproval, UserBalanceStore } from "./transfers_pb.js";
import { Balance, UintRange } from "./balances_pb.js";

/**
 *
 * A BadgeCollection is the top-level object for a collection of tokens. 
 * It defines everything about the collection, such as the manager, metadata, etc.
 *
 * All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).
 *
 * All collections can have a manager who is responsible for managing the collection and can be granted certain admin
 * permissions, such as the ability to mint new tokens.
 *
 * Certain fields are timeline-based, which means they may have different values at different block heights. 
 * We fetch the value according to the current time.
 * For example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.
 *
 * Collections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.
 *
 * See documentation for more details.
 *
 * @generated from message badges.BadgeCollection
 */
export class BadgeCollection extends Message<BadgeCollection> {
  /**
   * The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  /**
   * The metadata for the collection itself, which can vary over time.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 2;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * The metadata for each token in the collection, also subject to changes over time.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 3;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * The type of balances this collection uses ("Standard", "Off-Chain - Indexed", "Off-Chain - Non-Indexed", or "Non-Public").
   *
   * @generated from field: string balancesType = 4;
   */
  balancesType = "";

  /**
   * Metadata for fetching balances for collections with off-chain balances, subject to changes over time.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 5;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * An arbitrary field that can store any data, subject to changes over time.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 7;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * The address of the manager of this collection, subject to changes over time.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 8;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Permissions that define what the manager of the collection can do or not do.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 9;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Transferability of the collection for collections with standard balances, subject to changes over time.
   * Overrides user approvals for a transfer if specified.
   * Transfer must satisfy both user and collection-level approvals.
   * Only applicable to on-chain balances.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 10;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards that define how to interpret the fields of the collection, subject to changes over time.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 11;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Whether the collection is archived or not, subject to changes over time.
   * When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 12;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * The default store of a balance for a user, upon genesis.
   *
   * @generated from field: badges.UserBalanceStore defaultBalances = 13;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * The user or entity who created the collection.
   *
   * @generated from field: string createdBy = 14;
   */
  createdBy = "";

  /**
   * The valid token IDs for this collection.
   *
   * @generated from field: repeated badges.UintRange validBadgeIds = 15;
   */
  validBadgeIds: UintRange[] = [];

  /**
   * The generated address of the collection. Also used to escrow Mint balances.
   *
   * @generated from field: string mintEscrowAddress = 16;
   */
  mintEscrowAddress = "";

  /**
   * The IBC wrapper (sdk.coin) paths for the collection.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPath cosmosCoinWrapperPaths = 17;
   */
  cosmosCoinWrapperPaths: CosmosCoinWrapperPath[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   * These are set upon genesis and cannot be modified.
   *
   * @generated from field: badges.CollectionInvariants invariants = 18;
   */
  invariants?: CollectionInvariants;

  constructor(data?: PartialMessage<BadgeCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BadgeCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 3, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 4, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 7, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 8, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 9, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 10, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 11, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 12, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 13, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 14, name: "createdBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "validBadgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 16, name: "mintEscrowAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "cosmosCoinWrapperPaths", kind: "message", T: CosmosCoinWrapperPath, repeated: true },
    { no: 18, name: "invariants", kind: "message", T: CollectionInvariants },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadgeCollection {
    return new BadgeCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadgeCollection {
    return new BadgeCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadgeCollection {
    return new BadgeCollection().fromJsonString(jsonString, options);
  }

  static equals(a: BadgeCollection | PlainMessage<BadgeCollection> | undefined, b: BadgeCollection | PlainMessage<BadgeCollection> | undefined): boolean {
    return proto3.util.equals(BadgeCollection, a, b);
  }
}

/**
 * @generated from message badges.CosmosCoinWrapperPath
 */
export class CosmosCoinWrapperPath extends Message<CosmosCoinWrapperPath> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * @generated from field: repeated badges.Balance balances = 3;
   */
  balances: Balance[] = [];

  /**
   * @generated from field: string symbol = 4;
   */
  symbol = "";

  /**
   * @generated from field: repeated badges.DenomUnit denomUnits = 5;
   */
  denomUnits: DenomUnit[] = [];

  /**
   * @generated from field: bool allowOverrideWithAnyValidToken = 6;
   */
  allowOverrideWithAnyValidToken = false;

  constructor(data?: PartialMessage<CosmosCoinWrapperPath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CosmosCoinWrapperPath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 4, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "denomUnits", kind: "message", T: DenomUnit, repeated: true },
    { no: 6, name: "allowOverrideWithAnyValidToken", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CosmosCoinWrapperPath {
    return new CosmosCoinWrapperPath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPath {
    return new CosmosCoinWrapperPath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPath {
    return new CosmosCoinWrapperPath().fromJsonString(jsonString, options);
  }

  static equals(a: CosmosCoinWrapperPath | PlainMessage<CosmosCoinWrapperPath> | undefined, b: CosmosCoinWrapperPath | PlainMessage<CosmosCoinWrapperPath> | undefined): boolean {
    return proto3.util.equals(CosmosCoinWrapperPath, a, b);
  }
}

/**
 * @generated from message badges.DenomUnit
 */
export class DenomUnit extends Message<DenomUnit> {
  /**
   * @generated from field: string decimals = 1;
   */
  decimals = "";

  /**
   * @generated from field: string symbol = 2;
   */
  symbol = "";

  /**
   * @generated from field: bool isDefaultDisplay = 3;
   */
  isDefaultDisplay = false;

  constructor(data?: PartialMessage<DenomUnit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.DenomUnit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "decimals", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isDefaultDisplay", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenomUnit {
    return new DenomUnit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenomUnit {
    return new DenomUnit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenomUnit {
    return new DenomUnit().fromJsonString(jsonString, options);
  }

  static equals(a: DenomUnit | PlainMessage<DenomUnit> | undefined, b: DenomUnit | PlainMessage<DenomUnit> | undefined): boolean {
    return proto3.util.equals(DenomUnit, a, b);
  }
}

/**
 * CollectionInvariants defines the invariants that apply to a collection.
 *
 * @generated from message badges.CollectionInvariants
 */
export class CollectionInvariants extends Message<CollectionInvariants> {
  /**
   * If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
   * This prevents time-based restrictions on token ownership.
   *
   * @generated from field: bool noCustomOwnershipTimes = 1;
   */
  noCustomOwnershipTimes = false;

  /**
   * Maximum supply per token ID. If set, no balance can exceed this amount.
   * This prevents any single token ID from having more than the specified supply.
   *
   * @generated from field: string maxSupplyPerId = 2;
   */
  maxSupplyPerId = "";

  constructor(data?: PartialMessage<CollectionInvariants>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionInvariants";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "noCustomOwnershipTimes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "maxSupplyPerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionInvariants {
    return new CollectionInvariants().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionInvariants {
    return new CollectionInvariants().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionInvariants {
    return new CollectionInvariants().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionInvariants | PlainMessage<CollectionInvariants> | undefined, b: CollectionInvariants | PlainMessage<CollectionInvariants> | undefined): boolean {
    return proto3.util.equals(CollectionInvariants, a, b);
  }
}

