// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file badges/collections.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { BadgeMetadataTimeline, CollectionMetadataTimeline, CustomDataTimeline, IsArchivedTimeline, ManagerTimeline, OffChainBalancesMetadataTimeline, StandardsTimeline } from "./timelines_pb.js";
import { CollectionPermissions } from "./permissions_pb.js";
import { CollectionApproval, UserBalanceStore } from "./transfers_pb.js";
import { UintRange } from "./balances_pb.js";

/**
 *
 * A BadgeCollection is the top-level object for a collection of badges. 
 * It defines everything about the collection, such as the manager, metadata, etc.
 *
 * All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).
 *
 * All collections can have a manager who is responsible for managing the collection and can be granted certain admin
 * permissions, such as the ability to mint new badges.
 *
 * Certain fields are timeline-based, which means they may have different values at different block heights. 
 * We fetch the value according to the current time.
 * For example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.
 *
 * Collections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.
 *
 * See documentation for more details.
 *
 * @generated from message badges.BadgeCollection
 */
export class BadgeCollection extends Message<BadgeCollection> {
  /**
   * The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  /**
   * The metadata for the collection itself, which can vary over time.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 2;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * The metadata for each badge in the collection, also subject to changes over time.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 3;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * The type of balances this collection uses ("Standard", "Off-Chain - Indexed", "Off-Chain - Non-Indexed", or "Non-Public").
   *
   * @generated from field: string balancesType = 4;
   */
  balancesType = "";

  /**
   * Metadata for fetching balances for collections with off-chain balances, subject to changes over time.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 5;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * An arbitrary field that can store any data, subject to changes over time.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 7;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * The address of the manager of this collection, subject to changes over time.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 8;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Permissions that define what the manager of the collection can do or not do.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 9;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Transferability of the collection for collections with standard balances, subject to changes over time.
   * Overrides user approvals for a transfer if specified.
   * Transfer must satisfy both user and collection-level approvals.
   * Only applicable to on-chain balances.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 10;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards that define how to interpret the fields of the collection, subject to changes over time.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 11;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Whether the collection is archived or not, subject to changes over time.
   * When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 12;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * The default store of a balance for a user, upon genesis.
   *
   * @generated from field: badges.UserBalanceStore defaultBalances = 13;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * The user or entity who created the badge collection.
   *
   * @generated from field: string createdBy = 14;
   */
  createdBy = "";

  /**
   * The valid badge IDs for this collection.
   *
   * @generated from field: repeated badges.UintRange validBadgeIds = 15;
   */
  validBadgeIds: UintRange[] = [];

  constructor(data?: PartialMessage<BadgeCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BadgeCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 3, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 4, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 7, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 8, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 9, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 10, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 11, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 12, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 13, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 14, name: "createdBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "validBadgeIds", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadgeCollection {
    return new BadgeCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadgeCollection {
    return new BadgeCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadgeCollection {
    return new BadgeCollection().fromJsonString(jsonString, options);
  }

  static equals(a: BadgeCollection | PlainMessage<BadgeCollection> | undefined, b: BadgeCollection | PlainMessage<BadgeCollection> | undefined): boolean {
    return proto3.util.equals(BadgeCollection, a, b);
  }
}

