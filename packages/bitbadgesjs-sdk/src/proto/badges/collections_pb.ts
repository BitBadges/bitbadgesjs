// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file badges/collections.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { CollectionMetadata, TokenMetadata } from "./metadata_pb.js";
import { CollectionPermissions } from "./permissions_pb.js";
import { CollectionApproval } from "./approvals_pb.js";
import { UserBalanceStore } from "./user_balance_store_pb.js";
import { Balance, UintRange } from "./balances_pb.js";

/**
 *
 * A TokenCollection is the top-level object for a collection of tokens. 
 * It defines everything about the collection, such as the manager, metadata, etc.
 *
 * All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).
 *
 * All collections can have a manager who is responsible for managing the collection and can be granted certain admin
 * permissions, such as the ability to mint new tokens.
 *
 * Collections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.
 *
 * See documentation for more details.
 *
 * @generated from message badges.TokenCollection
 */
export class TokenCollection extends Message<TokenCollection> {
  /**
   * The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  /**
   * The metadata for the collection itself.
   *
   * @generated from field: badges.CollectionMetadata collectionMetadata = 2;
   */
  collectionMetadata?: CollectionMetadata;

  /**
   * The metadata for each token in the collection.
   *
   * @generated from field: repeated badges.TokenMetadata tokenMetadata = 3;
   */
  tokenMetadata: TokenMetadata[] = [];

  /**
   * An arbitrary field that can store any data.
   *
   * @generated from field: string customData = 4;
   */
  customData = "";

  /**
   * The address of the manager of this collection.
   *
   * @generated from field: string manager = 5;
   */
  manager = "";

  /**
   * Permissions that define what the manager of the collection can do or not do.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 6;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Transferability of the collection for collections with standard balances, subject to changes over time.
   * Overrides user approvals for a transfer if specified.
   * Transfer must satisfy both user and collection-level approvals.
   * Only applicable to on-chain balances.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 7;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards that define how to interpret the fields of the collection.
   *
   * @generated from field: repeated string standards = 8;
   */
  standards: string[] = [];

  /**
   * Whether the collection is archived or not.
   * When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
   *
   * @generated from field: bool isArchived = 9;
   */
  isArchived = false;

  /**
   * The default store of a balance / approvals for a user, upon genesis.
   *
   * @generated from field: badges.UserBalanceStore defaultBalances = 10;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * The user or entity who created the collection.
   *
   * @generated from field: string createdBy = 11;
   */
  createdBy = "";

  /**
   * The valid token IDs for this collection.
   *
   * @generated from field: repeated badges.UintRange validTokenIds = 12;
   */
  validTokenIds: UintRange[] = [];

  /**
   * The generated address of the collection. Also used to escrow Mint balances.
   *
   * @generated from field: string mintEscrowAddress = 13;
   */
  mintEscrowAddress = "";

  /**
   * The IBC wrapper (sdk.coin) paths for the collection.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPath cosmosCoinWrapperPaths = 14;
   */
  cosmosCoinWrapperPaths: CosmosCoinWrapperPath[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   * These are set upon genesis and cannot be modified.
   *
   * @generated from field: badges.CollectionInvariants invariants = 15;
   */
  invariants?: CollectionInvariants;

  /**
   * The alias (non-wrapping) paths for the collection.
   *
   * @generated from field: repeated badges.AliasPath aliasPaths = 16;
   */
  aliasPaths: AliasPath[] = [];

  constructor(data?: PartialMessage<TokenCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.TokenCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionMetadata", kind: "message", T: CollectionMetadata },
    { no: 3, name: "tokenMetadata", kind: "message", T: TokenMetadata, repeated: true },
    { no: 4, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "manager", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 7, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 8, name: "standards", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "isArchived", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 11, name: "createdBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "validTokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 13, name: "mintEscrowAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "cosmosCoinWrapperPaths", kind: "message", T: CosmosCoinWrapperPath, repeated: true },
    { no: 15, name: "invariants", kind: "message", T: CollectionInvariants },
    { no: 16, name: "aliasPaths", kind: "message", T: AliasPath, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TokenCollection {
    return new TokenCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TokenCollection {
    return new TokenCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TokenCollection {
    return new TokenCollection().fromJsonString(jsonString, options);
  }

  static equals(a: TokenCollection | PlainMessage<TokenCollection> | undefined, b: TokenCollection | PlainMessage<TokenCollection> | undefined): boolean {
    return proto3.util.equals(TokenCollection, a, b);
  }
}

/**
 * @generated from message badges.CosmosCoinWrapperPath
 */
export class CosmosCoinWrapperPath extends Message<CosmosCoinWrapperPath> {
  /**
   * The BitBadges address associated with this wrapper path. Used for routing and identifying the wrapper.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * The denomination (denom) to be used for the wrapped coin or the alias denom.
   *
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * The token balances that correspond to this wrapper path. Defines how much you have to wrap to get the corresponding base level unit.
   *
   * @generated from field: repeated badges.Balance balances = 3;
   */
  balances: Balance[] = [];

  /**
   * The symbol for the wrapped coin (e.g., "BADGE", "NFT"). Used for display purposes. Note that this may not be the default.
   *
   * @generated from field: string symbol = 4;
   */
  symbol = "";

  /**
   * Denomination units for the wrapped coin. Defines how the coin can be displayed with different
   * decimal places and symbols (e.g., base unit, display unit). You can specify which is the default display unit (base level or one of these).
   *
   * @generated from field: repeated badges.DenomUnit denomUnits = 5;
   */
  denomUnits: DenomUnit[] = [];

  /**
   * If true, allows this wrapper path to be used with any valid token ID in the collection via an {id} placeholder.
   *
   * @generated from field: bool allowOverrideWithAnyValidToken = 6;
   */
  allowOverrideWithAnyValidToken = false;

  /**
   * The base amount of the wrapped denom (0 decimals) that maps to balances[] for conversions.
   *
   * @generated from field: string amount = 7;
   */
  amount = "";

  constructor(data?: PartialMessage<CosmosCoinWrapperPath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CosmosCoinWrapperPath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 4, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "denomUnits", kind: "message", T: DenomUnit, repeated: true },
    { no: 6, name: "allowOverrideWithAnyValidToken", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CosmosCoinWrapperPath {
    return new CosmosCoinWrapperPath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPath {
    return new CosmosCoinWrapperPath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPath {
    return new CosmosCoinWrapperPath().fromJsonString(jsonString, options);
  }

  static equals(a: CosmosCoinWrapperPath | PlainMessage<CosmosCoinWrapperPath> | undefined, b: CosmosCoinWrapperPath | PlainMessage<CosmosCoinWrapperPath> | undefined): boolean {
    return proto3.util.equals(CosmosCoinWrapperPath, a, b);
  }
}

/**
 * @generated from message badges.AliasPath
 */
export class AliasPath extends Message<AliasPath> {
  /**
   * The denomination (denom) to be used for the alias.
   *
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * The token balances that correspond to this alias path. Defines how much of the base level unit the alias maps to.
   *
   * @generated from field: repeated badges.Balance balances = 2;
   */
  balances: Balance[] = [];

  /**
   * The symbol for the alias (e.g., "BADGE", "NFT"). Used for display purposes. Note that this may not be the default.
   *
   * @generated from field: string symbol = 3;
   */
  symbol = "";

  /**
   * Denomination units for the alias. Defines how the coin can be displayed with different decimal places and symbols.
   *
   * @generated from field: repeated badges.DenomUnit denomUnits = 4;
   */
  denomUnits: DenomUnit[] = [];

  /**
   * The base amount of the alias denom (0 decimals) that maps to balances[] for conversions.
   *
   * @generated from field: string amount = 5;
   */
  amount = "";

  constructor(data?: PartialMessage<AliasPath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.AliasPath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 3, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "denomUnits", kind: "message", T: DenomUnit, repeated: true },
    { no: 5, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AliasPath {
    return new AliasPath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AliasPath {
    return new AliasPath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AliasPath {
    return new AliasPath().fromJsonString(jsonString, options);
  }

  static equals(a: AliasPath | PlainMessage<AliasPath> | undefined, b: AliasPath | PlainMessage<AliasPath> | undefined): boolean {
    return proto3.util.equals(AliasPath, a, b);
  }
}

/**
 * @generated from message badges.CosmosCoinBackedPath
 */
export class CosmosCoinBackedPath extends Message<CosmosCoinBackedPath> {
  /**
   * The address associated with this backed path. Used for routing and escrowing IBC tokens.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * The IBC denomination of the backing token. This identifies which IBC token backs the badges
   * (e.g., "ibc/..." or "ubadge"). Conversion is Balances[] = sdk.Coins([{ amount: ibcAmount, denom: ibcDenom }])
   *
   * @generated from field: string ibcDenom = 2;
   */
  ibcDenom = "";

  /**
   * The token balances that correspond to this backed path. Defines which token IDs and amounts
   * are backed by the IBC tokens. Conversion is Balances[] = sdk.Coins([{ amount: ibcAmount, denom: ibcDenom }])
   *
   * @generated from field: repeated badges.Balance balances = 3;
   */
  balances: Balance[] = [];

  /**
   * The amount of IBC tokens that back the tokens. This defines the exchange rate or backing amount
   * for the tokens in this path. Conversion is Balances[] = sdk.Coins([{ amount: ibcAmount, denom: ibcDenom }])
   *
   * @generated from field: string ibcAmount = 4;
   */
  ibcAmount = "";

  constructor(data?: PartialMessage<CosmosCoinBackedPath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CosmosCoinBackedPath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ibcDenom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 4, name: "ibcAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CosmosCoinBackedPath {
    return new CosmosCoinBackedPath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CosmosCoinBackedPath {
    return new CosmosCoinBackedPath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CosmosCoinBackedPath {
    return new CosmosCoinBackedPath().fromJsonString(jsonString, options);
  }

  static equals(a: CosmosCoinBackedPath | PlainMessage<CosmosCoinBackedPath> | undefined, b: CosmosCoinBackedPath | PlainMessage<CosmosCoinBackedPath> | undefined): boolean {
    return proto3.util.equals(CosmosCoinBackedPath, a, b);
  }
}

/**
 * @generated from message badges.DenomUnit
 */
export class DenomUnit extends Message<DenomUnit> {
  /**
   * The number of decimal places for this unit. Defines the precision of the unit.
   *
   * @generated from field: string decimals = 1;
   */
  decimals = "";

  /**
   * The symbol for this unit (e.g., "BADGE", "nBADGE"). Used for display purposes.
   *
   * @generated from field: string symbol = 2;
   */
  symbol = "";

  /**
   * If true, this is the default display unit. Only one unit should be marked as the default display unit.
   * This unit will be used by default when displaying the coin amount. If none are marked default, we use the base level.
   *
   * @generated from field: bool isDefaultDisplay = 3;
   */
  isDefaultDisplay = false;

  constructor(data?: PartialMessage<DenomUnit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.DenomUnit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "decimals", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isDefaultDisplay", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenomUnit {
    return new DenomUnit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenomUnit {
    return new DenomUnit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenomUnit {
    return new DenomUnit().fromJsonString(jsonString, options);
  }

  static equals(a: DenomUnit | PlainMessage<DenomUnit> | undefined, b: DenomUnit | PlainMessage<DenomUnit> | undefined): boolean {
    return proto3.util.equals(DenomUnit, a, b);
  }
}

/**
 * CollectionInvariants defines the invariants that apply to a collection.
 *
 * @generated from message badges.CollectionInvariants
 */
export class CollectionInvariants extends Message<CollectionInvariants> {
  /**
   * If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
   * This prevents time-based restrictions on token ownership.
   *
   * @generated from field: bool noCustomOwnershipTimes = 1;
   */
  noCustomOwnershipTimes = false;

  /**
   * Maximum supply per token ID. If set, no balance can exceed this amount.
   * This prevents any single token ID from having more than the specified supply.
   *
   * @generated from field: string maxSupplyPerId = 2;
   */
  maxSupplyPerId = "";

  /**
   * The IBC backed (sdk.coin) path for the collection. Only one path is allowed.
   *
   * @generated from field: badges.CosmosCoinBackedPath cosmosCoinBackedPath = 3;
   */
  cosmosCoinBackedPath?: CosmosCoinBackedPath;

  /**
   * If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.
   * This prevents forceful transfers that bypass user-level approvals.
   * This only applies to transfers where the from address does not equal "Mint".
   *
   * @generated from field: bool noForcefulPostMintTransfers = 4;
   */
  noForcefulPostMintTransfers = false;

  /**
   * If true, disallows pool creation with this collection's assets.
   * When true, any attempt to create a pool with badges assets from this collection will fail.
   *
   * @generated from field: bool disablePoolCreation = 5;
   */
  disablePoolCreation = false;

  constructor(data?: PartialMessage<CollectionInvariants>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionInvariants";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "noCustomOwnershipTimes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "maxSupplyPerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cosmosCoinBackedPath", kind: "message", T: CosmosCoinBackedPath },
    { no: 4, name: "noForcefulPostMintTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "disablePoolCreation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionInvariants {
    return new CollectionInvariants().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionInvariants {
    return new CollectionInvariants().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionInvariants {
    return new CollectionInvariants().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionInvariants | PlainMessage<CollectionInvariants> | undefined, b: CollectionInvariants | PlainMessage<CollectionInvariants> | undefined): boolean {
    return proto3.util.equals(CollectionInvariants, a, b);
  }
}

