// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file badges/transfers.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Balance, UintRange } from "./balances_pb.js";
import { UserPermissions } from "./permissions_pb.js";
import { Coin } from "../cosmos/base/v1beta1/coin_pb.js";

/**
 *
 * UserBalanceStore is the store for the user balances for a collection.
 *
 * It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
 * as well as the permissions for updating the approved incoming/outgoing transfers.
 *
 * Upon initialization, all fields (minus the balances) are set to the defaults specified by the collection.
 *
 * The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
 * If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)
 * and autoApproveSelfInitiatedOutgoingTransfers is set to true.
 *
 * The incoming transfers can be used to allow / disallow transfers which are sent to this user.
 * If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)
 * and autoApproveSelfInitiatedIncomingTransfers is set to true.
 *
 * Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
 * the user approved transfers. 
 *
 * The permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.
 *
 * @generated from message badges.UserBalanceStore
 */
export class UserBalanceStore extends Message<UserBalanceStore> {
  /**
   * The list of balances associated with this user.
   *
   * @generated from field: repeated badges.Balance balances = 1;
   */
  balances: Balance[] = [];

  /**
   * The list of approved outgoing transfers for this user.
   *
   * @generated from field: repeated badges.UserOutgoingApproval outgoingApprovals = 2;
   */
  outgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * The list of approved incoming transfers for this user.
   *
   * @generated from field: repeated badges.UserIncomingApproval incomingApprovals = 3;
   */
  incomingApprovals: UserIncomingApproval[] = [];

  /**
   * Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).
   *
   * @generated from field: bool autoApproveSelfInitiatedOutgoingTransfers = 4;
   */
  autoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).
   *
   * @generated from field: bool autoApproveSelfInitiatedIncomingTransfers = 5;
   */
  autoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Whether to auto-approve all incoming transfers by default. 
   * This is just shorthand for adding an accept everything incoming approval
   * with no restrictions.
   *
   * @generated from field: bool autoApproveAllIncomingTransfers = 6;
   */
  autoApproveAllIncomingTransfers = false;

  /**
   * The permissions for this user's actions and transfers.
   *
   * @generated from field: badges.UserPermissions userPermissions = 7;
   */
  userPermissions?: UserPermissions;

  constructor(data?: PartialMessage<UserBalanceStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserBalanceStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 2, name: "outgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 3, name: "incomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 4, name: "autoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "autoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "autoApproveAllIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "userPermissions", kind: "message", T: UserPermissions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserBalanceStore {
    return new UserBalanceStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserBalanceStore {
    return new UserBalanceStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserBalanceStore {
    return new UserBalanceStore().fromJsonString(jsonString, options);
  }

  static equals(a: UserBalanceStore | PlainMessage<UserBalanceStore> | undefined, b: UserBalanceStore | PlainMessage<UserBalanceStore> | undefined): boolean {
    return proto3.util.equals(UserBalanceStore, a, b);
  }
}

/**
 *
 * Challenges define a rule for the approval in the form of a Merkle challenge.
 *
 * A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
 * then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.
 *
 * IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.
 *
 * IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
 * If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
 * We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
 *
 * @generated from message badges.MerkleChallenge
 */
export class MerkleChallenge extends Message<MerkleChallenge> {
  /**
   * The root hash of the Merkle tree to which the Merkle path must lead for verification.
   *
   * @generated from field: string root = 1;
   */
  root = "";

  /**
   * The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
   *
   * @generated from field: string expectedProofLength = 2;
   */
  expectedProofLength = "";

  /**
   * If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.
   *
   * @generated from field: bool useCreatorAddressAsLeaf = 3;
   */
  useCreatorAddressAsLeaf = false;

  /**
   * The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
   *
   * @generated from field: string maxUsesPerLeaf = 4;
   */
  maxUsesPerLeaf = "";

  /**
   * The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
   *
   * @generated from field: string uri = 5;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this Merkle challenge.
   *
   * @generated from field: string customData = 6;
   */
  customData = "";

  /**
   * The ID of this Merkle challenge for tracking the number of uses per leaf.
   *
   * @generated from field: string challengeTrackerId = 7;
   */
  challengeTrackerId = "";

  /**
   * Leaf must be signed by. Used to protect against man in the middle attacks.`
   * Scheme we use is sign(leaf + "-" +
   *
   * @generated from field: string leafSigner = 8;
   */
  leafSigner = "";

  constructor(data?: PartialMessage<MerkleChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expectedProofLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "useCreatorAddressAsLeaf", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "maxUsesPerLeaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "leafSigner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleChallenge {
    return new MerkleChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined, b: MerkleChallenge | PlainMessage<MerkleChallenge> | undefined): boolean {
    return proto3.util.equals(MerkleChallenge, a, b);
  }
}

/**
 *
 * ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.
 *
 * An ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.
 * The signature scheme is ETHSign(nonce + "-" + creatorAddress) and each signature can only be used once.
 * All challenges must be met with valid solutions for the transfer to be approved.
 *
 * IMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.
 * If you update the challenge ID, then the used signatures tracker will reset and start a new tally.
 * We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
 *
 * @generated from message badges.ETHSignatureChallenge
 */
export class ETHSignatureChallenge extends Message<ETHSignatureChallenge> {
  /**
   * The Ethereum address that must sign the nonce for verification.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * The ID of this ETH signature challenge for tracking the number of uses per signature.
   *
   * @generated from field: string challengeTrackerId = 2;
   */
  challengeTrackerId = "";

  /**
   * The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.
   *
   * @generated from field: string uri = 3;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this ETH signature challenge.
   *
   * @generated from field: string customData = 4;
   */
  customData = "";

  constructor(data?: PartialMessage<ETHSignatureChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ETHSignatureChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ETHSignatureChallenge {
    return new ETHSignatureChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ETHSignatureChallenge {
    return new ETHSignatureChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ETHSignatureChallenge {
    return new ETHSignatureChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: ETHSignatureChallenge | PlainMessage<ETHSignatureChallenge> | undefined, b: ETHSignatureChallenge | PlainMessage<ETHSignatureChallenge> | undefined): boolean {
    return proto3.util.equals(ETHSignatureChallenge, a, b);
  }
}

/**
 * UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.
 *
 * @generated from message badges.UserOutgoingApproval
 */
export class UserOutgoingApproval extends Message<UserOutgoingApproval> {
  /**
   * The list ID for the recipient of the transfer.
   *
   * @generated from field: string toListId = 1;
   */
  toListId = "";

  /**
   * The list ID for the user who initiated the transfer.
   *
   * @generated from field: string initiatedByListId = 2;
   */
  initiatedByListId = "";

  /**
   * The allowed range of transfer times for approval.
   *
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * The allowed range of token IDs for approval.
   *
   * @generated from field: repeated badges.UintRange tokenIds = 4;
   */
  tokenIds: UintRange[] = [];

  /**
   * The allowed range of ownership times for approval.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * The URI associated with this approval, optionally providing metadata about the approval.
   *
   * @generated from field: string uri = 8;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this approval.
   *
   * @generated from field: string customData = 9;
   */
  customData = "";

  /**
   * The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
   *
   * @generated from field: string approvalId = 10;
   */
  approvalId = "";

  /**
   * The criteria that must be met for this approval to be considered.
   *
   * @generated from field: badges.OutgoingApprovalCriteria approvalCriteria = 11;
   */
  approvalCriteria?: OutgoingApprovalCriteria;

  /**
   * Version of the approval. Maintained internally.
   *
   * @generated from field: string version = 12;
   */
  version = "";

  constructor(data?: PartialMessage<UserOutgoingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserOutgoingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "toListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "tokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 8, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "approvalCriteria", kind: "message", T: OutgoingApprovalCriteria },
    { no: 12, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserOutgoingApproval {
    return new UserOutgoingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserOutgoingApproval {
    return new UserOutgoingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserOutgoingApproval {
    return new UserOutgoingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: UserOutgoingApproval | PlainMessage<UserOutgoingApproval> | undefined, b: UserOutgoingApproval | PlainMessage<UserOutgoingApproval> | undefined): boolean {
    return proto3.util.equals(UserOutgoingApproval, a, b);
  }
}

/**
 * UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.
 *
 * @generated from message badges.UserIncomingApproval
 */
export class UserIncomingApproval extends Message<UserIncomingApproval> {
  /**
   * The list ID for the sender of the transfer.
   *
   * @generated from field: string fromListId = 1;
   */
  fromListId = "";

  /**
   * The list ID for the user who initiated the transfer.
   *
   * @generated from field: string initiatedByListId = 2;
   */
  initiatedByListId = "";

  /**
   * The allowed range of transfer times for approval.
   *
   * @generated from field: repeated badges.UintRange transferTimes = 3;
   */
  transferTimes: UintRange[] = [];

  /**
   * The allowed range of token IDs for approval.
   *
   * @generated from field: repeated badges.UintRange tokenIds = 4;
   */
  tokenIds: UintRange[] = [];

  /**
   * The allowed range of ownership times for approval.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 5;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * The URI associated with this approval, optionally providing metadata about the approval.
   *
   * @generated from field: string uri = 8;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this approval.
   *
   * @generated from field: string customData = 9;
   */
  customData = "";

  /**
   * The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
   *
   * @generated from field: string approvalId = 10;
   */
  approvalId = "";

  /**
   * The criteria that must be met for this approval to be considered.
   *
   * @generated from field: badges.IncomingApprovalCriteria approvalCriteria = 11;
   */
  approvalCriteria?: IncomingApprovalCriteria;

  /**
   * Version of the approval. Maintained internally.
   *
   * @generated from field: string version = 12;
   */
  version = "";

  constructor(data?: PartialMessage<UserIncomingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserIncomingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initiatedByListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "tokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 8, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "approvalCriteria", kind: "message", T: IncomingApprovalCriteria },
    { no: 12, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserIncomingApproval {
    return new UserIncomingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserIncomingApproval {
    return new UserIncomingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserIncomingApproval {
    return new UserIncomingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: UserIncomingApproval | PlainMessage<UserIncomingApproval> | undefined, b: UserIncomingApproval | PlainMessage<UserIncomingApproval> | undefined): boolean {
    return proto3.util.equals(UserIncomingApproval, a, b);
  }
}

/**
 * ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set. 
 *
 * @generated from message badges.ManualBalances
 */
export class ManualBalances extends Message<ManualBalances> {
  /**
   * @generated from field: repeated badges.Balance balances = 1;
   */
  balances: Balance[] = [];

  constructor(data?: PartialMessage<ManualBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ManualBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balances", kind: "message", T: Balance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ManualBalances {
    return new ManualBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ManualBalances {
    return new ManualBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ManualBalances {
    return new ManualBalances().fromJsonString(jsonString, options);
  }

  static equals(a: ManualBalances | PlainMessage<ManualBalances> | undefined, b: ManualBalances | PlainMessage<ManualBalances> | undefined): boolean {
    return proto3.util.equals(ManualBalances, a, b);
  }
}

/**
 * RecurringOwnershipTimes represents a list of recurring ownership times.
 *
 * @generated from message badges.RecurringOwnershipTimes
 */
export class RecurringOwnershipTimes extends Message<RecurringOwnershipTimes> {
  /**
   * The original start time of the first interval.
   *
   * @generated from field: string startTime = 1;
   */
  startTime = "";

  /**
   * The interval length in unix milliseconds.
   *
   * @generated from field: string intervalLength = 2;
   */
  intervalLength = "";

  /**
   * Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period
   *
   * @generated from field: string chargePeriodLength = 3;
   */
  chargePeriodLength = "";

  constructor(data?: PartialMessage<RecurringOwnershipTimes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.RecurringOwnershipTimes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "startTime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "intervalLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chargePeriodLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecurringOwnershipTimes {
    return new RecurringOwnershipTimes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecurringOwnershipTimes {
    return new RecurringOwnershipTimes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecurringOwnershipTimes {
    return new RecurringOwnershipTimes().fromJsonString(jsonString, options);
  }

  static equals(a: RecurringOwnershipTimes | PlainMessage<RecurringOwnershipTimes> | undefined, b: RecurringOwnershipTimes | PlainMessage<RecurringOwnershipTimes> | undefined): boolean {
    return proto3.util.equals(RecurringOwnershipTimes, a, b);
  }
}

/**
 * IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.
 *
 * @generated from message badges.IncrementedBalances
 */
export class IncrementedBalances extends Message<IncrementedBalances> {
  /**
   * @generated from field: repeated badges.Balance startBalances = 1;
   */
  startBalances: Balance[] = [];

  /**
   * The amount by which to increment token IDs.
   *
   * @generated from field: string incrementTokenIdsBy = 2;
   */
  incrementTokenIdsBy = "";

  /**
   * The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.
   *
   * @generated from field: string incrementOwnershipTimesBy = 3;
   */
  incrementOwnershipTimesBy = "";

  /**
   * The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.
   *
   * @generated from field: string durationFromTimestamp = 4;
   */
  durationFromTimestamp = "";

  /**
   * Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).
   *
   * @generated from field: bool allowOverrideTimestamp = 5;
   */
  allowOverrideTimestamp = false;

  /**
   * Recurring ownership times.
   *
   * @generated from field: badges.RecurringOwnershipTimes recurringOwnershipTimes = 6;
   */
  recurringOwnershipTimes?: RecurringOwnershipTimes;

  /**
   * Allow override of any valid ID
   *
   * @generated from field: bool allowOverrideWithAnyValidToken = 7;
   */
  allowOverrideWithAnyValidToken = false;

  constructor(data?: PartialMessage<IncrementedBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.IncrementedBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "startBalances", kind: "message", T: Balance, repeated: true },
    { no: 2, name: "incrementTokenIdsBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "incrementOwnershipTimesBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "durationFromTimestamp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "allowOverrideTimestamp", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "recurringOwnershipTimes", kind: "message", T: RecurringOwnershipTimes },
    { no: 7, name: "allowOverrideWithAnyValidToken", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromJsonString(jsonString, options);
  }

  static equals(a: IncrementedBalances | PlainMessage<IncrementedBalances> | undefined, b: IncrementedBalances | PlainMessage<IncrementedBalances> | undefined): boolean {
    return proto3.util.equals(IncrementedBalances, a, b);
  }
}

/**
 * PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.
 *
 * @generated from message badges.PredeterminedOrderCalculationMethod
 */
export class PredeterminedOrderCalculationMethod extends Message<PredeterminedOrderCalculationMethod> {
  /**
   * Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.
   *
   * @generated from field: bool useOverallNumTransfers = 1;
   */
  useOverallNumTransfers = false;

  /**
   * Use the number of transfers per "to" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.
   *
   * @generated from field: bool usePerToAddressNumTransfers = 2;
   */
  usePerToAddressNumTransfers = false;

  /**
   * Use the number of transfers per "from" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.
   *
   * @generated from field: bool usePerFromAddressNumTransfers = 3;
   */
  usePerFromAddressNumTransfers = false;

  /**
   * Use the number of transfers per "initiated by" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.
   *
   * @generated from field: bool usePerInitiatedByAddressNumTransfers = 4;
   */
  usePerInitiatedByAddressNumTransfers = false;

  /**
   * Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.
   *
   * @generated from field: bool useMerkleChallengeLeafIndex = 5;
   */
  useMerkleChallengeLeafIndex = false;

  /**
   * If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.
   *
   * @generated from field: string challengeTrackerId = 6;
   */
  challengeTrackerId = "";

  constructor(data?: PartialMessage<PredeterminedOrderCalculationMethod>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PredeterminedOrderCalculationMethod";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "useOverallNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "usePerToAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "usePerFromAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "usePerInitiatedByAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "useMerkleChallengeLeafIndex", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromJsonString(jsonString, options);
  }

  static equals(a: PredeterminedOrderCalculationMethod | PlainMessage<PredeterminedOrderCalculationMethod> | undefined, b: PredeterminedOrderCalculationMethod | PlainMessage<PredeterminedOrderCalculationMethod> | undefined): boolean {
    return proto3.util.equals(PredeterminedOrderCalculationMethod, a, b);
  }
}

/**
 * PredeterminedBalances represents balances with predetermined order calculation.
 *
 * @generated from message badges.PredeterminedBalances
 */
export class PredeterminedBalances extends Message<PredeterminedBalances> {
  /**
   * Manual balances that can be entered. If this is nil, then we use the incremented balances.
   *
   * @generated from field: repeated badges.ManualBalances manualBalances = 1;
   */
  manualBalances: ManualBalances[] = [];

  /**
   * Balances that have a starting amount and increment. If this is nil, then we use the manual balances.
   *
   * @generated from field: badges.IncrementedBalances incrementedBalances = 2;
   */
  incrementedBalances?: IncrementedBalances;

  /**
   * The method to calculate the order of predetermined balances.
   *
   * @generated from field: badges.PredeterminedOrderCalculationMethod orderCalculationMethod = 3;
   */
  orderCalculationMethod?: PredeterminedOrderCalculationMethod;

  constructor(data?: PartialMessage<PredeterminedBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PredeterminedBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "manualBalances", kind: "message", T: ManualBalances, repeated: true },
    { no: 2, name: "incrementedBalances", kind: "message", T: IncrementedBalances },
    { no: 3, name: "orderCalculationMethod", kind: "message", T: PredeterminedOrderCalculationMethod },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromJsonString(jsonString, options);
  }

  static equals(a: PredeterminedBalances | PlainMessage<PredeterminedBalances> | undefined, b: PredeterminedBalances | PlainMessage<PredeterminedBalances> | undefined): boolean {
    return proto3.util.equals(PredeterminedBalances, a, b);
  }
}

/**
 * AutoDeletionOptions defines the options for auto-deletion of approvals.
 *
 * @generated from message badges.AutoDeletionOptions
 */
export class AutoDeletionOptions extends Message<AutoDeletionOptions> {
  /**
   * After one use?
   *
   * @generated from field: bool afterOneUse = 1;
   */
  afterOneUse = false;

  /**
   * After overall max number of uses threshold is met?
   *
   * @generated from field: bool afterOverallMaxNumTransfers = 2;
   */
  afterOverallMaxNumTransfers = false;

  /**
   * Allow counterparty to purge this approval if they are the only initiator
   *
   * @generated from field: bool allowCounterpartyPurge = 3;
   */
  allowCounterpartyPurge = false;

  /**
   * Allow others to call PurgeApprovals on behalf of this approval owner
   *
   * @generated from field: bool allowPurgeIfExpired = 4;
   */
  allowPurgeIfExpired = false;

  constructor(data?: PartialMessage<AutoDeletionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.AutoDeletionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "afterOneUse", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "afterOverallMaxNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "allowCounterpartyPurge", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "allowPurgeIfExpired", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AutoDeletionOptions {
    return new AutoDeletionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AutoDeletionOptions {
    return new AutoDeletionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AutoDeletionOptions {
    return new AutoDeletionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: AutoDeletionOptions | PlainMessage<AutoDeletionOptions> | undefined, b: AutoDeletionOptions | PlainMessage<AutoDeletionOptions> | undefined): boolean {
    return proto3.util.equals(AutoDeletionOptions, a, b);
  }
}

/**
 * ApprovalAmounts defines approval amounts per unique "from," "to," and/or "initiated by" address.
 * If any of these are nil or "0", we assume unlimited approvals.
 * If they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times 
 * must not exceed the corresponding value.
 *
 * @generated from message badges.ApprovalAmounts
 */
export class ApprovalAmounts extends Message<ApprovalAmounts> {
  /**
   * Overall approval amount.
   *
   * @generated from field: string overallApprovalAmount = 1;
   */
  overallApprovalAmount = "";

  /**
   * Approval amount per "to" address.
   *
   * @generated from field: string perToAddressApprovalAmount = 2;
   */
  perToAddressApprovalAmount = "";

  /**
   * Approval amount per "from" address.
   *
   * @generated from field: string perFromAddressApprovalAmount = 3;
   */
  perFromAddressApprovalAmount = "";

  /**
   * Approval amount per "initiated by" address.
   *
   * @generated from field: string perInitiatedByAddressApprovalAmount = 4;
   */
  perInitiatedByAddressApprovalAmount = "";

  /**
   * The ID of the amount tracker associated with this approval.
   * We use this ID to track the number of transfers and amounts transferred.
   *
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * Time intervals to reset the trackers at.
   *
   * @generated from field: badges.ResetTimeIntervals resetTimeIntervals = 7;
   */
  resetTimeIntervals?: ResetTimeIntervals;

  constructor(data?: PartialMessage<ApprovalAmounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalAmounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overallApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "perToAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "perFromAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "perInitiatedByAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "resetTimeIntervals", kind: "message", T: ResetTimeIntervals },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalAmounts | PlainMessage<ApprovalAmounts> | undefined, b: ApprovalAmounts | PlainMessage<ApprovalAmounts> | undefined): boolean {
    return proto3.util.equals(ApprovalAmounts, a, b);
  }
}

/**
 * Time intervals to reset the trackers at.
 *
 * @generated from message badges.ResetTimeIntervals
 */
export class ResetTimeIntervals extends Message<ResetTimeIntervals> {
  /**
   * Original start time of the first interval.
   *
   * @generated from field: string startTime = 1;
   */
  startTime = "";

  /**
   * Interval length in unix milliseconds.
   *
   * @generated from field: string intervalLength = 2;
   */
  intervalLength = "";

  constructor(data?: PartialMessage<ResetTimeIntervals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ResetTimeIntervals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "startTime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "intervalLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetTimeIntervals {
    return new ResetTimeIntervals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetTimeIntervals {
    return new ResetTimeIntervals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetTimeIntervals {
    return new ResetTimeIntervals().fromJsonString(jsonString, options);
  }

  static equals(a: ResetTimeIntervals | PlainMessage<ResetTimeIntervals> | undefined, b: ResetTimeIntervals | PlainMessage<ResetTimeIntervals> | undefined): boolean {
    return proto3.util.equals(ResetTimeIntervals, a, b);
  }
}

/**
 * MaxNumTransfers defines the maximum number of transfers per unique "from," "to," and/or "initiated by" address.
 * If any of these are nil or "0", we assume unlimited approvals.
 * If they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times
 * must not exceed the corresponding value.
 *
 * @generated from message badges.MaxNumTransfers
 */
export class MaxNumTransfers extends Message<MaxNumTransfers> {
  /**
   * Overall maximum number of transfers.
   *
   * @generated from field: string overallMaxNumTransfers = 1;
   */
  overallMaxNumTransfers = "";

  /**
   * Maximum number of transfers per "to" address.
   *
   * @generated from field: string perToAddressMaxNumTransfers = 2;
   */
  perToAddressMaxNumTransfers = "";

  /**
   * Maximum number of transfers per "from" address.
   *
   * @generated from field: string perFromAddressMaxNumTransfers = 3;
   */
  perFromAddressMaxNumTransfers = "";

  /**
   * Maximum number of transfers per "initiated by" address.
   *
   * @generated from field: string perInitiatedByAddressMaxNumTransfers = 4;
   */
  perInitiatedByAddressMaxNumTransfers = "";

  /**
   * The ID of the amount tracker associated with this approval.
   * We use this ID to track the number of transfers and amounts transferred.
   *
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * Time intervals to reset the trackers at.
   *
   * @generated from field: badges.ResetTimeIntervals resetTimeIntervals = 7;
   */
  resetTimeIntervals?: ResetTimeIntervals;

  constructor(data?: PartialMessage<MaxNumTransfers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MaxNumTransfers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overallMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "perToAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "perFromAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "perInitiatedByAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "resetTimeIntervals", kind: "message", T: ResetTimeIntervals },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromJsonString(jsonString, options);
  }

  static equals(a: MaxNumTransfers | PlainMessage<MaxNumTransfers> | undefined, b: MaxNumTransfers | PlainMessage<MaxNumTransfers> | undefined): boolean {
    return proto3.util.equals(MaxNumTransfers, a, b);
  }
}

/**
 * ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.
 *
 * @generated from message badges.ApprovalTracker
 */
export class ApprovalTracker extends Message<ApprovalTracker> {
  /**
   * The number of transfers that have been processed.
   *
   * @generated from field: string numTransfers = 1;
   */
  numTransfers = "";

  /**
   * Cumulative balances associated with the transfers that have been processed.
   *
   * @generated from field: repeated badges.Balance amounts = 2;
   */
  amounts: Balance[] = [];

  /**
   * Last updated at time.
   *
   * @generated from field: string lastUpdatedAt = 3;
   */
  lastUpdatedAt = "";

  constructor(data?: PartialMessage<ApprovalTracker>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalTracker";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "numTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amounts", kind: "message", T: Balance, repeated: true },
    { no: 3, name: "lastUpdatedAt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalTracker {
    return new ApprovalTracker().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalTracker {
    return new ApprovalTracker().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalTracker {
    return new ApprovalTracker().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalTracker | PlainMessage<ApprovalTracker> | undefined, b: ApprovalTracker | PlainMessage<ApprovalTracker> | undefined): boolean {
    return proto3.util.equals(ApprovalTracker, a, b);
  }
}

/**
 * @generated from message badges.CoinTransfer
 */
export class CoinTransfer extends Message<CoinTransfer> {
  /**
   * The address of the recipient of the transfer.
   *
   * @generated from field: string to = 1;
   */
  to = "";

  /**
   * The sdk.Coins to be transferred.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin coins = 2;
   */
  coins: Coin[] = [];

  /**
   * By default, the from address is the initiator of the transaction.
   * If this is set to true, we will override the from address with the approver address.
   * Note: This is not applicable for collection approvals (since approverAddress == '').
   *
   * @generated from field: bool overrideFromWithApproverAddress = 3;
   */
  overrideFromWithApproverAddress = false;

  /**
   * By default, the to address is what is specified in the coin transfer.
   * If this is set to true, we will override the to address with the initiator of the transaction.
   *
   * @generated from field: bool overrideToWithInitiator = 4;
   */
  overrideToWithInitiator = false;

  constructor(data?: PartialMessage<CoinTransfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CoinTransfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "coins", kind: "message", T: Coin, repeated: true },
    { no: 3, name: "overrideFromWithApproverAddress", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "overrideToWithInitiator", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CoinTransfer {
    return new CoinTransfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CoinTransfer {
    return new CoinTransfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CoinTransfer {
    return new CoinTransfer().fromJsonString(jsonString, options);
  }

  static equals(a: CoinTransfer | PlainMessage<CoinTransfer> | undefined, b: CoinTransfer | PlainMessage<CoinTransfer> | undefined): boolean {
    return proto3.util.equals(CoinTransfer, a, b);
  }
}

/**
 *
 * MustOwnTokens represents a condition where a user must own specific tokens
 * to be approved to transfer.
 *
 * - collectionId: The ID of the collection for the tokens that must be owned
 * - amountRange: The range of amounts the user must own (min to max)
 * - ownershipTimes: The time ranges during which the user must own the tokens.
 * - tokenIds: The token IDs the user must own.
 * - overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.
 * - mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for >= 1 millisecond is sufficient.
 *
 * @generated from message badges.MustOwnTokens
 */
export class MustOwnTokens extends Message<MustOwnTokens> {
  /**
   * The ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  /**
   * The range of amounts the user must own (min to max).
   *
   * @generated from field: badges.UintRange amountRange = 2;
   */
  amountRange?: UintRange;

  /**
   * The time ranges during which the user must own the tokens.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 3;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * The token IDs the user must own.
   *
   * @generated from field: repeated badges.UintRange tokenIds = 4;
   */
  tokenIds: UintRange[] = [];

  /**
   * If true, override ownershipTimes with the current time.
   *
   * @generated from field: bool overrideWithCurrentTime = 5;
   */
  overrideWithCurrentTime = false;

  /**
   * If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.
   *
   * @generated from field: bool mustSatisfyForAllAssets = 6;
   */
  mustSatisfyForAllAssets = false;

  /**
   * The party to check ownership for. Options are "initiator", "sender", or "recipient". Defaults to "initiator" if empty.
   *
   * @generated from field: string ownershipCheckParty = 7;
   */
  ownershipCheckParty = "";

  constructor(data?: PartialMessage<MustOwnTokens>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MustOwnTokens";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amountRange", kind: "message", T: UintRange },
    { no: 3, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "tokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "overrideWithCurrentTime", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "mustSatisfyForAllAssets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "ownershipCheckParty", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MustOwnTokens {
    return new MustOwnTokens().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MustOwnTokens {
    return new MustOwnTokens().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MustOwnTokens {
    return new MustOwnTokens().fromJsonString(jsonString, options);
  }

  static equals(a: MustOwnTokens | PlainMessage<MustOwnTokens> | undefined, b: MustOwnTokens | PlainMessage<MustOwnTokens> | undefined): boolean {
    return proto3.util.equals(MustOwnTokens, a, b);
  }
}

/**
 * DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.
 *
 * @generated from message badges.DynamicStoreChallenge
 */
export class DynamicStoreChallenge extends Message<DynamicStoreChallenge> {
  /**
   * The ID of the dynamic store to check.
   *
   * @generated from field: string storeId = 1;
   */
  storeId = "";

  constructor(data?: PartialMessage<DynamicStoreChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.DynamicStoreChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamicStoreChallenge {
    return new DynamicStoreChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamicStoreChallenge {
    return new DynamicStoreChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamicStoreChallenge {
    return new DynamicStoreChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: DynamicStoreChallenge | PlainMessage<DynamicStoreChallenge> | undefined, b: DynamicStoreChallenge | PlainMessage<DynamicStoreChallenge> | undefined): boolean {
    return proto3.util.equals(DynamicStoreChallenge, a, b);
  }
}

/**
 * ApprovalCriteria defines the criteria for approving transfers.
 *
 * @generated from message badges.ApprovalCriteria
 */
export class ApprovalCriteria extends Message<ApprovalCriteria> {
  /**
   * Merkle challenge that must be satisfied for approval.
   *
   * @generated from field: repeated badges.MerkleChallenge merkleChallenges = 1;
   */
  merkleChallenges: MerkleChallenge[] = [];

  /**
   * Predetermined balances for eeach approval.
   *
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 2;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * Threshold limit of amounts that can be transferred using this approval.
   *
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 3;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * Maximum number of transfers that can be processed using this approval.
   *
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 4;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * The sdk.Coins that need to be transferred for approval.
   *
   * @generated from field: repeated badges.CoinTransfer coinTransfers = 5;
   */
  coinTransfers: CoinTransfer[] = [];

  /**
   * Require the "to" address to be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireToEqualsInitiatedBy = 6;
   */
  requireToEqualsInitiatedBy = false;

  /**
   * Require the "from" address to be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireFromEqualsInitiatedBy = 7;
   */
  requireFromEqualsInitiatedBy = false;

  /**
   * Require the "to" address to not be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireToDoesNotEqualInitiatedBy = 8;
   */
  requireToDoesNotEqualInitiatedBy = false;

  /**
   * Require the "from" address to not be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireFromDoesNotEqualInitiatedBy = 9;
   */
  requireFromDoesNotEqualInitiatedBy = false;

  /**
   * Overrides the user's outgoing approvals for approval.
   *
   * @generated from field: bool overridesFromOutgoingApprovals = 10;
   */
  overridesFromOutgoingApprovals = false;

  /**
   * Overrides the user's incoming approvals for approval.
   *
   * @generated from field: bool overridesToIncomingApprovals = 11;
   */
  overridesToIncomingApprovals = false;

  /**
   * Auto-deletion options.
   *
   * @generated from field: badges.AutoDeletionOptions autoDeletionOptions = 12;
   */
  autoDeletionOptions?: AutoDeletionOptions;

  /**
   * User level royalties to apply to the transfer.
   *
   * @generated from field: badges.UserRoyalties userRoyalties = 13;
   */
  userRoyalties?: UserRoyalties;

  /**
   * Must own tokens for approval.
   *
   * @generated from field: repeated badges.MustOwnTokens mustOwnTokens = 14;
   */
  mustOwnTokens: MustOwnTokens[] = [];

  /**
   * Dynamic store challenges that the initiator must pass for approval.
   *
   * @generated from field: repeated badges.DynamicStoreChallenge dynamicStoreChallenges = 15;
   */
  dynamicStoreChallenges: DynamicStoreChallenge[] = [];

  /**
   * ETH signature challenges that the initiator must pass for approval.
   *
   * @generated from field: repeated badges.ETHSignatureChallenge ethSignatureChallenges = 16;
   */
  ethSignatureChallenges: ETHSignatureChallenge[] = [];

  constructor(data?: PartialMessage<ApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "merkleChallenges", kind: "message", T: MerkleChallenge, repeated: true },
    { no: 2, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 3, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 4, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 5, name: "coinTransfers", kind: "message", T: CoinTransfer, repeated: true },
    { no: 6, name: "requireToEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "requireFromEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "requireToDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "requireFromDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "overridesFromOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "overridesToIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "autoDeletionOptions", kind: "message", T: AutoDeletionOptions },
    { no: 13, name: "userRoyalties", kind: "message", T: UserRoyalties },
    { no: 14, name: "mustOwnTokens", kind: "message", T: MustOwnTokens, repeated: true },
    { no: 15, name: "dynamicStoreChallenges", kind: "message", T: DynamicStoreChallenge, repeated: true },
    { no: 16, name: "ethSignatureChallenges", kind: "message", T: ETHSignatureChallenge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalCriteria | PlainMessage<ApprovalCriteria> | undefined, b: ApprovalCriteria | PlainMessage<ApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(ApprovalCriteria, a, b);
  }
}

/**
 * UserRoyalties defines the royalties for a user.
 *
 * @generated from message badges.UserRoyalties
 */
export class UserRoyalties extends Message<UserRoyalties> {
  /**
   * Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.
   *
   * @generated from field: string percentage = 1;
   */
  percentage = "";

  /**
   * Payout address for the royalties.
   *
   * @generated from field: string payoutAddress = 2;
   */
  payoutAddress = "";

  constructor(data?: PartialMessage<UserRoyalties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserRoyalties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "percentage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payoutAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserRoyalties {
    return new UserRoyalties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserRoyalties {
    return new UserRoyalties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserRoyalties {
    return new UserRoyalties().fromJsonString(jsonString, options);
  }

  static equals(a: UserRoyalties | PlainMessage<UserRoyalties> | undefined, b: UserRoyalties | PlainMessage<UserRoyalties> | undefined): boolean {
    return proto3.util.equals(UserRoyalties, a, b);
  }
}

/**
 * OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
 *
 * @generated from message badges.OutgoingApprovalCriteria
 */
export class OutgoingApprovalCriteria extends Message<OutgoingApprovalCriteria> {
  /**
   * Merkle challenge that must be satisfied for approval.
   *
   * @generated from field: repeated badges.MerkleChallenge merkleChallenges = 1;
   */
  merkleChallenges: MerkleChallenge[] = [];

  /**
   * Predetermined balances for eeach approval.
   *
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 2;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * Threshold limit of amounts that can be transferred using this approval.
   *
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 3;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * Maximum number of transfers that can be processed using this approval.
   *
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 4;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * The sdk.Coins that need to be transferred for approval.
   *
   * @generated from field: repeated badges.CoinTransfer coinTransfers = 5;
   */
  coinTransfers: CoinTransfer[] = [];

  /**
   * Require the "to" address to be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireToEqualsInitiatedBy = 6;
   */
  requireToEqualsInitiatedBy = false;

  /**
   * Require the "to" address to not be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireToDoesNotEqualInitiatedBy = 7;
   */
  requireToDoesNotEqualInitiatedBy = false;

  /**
   * Auto-deletion options.
   *
   * @generated from field: badges.AutoDeletionOptions autoDeletionOptions = 8;
   */
  autoDeletionOptions?: AutoDeletionOptions;

  /**
   * Must own tokens for approval.
   *
   * @generated from field: repeated badges.MustOwnTokens mustOwnTokens = 9;
   */
  mustOwnTokens: MustOwnTokens[] = [];

  /**
   * Dynamic store challenges that the initiator must pass for approval.
   *
   * @generated from field: repeated badges.DynamicStoreChallenge dynamicStoreChallenges = 10;
   */
  dynamicStoreChallenges: DynamicStoreChallenge[] = [];

  /**
   * ETH signature challenges that the initiator must pass for approval.
   *
   * @generated from field: repeated badges.ETHSignatureChallenge ethSignatureChallenges = 11;
   */
  ethSignatureChallenges: ETHSignatureChallenge[] = [];

  constructor(data?: PartialMessage<OutgoingApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.OutgoingApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "merkleChallenges", kind: "message", T: MerkleChallenge, repeated: true },
    { no: 2, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 3, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 4, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 5, name: "coinTransfers", kind: "message", T: CoinTransfer, repeated: true },
    { no: 6, name: "requireToEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "requireToDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "autoDeletionOptions", kind: "message", T: AutoDeletionOptions },
    { no: 9, name: "mustOwnTokens", kind: "message", T: MustOwnTokens, repeated: true },
    { no: 10, name: "dynamicStoreChallenges", kind: "message", T: DynamicStoreChallenge, repeated: true },
    { no: 11, name: "ethSignatureChallenges", kind: "message", T: ETHSignatureChallenge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: OutgoingApprovalCriteria | PlainMessage<OutgoingApprovalCriteria> | undefined, b: OutgoingApprovalCriteria | PlainMessage<OutgoingApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(OutgoingApprovalCriteria, a, b);
  }
}

/**
 * IncomingApprovalCriteria defines the criteria for approving incoming transfers.
 *
 * @generated from message badges.IncomingApprovalCriteria
 */
export class IncomingApprovalCriteria extends Message<IncomingApprovalCriteria> {
  /**
   * Merkle challenge that must be satisfied for approval.
   *
   * @generated from field: repeated badges.MerkleChallenge merkleChallenges = 1;
   */
  merkleChallenges: MerkleChallenge[] = [];

  /**
   * Predetermined balances for eeach approval.
   *
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 2;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * Threshold limit of amounts that can be transferred using this approval.
   *
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 3;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * Maximum number of transfers that can be processed using this approval.
   *
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 4;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * The sdk.Coins that need to be transferred for approval.
   *
   * @generated from field: repeated badges.CoinTransfer coinTransfers = 5;
   */
  coinTransfers: CoinTransfer[] = [];

  /**
   * Require the "from" address to be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireFromEqualsInitiatedBy = 6;
   */
  requireFromEqualsInitiatedBy = false;

  /**
   * Require the "from" address to not be equal to the "initiated by" address for approval.
   *
   * @generated from field: bool requireFromDoesNotEqualInitiatedBy = 7;
   */
  requireFromDoesNotEqualInitiatedBy = false;

  /**
   * Auto-deletion options.
   *
   * @generated from field: badges.AutoDeletionOptions autoDeletionOptions = 8;
   */
  autoDeletionOptions?: AutoDeletionOptions;

  /**
   * Must own tokens for approval.
   *
   * @generated from field: repeated badges.MustOwnTokens mustOwnTokens = 9;
   */
  mustOwnTokens: MustOwnTokens[] = [];

  /**
   * Dynamic store challenges that the initiator must pass for approval.
   *
   * @generated from field: repeated badges.DynamicStoreChallenge dynamicStoreChallenges = 10;
   */
  dynamicStoreChallenges: DynamicStoreChallenge[] = [];

  /**
   * ETH signature challenges that the initiator must pass for approval.
   *
   * @generated from field: repeated badges.ETHSignatureChallenge ethSignatureChallenges = 11;
   */
  ethSignatureChallenges: ETHSignatureChallenge[] = [];

  constructor(data?: PartialMessage<IncomingApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.IncomingApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "merkleChallenges", kind: "message", T: MerkleChallenge, repeated: true },
    { no: 2, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 3, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 4, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 5, name: "coinTransfers", kind: "message", T: CoinTransfer, repeated: true },
    { no: 6, name: "requireFromEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "requireFromDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "autoDeletionOptions", kind: "message", T: AutoDeletionOptions },
    { no: 9, name: "mustOwnTokens", kind: "message", T: MustOwnTokens, repeated: true },
    { no: 10, name: "dynamicStoreChallenges", kind: "message", T: DynamicStoreChallenge, repeated: true },
    { no: 11, name: "ethSignatureChallenges", kind: "message", T: ETHSignatureChallenge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: IncomingApprovalCriteria | PlainMessage<IncomingApprovalCriteria> | undefined, b: IncomingApprovalCriteria | PlainMessage<IncomingApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(IncomingApprovalCriteria, a, b);
  }
}

/**
 * CollectionApproval defines the rules for the approval of a transfer on the collection level
 *
 * @generated from message badges.CollectionApproval
 */
export class CollectionApproval extends Message<CollectionApproval> {
  /**
   * The list ID for the sender of the transfer.
   *
   * @generated from field: string fromListId = 1;
   */
  fromListId = "";

  /**
   * The list ID for the recipient of the transfer.
   *
   * @generated from field: string toListId = 2;
   */
  toListId = "";

  /**
   * The list ID for the user who initiated the transfer.
   *
   * @generated from field: string initiatedByListId = 3;
   */
  initiatedByListId = "";

  /**
   * The allowed range of transfer times for approval.
   *
   * @generated from field: repeated badges.UintRange transferTimes = 4;
   */
  transferTimes: UintRange[] = [];

  /**
   * The allowed range of token IDs for approval.
   *
   * @generated from field: repeated badges.UintRange tokenIds = 5;
   */
  tokenIds: UintRange[] = [];

  /**
   * The allowed range of ownership times for approval.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 6;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * The URI associated with this approval, optionally providing metadata about the approval.
   *
   * @generated from field: string uri = 9;
   */
  uri = "";

  /**
   * Arbitrary custom data associated with this approval.
   *
   * @generated from field: string customData = 10;
   */
  customData = "";

  /**
   * The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
   *
   * @generated from field: string approvalId = 11;
   */
  approvalId = "";

  /**
   * The criteria that must be met for this approval to be considered.
   *
   * @generated from field: badges.ApprovalCriteria approvalCriteria = 12;
   */
  approvalCriteria?: ApprovalCriteria;

  /**
   * Version of the approval. Maintained internally.
   *
   * @generated from field: string version = 13;
   */
  version = "";

  constructor(data?: PartialMessage<CollectionApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CollectionApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fromListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "initiatedByListId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "transferTimes", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "tokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 9, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "approvalCriteria", kind: "message", T: ApprovalCriteria },
    { no: 13, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionApproval {
    return new CollectionApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionApproval {
    return new CollectionApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionApproval {
    return new CollectionApproval().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionApproval | PlainMessage<CollectionApproval> | undefined, b: CollectionApproval | PlainMessage<CollectionApproval> | undefined): boolean {
    return proto3.util.equals(CollectionApproval, a, b);
  }
}

/**
 * ApprovalIdentifierDetails defines the details to identify a specific approval.
 *
 * @generated from message badges.ApprovalIdentifierDetails
 */
export class ApprovalIdentifierDetails extends Message<ApprovalIdentifierDetails> {
  /**
   * The ID of the approval.
   *
   * @generated from field: string approvalId = 1;
   */
  approvalId = "";

  /**
   * The level of the approval. Can be "collection", "incoming", or "outgoing".
   *
   * @generated from field: string approvalLevel = 2;
   */
  approvalLevel = "";

  /**
   * The address of the approver. Leave blank "" if approvalLevel == "collection".
   *
   * @generated from field: string approverAddress = 3;
   */
  approverAddress = "";

  /**
   * The version of the approval.
   *
   * @generated from field: string version = 4;
   */
  version = "";

  constructor(data?: PartialMessage<ApprovalIdentifierDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalIdentifierDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "approvalLevel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approverAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalIdentifierDetails {
    return new ApprovalIdentifierDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalIdentifierDetails {
    return new ApprovalIdentifierDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalIdentifierDetails {
    return new ApprovalIdentifierDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalIdentifierDetails | PlainMessage<ApprovalIdentifierDetails> | undefined, b: ApprovalIdentifierDetails | PlainMessage<ApprovalIdentifierDetails> | undefined): boolean {
    return proto3.util.equals(ApprovalIdentifierDetails, a, b);
  }
}

/**
 * Transfer defines the details of a transfer of tokens.
 *
 * @generated from message badges.Transfer
 */
export class Transfer extends Message<Transfer> {
  /**
   * The address of the sender of the transfer.
   *
   * @generated from field: string from = 1;
   */
  from = "";

  /**
   * The addresses of the recipients of the transfer.
   *
   * @generated from field: repeated string toAddresses = 2;
   */
  toAddresses: string[] = [];

  /**
   * The balances to be transferred.
   *
   * @generated from field: repeated badges.Balance balances = 3;
   */
  balances: Balance[] = [];

  /**
   * If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
   * We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
   *
   * @generated from field: badges.ApprovalIdentifierDetails precalculateBalancesFromApproval = 4;
   */
  precalculateBalancesFromApproval?: ApprovalIdentifierDetails;

  /**
   * The Merkle proofs / solutions for all Merkle challenges required for the transfer.
   *
   * @generated from field: repeated badges.MerkleProof merkleProofs = 5;
   */
  merkleProofs: MerkleProof[] = [];

  /**
   * The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.
   *
   * @generated from field: repeated badges.ETHSignatureProof ethSignatureProofs = 6;
   */
  ethSignatureProofs: ETHSignatureProof[] = [];

  /**
   * The memo for the transfer.
   *
   * @generated from field: string memo = 7;
   */
  memo = "";

  /**
   * The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
   * This field can be used to prioritize specific approvals and scan through them first.
   *
   * @generated from field: repeated badges.ApprovalIdentifierDetails prioritizedApprovals = 8;
   */
  prioritizedApprovals: ApprovalIdentifierDetails[] = [];

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedCollectionApprovals = 9;
   */
  onlyCheckPrioritizedCollectionApprovals = false;

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedIncomingApprovals = 10;
   */
  onlyCheckPrioritizedIncomingApprovals = false;

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedOutgoingApprovals = 11;
   */
  onlyCheckPrioritizedOutgoingApprovals = false;

  /**
   * The options for precalculating the balances.
   *
   * @generated from field: badges.PrecalculationOptions precalculationOptions = 12;
   */
  precalculationOptions?: PrecalculationOptions;

  /**
   * Affiliate address for the transfer.
   *
   * @generated from field: string affiliateAddress = 13;
   */
  affiliateAddress = "";

  /**
   * The number of times to attempt approval validation. If 0 / not specified, we default to only one.
   *
   * @generated from field: string numAttempts = 14;
   */
  numAttempts = "";

  constructor(data?: PartialMessage<Transfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.Transfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toAddresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 4, name: "precalculateBalancesFromApproval", kind: "message", T: ApprovalIdentifierDetails },
    { no: 5, name: "merkleProofs", kind: "message", T: MerkleProof, repeated: true },
    { no: 6, name: "ethSignatureProofs", kind: "message", T: ETHSignatureProof, repeated: true },
    { no: 7, name: "memo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "prioritizedApprovals", kind: "message", T: ApprovalIdentifierDetails, repeated: true },
    { no: 9, name: "onlyCheckPrioritizedCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "onlyCheckPrioritizedIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "onlyCheckPrioritizedOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "precalculationOptions", kind: "message", T: PrecalculationOptions },
    { no: 13, name: "affiliateAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "numAttempts", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transfer {
    return new Transfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJsonString(jsonString, options);
  }

  static equals(a: Transfer | PlainMessage<Transfer> | undefined, b: Transfer | PlainMessage<Transfer> | undefined): boolean {
    return proto3.util.equals(Transfer, a, b);
  }
}

/**
 * PrecalculationOptions defines the options for precalculating the balances.
 *
 * @generated from message badges.PrecalculationOptions
 */
export class PrecalculationOptions extends Message<PrecalculationOptions> {
  /**
   * The timestamp to override with when calculating the balances.
   *
   * @generated from field: string overrideTimestamp = 1;
   */
  overrideTimestamp = "";

  /**
   * The IDs to override for the transfer. Only applicable if using this option in precalculation.
   *
   * @generated from field: repeated badges.UintRange tokenIdsOverride = 2;
   */
  tokenIdsOverride: UintRange[] = [];

  constructor(data?: PartialMessage<PrecalculationOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PrecalculationOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overrideTimestamp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tokenIdsOverride", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrecalculationOptions {
    return new PrecalculationOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrecalculationOptions {
    return new PrecalculationOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrecalculationOptions {
    return new PrecalculationOptions().fromJsonString(jsonString, options);
  }

  static equals(a: PrecalculationOptions | PlainMessage<PrecalculationOptions> | undefined, b: PrecalculationOptions | PlainMessage<PrecalculationOptions> | undefined): boolean {
    return proto3.util.equals(PrecalculationOptions, a, b);
  }
}

/**
 * MerklePathItem represents an item in a Merkle path.
 *
 * @generated from message badges.MerklePathItem
 */
export class MerklePathItem extends Message<MerklePathItem> {
  /**
   * The hash of the sibling node (aunt) in the Merkle path.
   *
   * @generated from field: string aunt = 1;
   */
  aunt = "";

  /**
   * Indicates whether the aunt node is on the right side of the path.
   *
   * @generated from field: bool onRight = 2;
   */
  onRight = false;

  constructor(data?: PartialMessage<MerklePathItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerklePathItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aunt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "onRight", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerklePathItem {
    return new MerklePathItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerklePathItem {
    return new MerklePathItem().fromJsonString(jsonString, options);
  }

  static equals(a: MerklePathItem | PlainMessage<MerklePathItem> | undefined, b: MerklePathItem | PlainMessage<MerklePathItem> | undefined): boolean {
    return proto3.util.equals(MerklePathItem, a, b);
  }
}

/**
 * MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
 *
 * @generated from message badges.MerkleProof
 */
export class MerkleProof extends Message<MerkleProof> {
  /**
   * The hash of the leaf node for which the proof is generated.
   *
   * @generated from field: string leaf = 1;
   */
  leaf = "";

  /**
   * List of Merkle path items (aunts) that make up the proof.
   *
   * @generated from field: repeated badges.MerklePathItem aunts = 2;
   */
  aunts: MerklePathItem[] = [];

  /**
   * The signature of the leaf node tying the address to the leaf node.
   *
   * @generated from field: string leafSignature = 3;
   */
  leafSignature = "";

  constructor(data?: PartialMessage<MerkleProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MerkleProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "leaf", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "aunts", kind: "message", T: MerklePathItem, repeated: true },
    { no: 3, name: "leafSignature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleProof {
    return new MerkleProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleProof {
    return new MerkleProof().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleProof | PlainMessage<MerkleProof> | undefined, b: MerkleProof | PlainMessage<MerkleProof> | undefined): boolean {
    return proto3.util.equals(MerkleProof, a, b);
  }
}

/**
 * ETHSignatureProof represents an Ethereum signature proof for a challenge.
 *
 * @generated from message badges.ETHSignatureProof
 */
export class ETHSignatureProof extends Message<ETHSignatureProof> {
  /**
   * The nonce that was signed. The signature scheme is ETHSign(nonce + "-" + creatorAddress).
   *
   * @generated from field: string nonce = 1;
   */
  nonce = "";

  /**
   * The Ethereum signature of the nonce.
   *
   * @generated from field: string signature = 2;
   */
  signature = "";

  constructor(data?: PartialMessage<ETHSignatureProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ETHSignatureProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ETHSignatureProof {
    return new ETHSignatureProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ETHSignatureProof {
    return new ETHSignatureProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ETHSignatureProof {
    return new ETHSignatureProof().fromJsonString(jsonString, options);
  }

  static equals(a: ETHSignatureProof | PlainMessage<ETHSignatureProof> | undefined, b: ETHSignatureProof | PlainMessage<ETHSignatureProof> | undefined): boolean {
    return proto3.util.equals(ETHSignatureProof, a, b);
  }
}

