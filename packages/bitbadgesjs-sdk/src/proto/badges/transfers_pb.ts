// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file badges/transfers.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Balance, UintRange } from "./balances_pb.js";
import { ApprovalIdentifierDetails } from "./approvals_pb.js";
import { ETHSignatureProof, MerkleProof } from "./challenges_pb.js";

/**
 * Transfer defines the details of a transfer of tokens.
 *
 * @generated from message badges.Transfer
 */
export class Transfer extends Message<Transfer> {
  /**
   * The address of the sender of the transfer.
   *
   * @generated from field: string from = 1;
   */
  from = "";

  /**
   * The addresses of the recipients of the transfer.
   *
   * @generated from field: repeated string toAddresses = 2;
   */
  toAddresses: string[] = [];

  /**
   * The balances to be transferred.
   *
   * @generated from field: repeated badges.Balance balances = 3;
   */
  balances: Balance[] = [];

  /**
   * If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
   * We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
   *
   * @generated from field: badges.ApprovalIdentifierDetails precalculateBalancesFromApproval = 4;
   */
  precalculateBalancesFromApproval?: ApprovalIdentifierDetails;

  /**
   * The Merkle proofs / solutions for all Merkle challenges required for the transfer.
   *
   * @generated from field: repeated badges.MerkleProof merkleProofs = 5;
   */
  merkleProofs: MerkleProof[] = [];

  /**
   * The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.
   *
   * @generated from field: repeated badges.ETHSignatureProof ethSignatureProofs = 6;
   */
  ethSignatureProofs: ETHSignatureProof[] = [];

  /**
   * The memo for the transfer.
   *
   * @generated from field: string memo = 7;
   */
  memo = "";

  /**
   * The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
   * This field can be used to prioritize specific approvals and scan through them first.
   *
   * @generated from field: repeated badges.ApprovalIdentifierDetails prioritizedApprovals = 8;
   */
  prioritizedApprovals: ApprovalIdentifierDetails[] = [];

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedCollectionApprovals = 9;
   */
  onlyCheckPrioritizedCollectionApprovals = false;

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedIncomingApprovals = 10;
   */
  onlyCheckPrioritizedIncomingApprovals = false;

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedOutgoingApprovals = 11;
   */
  onlyCheckPrioritizedOutgoingApprovals = false;

  /**
   * The options for precalculating the balances.
   *
   * @generated from field: badges.PrecalculationOptions precalculationOptions = 12;
   */
  precalculationOptions?: PrecalculationOptions;

  constructor(data?: PartialMessage<Transfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.Transfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toAddresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 4, name: "precalculateBalancesFromApproval", kind: "message", T: ApprovalIdentifierDetails },
    { no: 5, name: "merkleProofs", kind: "message", T: MerkleProof, repeated: true },
    { no: 6, name: "ethSignatureProofs", kind: "message", T: ETHSignatureProof, repeated: true },
    { no: 7, name: "memo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "prioritizedApprovals", kind: "message", T: ApprovalIdentifierDetails, repeated: true },
    { no: 9, name: "onlyCheckPrioritizedCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "onlyCheckPrioritizedIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "onlyCheckPrioritizedOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "precalculationOptions", kind: "message", T: PrecalculationOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transfer {
    return new Transfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJsonString(jsonString, options);
  }

  static equals(a: Transfer | PlainMessage<Transfer> | undefined, b: Transfer | PlainMessage<Transfer> | undefined): boolean {
    return proto3.util.equals(Transfer, a, b);
  }
}

/**
 * PrecalculationOptions defines the options for precalculating the balances.
 *
 * @generated from message badges.PrecalculationOptions
 */
export class PrecalculationOptions extends Message<PrecalculationOptions> {
  /**
   * The timestamp to override with when calculating the balances.
   *
   * @generated from field: string overrideTimestamp = 1;
   */
  overrideTimestamp = "";

  /**
   * The IDs to override for the transfer. Only applicable if using this option in precalculation.
   *
   * @generated from field: repeated badges.UintRange tokenIdsOverride = 2;
   */
  tokenIdsOverride: UintRange[] = [];

  constructor(data?: PartialMessage<PrecalculationOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PrecalculationOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overrideTimestamp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tokenIdsOverride", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrecalculationOptions {
    return new PrecalculationOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrecalculationOptions {
    return new PrecalculationOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrecalculationOptions {
    return new PrecalculationOptions().fromJsonString(jsonString, options);
  }

  static equals(a: PrecalculationOptions | PlainMessage<PrecalculationOptions> | undefined, b: PrecalculationOptions | PlainMessage<PrecalculationOptions> | undefined): boolean {
    return proto3.util.equals(PrecalculationOptions, a, b);
  }
}

