// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file badges/predetermined_balances.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Balance } from "./balances_pb.js";

/**
 * ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set. 
 *
 * @generated from message badges.ManualBalances
 */
export class ManualBalances extends Message<ManualBalances> {
  /**
   * @generated from field: repeated badges.Balance balances = 1;
   */
  balances: Balance[] = [];

  constructor(data?: PartialMessage<ManualBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ManualBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balances", kind: "message", T: Balance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ManualBalances {
    return new ManualBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ManualBalances {
    return new ManualBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ManualBalances {
    return new ManualBalances().fromJsonString(jsonString, options);
  }

  static equals(a: ManualBalances | PlainMessage<ManualBalances> | undefined, b: ManualBalances | PlainMessage<ManualBalances> | undefined): boolean {
    return proto3.util.equals(ManualBalances, a, b);
  }
}

/**
 * RecurringOwnershipTimes represents a list of recurring ownership times.
 *
 * @generated from message badges.RecurringOwnershipTimes
 */
export class RecurringOwnershipTimes extends Message<RecurringOwnershipTimes> {
  /**
   * The original start time of the first interval.
   *
   * @generated from field: string startTime = 1;
   */
  startTime = "";

  /**
   * The interval length in unix milliseconds.
   *
   * @generated from field: string intervalLength = 2;
   */
  intervalLength = "";

  /**
   * Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period
   *
   * @generated from field: string chargePeriodLength = 3;
   */
  chargePeriodLength = "";

  constructor(data?: PartialMessage<RecurringOwnershipTimes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.RecurringOwnershipTimes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "startTime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "intervalLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chargePeriodLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecurringOwnershipTimes {
    return new RecurringOwnershipTimes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecurringOwnershipTimes {
    return new RecurringOwnershipTimes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecurringOwnershipTimes {
    return new RecurringOwnershipTimes().fromJsonString(jsonString, options);
  }

  static equals(a: RecurringOwnershipTimes | PlainMessage<RecurringOwnershipTimes> | undefined, b: RecurringOwnershipTimes | PlainMessage<RecurringOwnershipTimes> | undefined): boolean {
    return proto3.util.equals(RecurringOwnershipTimes, a, b);
  }
}

/**
 * IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.
 *
 * @generated from message badges.IncrementedBalances
 */
export class IncrementedBalances extends Message<IncrementedBalances> {
  /**
   * @generated from field: repeated badges.Balance startBalances = 1;
   */
  startBalances: Balance[] = [];

  /**
   * The amount by which to increment token IDs.
   *
   * @generated from field: string incrementTokenIdsBy = 2;
   */
  incrementTokenIdsBy = "";

  /**
   * The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.
   *
   * @generated from field: string incrementOwnershipTimesBy = 3;
   */
  incrementOwnershipTimesBy = "";

  /**
   * The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.
   *
   * @generated from field: string durationFromTimestamp = 4;
   */
  durationFromTimestamp = "";

  /**
   * Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).
   *
   * @generated from field: bool allowOverrideTimestamp = 5;
   */
  allowOverrideTimestamp = false;

  /**
   * Recurring ownership times.
   *
   * @generated from field: badges.RecurringOwnershipTimes recurringOwnershipTimes = 6;
   */
  recurringOwnershipTimes?: RecurringOwnershipTimes;

  /**
   * Allow override of any valid ID
   *
   * @generated from field: bool allowOverrideWithAnyValidToken = 7;
   */
  allowOverrideWithAnyValidToken = false;

  constructor(data?: PartialMessage<IncrementedBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.IncrementedBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "startBalances", kind: "message", T: Balance, repeated: true },
    { no: 2, name: "incrementTokenIdsBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "incrementOwnershipTimesBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "durationFromTimestamp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "allowOverrideTimestamp", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "recurringOwnershipTimes", kind: "message", T: RecurringOwnershipTimes },
    { no: 7, name: "allowOverrideWithAnyValidToken", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IncrementedBalances {
    return new IncrementedBalances().fromJsonString(jsonString, options);
  }

  static equals(a: IncrementedBalances | PlainMessage<IncrementedBalances> | undefined, b: IncrementedBalances | PlainMessage<IncrementedBalances> | undefined): boolean {
    return proto3.util.equals(IncrementedBalances, a, b);
  }
}

/**
 * PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.
 *
 * @generated from message badges.PredeterminedOrderCalculationMethod
 */
export class PredeterminedOrderCalculationMethod extends Message<PredeterminedOrderCalculationMethod> {
  /**
   * Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.
   *
   * @generated from field: bool useOverallNumTransfers = 1;
   */
  useOverallNumTransfers = false;

  /**
   * Use the number of transfers per "to" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.
   *
   * @generated from field: bool usePerToAddressNumTransfers = 2;
   */
  usePerToAddressNumTransfers = false;

  /**
   * Use the number of transfers per "from" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.
   *
   * @generated from field: bool usePerFromAddressNumTransfers = 3;
   */
  usePerFromAddressNumTransfers = false;

  /**
   * Use the number of transfers per "initiated by" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.
   *
   * @generated from field: bool usePerInitiatedByAddressNumTransfers = 4;
   */
  usePerInitiatedByAddressNumTransfers = false;

  /**
   * Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.
   *
   * @generated from field: bool useMerkleChallengeLeafIndex = 5;
   */
  useMerkleChallengeLeafIndex = false;

  /**
   * If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.
   *
   * @generated from field: string challengeTrackerId = 6;
   */
  challengeTrackerId = "";

  constructor(data?: PartialMessage<PredeterminedOrderCalculationMethod>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PredeterminedOrderCalculationMethod";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "useOverallNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "usePerToAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "usePerFromAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "usePerInitiatedByAddressNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "useMerkleChallengeLeafIndex", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "challengeTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredeterminedOrderCalculationMethod {
    return new PredeterminedOrderCalculationMethod().fromJsonString(jsonString, options);
  }

  static equals(a: PredeterminedOrderCalculationMethod | PlainMessage<PredeterminedOrderCalculationMethod> | undefined, b: PredeterminedOrderCalculationMethod | PlainMessage<PredeterminedOrderCalculationMethod> | undefined): boolean {
    return proto3.util.equals(PredeterminedOrderCalculationMethod, a, b);
  }
}

/**
 * PredeterminedBalances represents balances with predetermined order calculation.
 *
 * @generated from message badges.PredeterminedBalances
 */
export class PredeterminedBalances extends Message<PredeterminedBalances> {
  /**
   * Manual balances that can be entered. If this is nil, then we use the incremented balances.
   *
   * @generated from field: repeated badges.ManualBalances manualBalances = 1;
   */
  manualBalances: ManualBalances[] = [];

  /**
   * Balances that have a starting amount and increment. If this is nil, then we use the manual balances.
   *
   * @generated from field: badges.IncrementedBalances incrementedBalances = 2;
   */
  incrementedBalances?: IncrementedBalances;

  /**
   * The method to calculate the order of predetermined balances.
   *
   * @generated from field: badges.PredeterminedOrderCalculationMethod orderCalculationMethod = 3;
   */
  orderCalculationMethod?: PredeterminedOrderCalculationMethod;

  constructor(data?: PartialMessage<PredeterminedBalances>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.PredeterminedBalances";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "manualBalances", kind: "message", T: ManualBalances, repeated: true },
    { no: 2, name: "incrementedBalances", kind: "message", T: IncrementedBalances },
    { no: 3, name: "orderCalculationMethod", kind: "message", T: PredeterminedOrderCalculationMethod },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredeterminedBalances {
    return new PredeterminedBalances().fromJsonString(jsonString, options);
  }

  static equals(a: PredeterminedBalances | PlainMessage<PredeterminedBalances> | undefined, b: PredeterminedBalances | PlainMessage<PredeterminedBalances> | undefined): boolean {
    return proto3.util.equals(PredeterminedBalances, a, b);
  }
}

