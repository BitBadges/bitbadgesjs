// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file badges/approval_tracking.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Balance } from "./balances_pb.js";

/**
 * AutoDeletionOptions defines the options for auto-deletion of approvals.
 *
 * @generated from message badges.AutoDeletionOptions
 */
export class AutoDeletionOptions extends Message<AutoDeletionOptions> {
  /**
   * After one use?
   *
   * @generated from field: bool afterOneUse = 1;
   */
  afterOneUse = false;

  /**
   * After overall max number of uses threshold is met?
   *
   * @generated from field: bool afterOverallMaxNumTransfers = 2;
   */
  afterOverallMaxNumTransfers = false;

  /**
   * Allow counterparty to purge this approval if they are the only initiator
   *
   * @generated from field: bool allowCounterpartyPurge = 3;
   */
  allowCounterpartyPurge = false;

  /**
   * Allow others to call PurgeApprovals on behalf of this approval owner
   *
   * @generated from field: bool allowPurgeIfExpired = 4;
   */
  allowPurgeIfExpired = false;

  constructor(data?: PartialMessage<AutoDeletionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.AutoDeletionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "afterOneUse", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "afterOverallMaxNumTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "allowCounterpartyPurge", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "allowPurgeIfExpired", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AutoDeletionOptions {
    return new AutoDeletionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AutoDeletionOptions {
    return new AutoDeletionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AutoDeletionOptions {
    return new AutoDeletionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: AutoDeletionOptions | PlainMessage<AutoDeletionOptions> | undefined, b: AutoDeletionOptions | PlainMessage<AutoDeletionOptions> | undefined): boolean {
    return proto3.util.equals(AutoDeletionOptions, a, b);
  }
}

/**
 * Time intervals to reset the trackers at.
 *
 * @generated from message badges.ResetTimeIntervals
 */
export class ResetTimeIntervals extends Message<ResetTimeIntervals> {
  /**
   * Original start time of the first interval.
   *
   * @generated from field: string startTime = 1;
   */
  startTime = "";

  /**
   * Interval length in unix milliseconds.
   *
   * @generated from field: string intervalLength = 2;
   */
  intervalLength = "";

  constructor(data?: PartialMessage<ResetTimeIntervals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ResetTimeIntervals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "startTime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "intervalLength", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetTimeIntervals {
    return new ResetTimeIntervals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetTimeIntervals {
    return new ResetTimeIntervals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetTimeIntervals {
    return new ResetTimeIntervals().fromJsonString(jsonString, options);
  }

  static equals(a: ResetTimeIntervals | PlainMessage<ResetTimeIntervals> | undefined, b: ResetTimeIntervals | PlainMessage<ResetTimeIntervals> | undefined): boolean {
    return proto3.util.equals(ResetTimeIntervals, a, b);
  }
}

/**
 * ApprovalAmounts defines approval amounts per unique "from," "to," and/or "initiated by" address.
 * If any of these are nil or "0", we assume unlimited approvals.
 * If they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times 
 * must not exceed the corresponding value.
 *
 * @generated from message badges.ApprovalAmounts
 */
export class ApprovalAmounts extends Message<ApprovalAmounts> {
  /**
   * Overall approval amount.
   *
   * @generated from field: string overallApprovalAmount = 1;
   */
  overallApprovalAmount = "";

  /**
   * Approval amount per "to" address.
   *
   * @generated from field: string perToAddressApprovalAmount = 2;
   */
  perToAddressApprovalAmount = "";

  /**
   * Approval amount per "from" address.
   *
   * @generated from field: string perFromAddressApprovalAmount = 3;
   */
  perFromAddressApprovalAmount = "";

  /**
   * Approval amount per "initiated by" address.
   *
   * @generated from field: string perInitiatedByAddressApprovalAmount = 4;
   */
  perInitiatedByAddressApprovalAmount = "";

  /**
   * The ID of the amount tracker associated with this approval.
   * We use this ID to track the number of transfers and amounts transferred.
   *
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * Time intervals to reset the trackers at.
   *
   * @generated from field: badges.ResetTimeIntervals resetTimeIntervals = 7;
   */
  resetTimeIntervals?: ResetTimeIntervals;

  constructor(data?: PartialMessage<ApprovalAmounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalAmounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overallApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "perToAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "perFromAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "perInitiatedByAddressApprovalAmount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "resetTimeIntervals", kind: "message", T: ResetTimeIntervals },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalAmounts {
    return new ApprovalAmounts().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalAmounts | PlainMessage<ApprovalAmounts> | undefined, b: ApprovalAmounts | PlainMessage<ApprovalAmounts> | undefined): boolean {
    return proto3.util.equals(ApprovalAmounts, a, b);
  }
}

/**
 * MaxNumTransfers defines the maximum number of transfers per unique "from," "to," and/or "initiated by" address.
 * If any of these are nil or "0", we assume unlimited approvals.
 * If they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times
 * must not exceed the corresponding value.
 *
 * @generated from message badges.MaxNumTransfers
 */
export class MaxNumTransfers extends Message<MaxNumTransfers> {
  /**
   * Overall maximum number of transfers.
   *
   * @generated from field: string overallMaxNumTransfers = 1;
   */
  overallMaxNumTransfers = "";

  /**
   * Maximum number of transfers per "to" address.
   *
   * @generated from field: string perToAddressMaxNumTransfers = 2;
   */
  perToAddressMaxNumTransfers = "";

  /**
   * Maximum number of transfers per "from" address.
   *
   * @generated from field: string perFromAddressMaxNumTransfers = 3;
   */
  perFromAddressMaxNumTransfers = "";

  /**
   * Maximum number of transfers per "initiated by" address.
   *
   * @generated from field: string perInitiatedByAddressMaxNumTransfers = 4;
   */
  perInitiatedByAddressMaxNumTransfers = "";

  /**
   * The ID of the amount tracker associated with this approval.
   * We use this ID to track the number of transfers and amounts transferred.
   *
   * @generated from field: string amountTrackerId = 6;
   */
  amountTrackerId = "";

  /**
   * Time intervals to reset the trackers at.
   *
   * @generated from field: badges.ResetTimeIntervals resetTimeIntervals = 7;
   */
  resetTimeIntervals?: ResetTimeIntervals;

  constructor(data?: PartialMessage<MaxNumTransfers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MaxNumTransfers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overallMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "perToAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "perFromAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "perInitiatedByAddressMaxNumTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "amountTrackerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "resetTimeIntervals", kind: "message", T: ResetTimeIntervals },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MaxNumTransfers {
    return new MaxNumTransfers().fromJsonString(jsonString, options);
  }

  static equals(a: MaxNumTransfers | PlainMessage<MaxNumTransfers> | undefined, b: MaxNumTransfers | PlainMessage<MaxNumTransfers> | undefined): boolean {
    return proto3.util.equals(MaxNumTransfers, a, b);
  }
}

/**
 * ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.
 *
 * @generated from message badges.ApprovalTracker
 */
export class ApprovalTracker extends Message<ApprovalTracker> {
  /**
   * The number of transfers that have been processed.
   *
   * @generated from field: string numTransfers = 1;
   */
  numTransfers = "";

  /**
   * Cumulative balances associated with the transfers that have been processed.
   *
   * @generated from field: repeated badges.Balance amounts = 2;
   */
  amounts: Balance[] = [];

  /**
   * Last updated at time.
   *
   * @generated from field: string lastUpdatedAt = 3;
   */
  lastUpdatedAt = "";

  constructor(data?: PartialMessage<ApprovalTracker>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalTracker";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "numTransfers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amounts", kind: "message", T: Balance, repeated: true },
    { no: 3, name: "lastUpdatedAt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalTracker {
    return new ApprovalTracker().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalTracker {
    return new ApprovalTracker().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalTracker {
    return new ApprovalTracker().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalTracker | PlainMessage<ApprovalTracker> | undefined, b: ApprovalTracker | PlainMessage<ApprovalTracker> | undefined): boolean {
    return proto3.util.equals(ApprovalTracker, a, b);
  }
}

