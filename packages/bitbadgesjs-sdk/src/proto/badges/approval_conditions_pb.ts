// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file badges/approval_conditions.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Coin } from "../cosmos/base/v1beta1/coin_pb.js";
import { UintRange } from "./balances_pb.js";

/**
 * @generated from message badges.CoinTransfer
 */
export class CoinTransfer extends Message<CoinTransfer> {
  /**
   * The address of the recipient of the transfer.
   *
   * @generated from field: string to = 1;
   */
  to = "";

  /**
   * The sdk.Coins to be transferred.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin coins = 2;
   */
  coins: Coin[] = [];

  /**
   * By default, the from address is the initiator of the transaction.
   * If this is set to true, we will override the from address with the approver address.
   * Note: This is not applicable for collection approvals (since approverAddress == '').
   *
   * @generated from field: bool overrideFromWithApproverAddress = 3;
   */
  overrideFromWithApproverAddress = false;

  /**
   * By default, the to address is what is specified in the coin transfer.
   * If this is set to true, we will override the to address with the initiator of the transaction.
   *
   * @generated from field: bool overrideToWithInitiator = 4;
   */
  overrideToWithInitiator = false;

  constructor(data?: PartialMessage<CoinTransfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CoinTransfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "coins", kind: "message", T: Coin, repeated: true },
    { no: 3, name: "overrideFromWithApproverAddress", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "overrideToWithInitiator", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CoinTransfer {
    return new CoinTransfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CoinTransfer {
    return new CoinTransfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CoinTransfer {
    return new CoinTransfer().fromJsonString(jsonString, options);
  }

  static equals(a: CoinTransfer | PlainMessage<CoinTransfer> | undefined, b: CoinTransfer | PlainMessage<CoinTransfer> | undefined): boolean {
    return proto3.util.equals(CoinTransfer, a, b);
  }
}

/**
 *
 * MustOwnTokens represents a condition where a user must own specific tokens
 * to be approved to transfer.
 *
 * - collectionId: The ID of the collection for the tokens that must be owned
 * - amountRange: The range of amounts the user must own (min to max)
 * - ownershipTimes: The time ranges during which the user must own the tokens.
 * - tokenIds: The token IDs the user must own.
 * - overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.
 * - mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for >= 1 millisecond is sufficient.
 *
 * @generated from message badges.MustOwnTokens
 */
export class MustOwnTokens extends Message<MustOwnTokens> {
  /**
   * The ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  /**
   * The range of amounts the user must own (min to max).
   *
   * @generated from field: badges.UintRange amountRange = 2;
   */
  amountRange?: UintRange;

  /**
   * The time ranges during which the user must own the tokens.
   *
   * @generated from field: repeated badges.UintRange ownershipTimes = 3;
   */
  ownershipTimes: UintRange[] = [];

  /**
   * The token IDs the user must own.
   *
   * @generated from field: repeated badges.UintRange tokenIds = 4;
   */
  tokenIds: UintRange[] = [];

  /**
   * If true, override ownershipTimes with the current time.
   *
   * @generated from field: bool overrideWithCurrentTime = 5;
   */
  overrideWithCurrentTime = false;

  /**
   * If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.
   *
   * @generated from field: bool mustSatisfyForAllAssets = 6;
   */
  mustSatisfyForAllAssets = false;

  /**
   * The party to check ownership for. Options are "initiator", "sender", or "recipient". Defaults to "initiator" if empty.
   *
   * @generated from field: string ownershipCheckParty = 7;
   */
  ownershipCheckParty = "";

  constructor(data?: PartialMessage<MustOwnTokens>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MustOwnTokens";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amountRange", kind: "message", T: UintRange },
    { no: 3, name: "ownershipTimes", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "tokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "overrideWithCurrentTime", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "mustSatisfyForAllAssets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "ownershipCheckParty", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MustOwnTokens {
    return new MustOwnTokens().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MustOwnTokens {
    return new MustOwnTokens().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MustOwnTokens {
    return new MustOwnTokens().fromJsonString(jsonString, options);
  }

  static equals(a: MustOwnTokens | PlainMessage<MustOwnTokens> | undefined, b: MustOwnTokens | PlainMessage<MustOwnTokens> | undefined): boolean {
    return proto3.util.equals(MustOwnTokens, a, b);
  }
}

/**
 * DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.
 *
 * @generated from message badges.DynamicStoreChallenge
 */
export class DynamicStoreChallenge extends Message<DynamicStoreChallenge> {
  /**
   * The ID of the dynamic store to check.
   *
   * @generated from field: string storeId = 1;
   */
  storeId = "";

  constructor(data?: PartialMessage<DynamicStoreChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.DynamicStoreChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamicStoreChallenge {
    return new DynamicStoreChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamicStoreChallenge {
    return new DynamicStoreChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamicStoreChallenge {
    return new DynamicStoreChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: DynamicStoreChallenge | PlainMessage<DynamicStoreChallenge> | undefined, b: DynamicStoreChallenge | PlainMessage<DynamicStoreChallenge> | undefined): boolean {
    return proto3.util.equals(DynamicStoreChallenge, a, b);
  }
}

/**
 * AddressChecks defines checks for address types (WASM contract, liquidity pool, etc.)
 *
 * @generated from message badges.AddressChecks
 */
export class AddressChecks extends Message<AddressChecks> {
  /**
   * Require the address to be a WASM contract.
   *
   * @generated from field: bool mustBeWasmContract = 1;
   */
  mustBeWasmContract = false;

  /**
   * Require the address to not be a WASM contract.
   *
   * @generated from field: bool mustNotBeWasmContract = 2;
   */
  mustNotBeWasmContract = false;

  /**
   * Require the address to be a liquidity pool.
   *
   * @generated from field: bool mustBeLiquidityPool = 3;
   */
  mustBeLiquidityPool = false;

  /**
   * Require the address to not be a liquidity pool.
   *
   * @generated from field: bool mustNotBeLiquidityPool = 4;
   */
  mustNotBeLiquidityPool = false;

  constructor(data?: PartialMessage<AddressChecks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.AddressChecks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mustBeWasmContract", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "mustNotBeWasmContract", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "mustBeLiquidityPool", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "mustNotBeLiquidityPool", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddressChecks {
    return new AddressChecks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddressChecks {
    return new AddressChecks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddressChecks {
    return new AddressChecks().fromJsonString(jsonString, options);
  }

  static equals(a: AddressChecks | PlainMessage<AddressChecks> | undefined, b: AddressChecks | PlainMessage<AddressChecks> | undefined): boolean {
    return proto3.util.equals(AddressChecks, a, b);
  }
}

/**
 * AltTimeChecks defines alternative time-based checks for approval denial.
 * If the transfer time falls within any of the specified offline hours or days, the approval is denied.
 * Uses UTC timezone for neutral timezone approach.
 * offlineHours: ranges of hours (0-23) when transfers should be denied
 * offlineDays: ranges of days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied
 *
 * @generated from message badges.AltTimeChecks
 */
export class AltTimeChecks extends Message<AltTimeChecks> {
  /**
   * Hours (0-23) when transfers should be denied. Uses UTC timezone.
   *
   * @generated from field: repeated badges.UintRange offlineHours = 1;
   */
  offlineHours: UintRange[] = [];

  /**
   * Days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied. Uses UTC timezone.
   *
   * @generated from field: repeated badges.UintRange offlineDays = 2;
   */
  offlineDays: UintRange[] = [];

  constructor(data?: PartialMessage<AltTimeChecks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.AltTimeChecks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "offlineHours", kind: "message", T: UintRange, repeated: true },
    { no: 2, name: "offlineDays", kind: "message", T: UintRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AltTimeChecks {
    return new AltTimeChecks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AltTimeChecks {
    return new AltTimeChecks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AltTimeChecks {
    return new AltTimeChecks().fromJsonString(jsonString, options);
  }

  static equals(a: AltTimeChecks | PlainMessage<AltTimeChecks> | undefined, b: AltTimeChecks | PlainMessage<AltTimeChecks> | undefined): boolean {
    return proto3.util.equals(AltTimeChecks, a, b);
  }
}

/**
 * UserRoyalties defines the royalties for a user.
 *
 * @generated from message badges.UserRoyalties
 */
export class UserRoyalties extends Message<UserRoyalties> {
  /**
   * Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.
   *
   * @generated from field: string percentage = 1;
   */
  percentage = "";

  /**
   * Payout address for the royalties.
   *
   * @generated from field: string payoutAddress = 2;
   */
  payoutAddress = "";

  constructor(data?: PartialMessage<UserRoyalties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.UserRoyalties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "percentage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payoutAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserRoyalties {
    return new UserRoyalties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserRoyalties {
    return new UserRoyalties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserRoyalties {
    return new UserRoyalties().fromJsonString(jsonString, options);
  }

  static equals(a: UserRoyalties | PlainMessage<UserRoyalties> | undefined, b: UserRoyalties | PlainMessage<UserRoyalties> | undefined): boolean {
    return proto3.util.equals(UserRoyalties, a, b);
  }
}

