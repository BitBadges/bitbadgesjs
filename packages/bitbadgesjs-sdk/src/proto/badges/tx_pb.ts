// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file badges/tx.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Params } from "./params_pb.js";
import { Balance, UintRange } from "./balances_pb.js";
import { CollectionInvariants, DenomUnit } from "./collections_pb.js";
import { ApprovalIdentifierDetails, CollectionApproval, Transfer, UserBalanceStore, UserIncomingApproval, UserOutgoingApproval } from "./transfers_pb.js";
import { BadgeIdsActionPermission, CollectionApprovalPermission, CollectionPermissions, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, UserPermissions } from "./permissions_pb.js";
import { BadgeMetadataTimeline, CollectionMetadataTimeline, CustomDataTimeline, IsArchivedTimeline, ManagerTimeline, OffChainBalancesMetadataTimeline, StandardsTimeline } from "./timelines_pb.js";
import { Coin } from "../cosmos/base/v1beta1/coin_pb.js";
import { AddressList } from "./address_lists_pb.js";

/**
 * Used for WASM bindings and JSON parsing
 *
 * @generated from message badges.BadgeCustomMsgType
 */
export class BadgeCustomMsgType extends Message<BadgeCustomMsgType> {
  /**
   * @generated from field: badges.MsgCreateAddressLists createAddressListsMsg = 1;
   */
  createAddressListsMsg?: MsgCreateAddressLists;

  /**
   * @generated from field: badges.MsgUniversalUpdateCollection universalUpdateCollectionMsg = 2;
   */
  universalUpdateCollectionMsg?: MsgUniversalUpdateCollection;

  /**
   * @generated from field: badges.MsgDeleteCollection deleteCollectionMsg = 3;
   */
  deleteCollectionMsg?: MsgDeleteCollection;

  /**
   * @generated from field: badges.MsgTransferBadges transferBadgesMsg = 4;
   */
  transferBadgesMsg?: MsgTransferBadges;

  /**
   * @generated from field: badges.MsgUpdateUserApprovals updateUserApprovalsMsg = 5;
   */
  updateUserApprovalsMsg?: MsgUpdateUserApprovals;

  /**
   * @generated from field: badges.MsgUpdateCollection updateCollectionMsg = 6;
   */
  updateCollectionMsg?: MsgUpdateCollection;

  /**
   * @generated from field: badges.MsgCreateCollection createCollectionMsg = 7;
   */
  createCollectionMsg?: MsgCreateCollection;

  /**
   * @generated from field: badges.MsgCreateDynamicStore createDynamicStoreMsg = 8;
   */
  createDynamicStoreMsg?: MsgCreateDynamicStore;

  /**
   * @generated from field: badges.MsgUpdateDynamicStore updateDynamicStoreMsg = 9;
   */
  updateDynamicStoreMsg?: MsgUpdateDynamicStore;

  /**
   * @generated from field: badges.MsgDeleteDynamicStore deleteDynamicStoreMsg = 10;
   */
  deleteDynamicStoreMsg?: MsgDeleteDynamicStore;

  /**
   * @generated from field: badges.MsgSetDynamicStoreValue setDynamicStoreValueMsg = 11;
   */
  setDynamicStoreValueMsg?: MsgSetDynamicStoreValue;

  /**
   * @generated from field: badges.MsgIncrementStoreValue incrementStoreValueMsg = 12;
   */
  incrementStoreValueMsg?: MsgIncrementStoreValue;

  /**
   * @generated from field: badges.MsgDecrementStoreValue decrementStoreValueMsg = 13;
   */
  decrementStoreValueMsg?: MsgDecrementStoreValue;

  /**
   * @generated from field: badges.MsgSetIncomingApproval setIncomingApprovalMsg = 14;
   */
  setIncomingApprovalMsg?: MsgSetIncomingApproval;

  /**
   * @generated from field: badges.MsgDeleteIncomingApproval deleteIncomingApprovalMsg = 15;
   */
  deleteIncomingApprovalMsg?: MsgDeleteIncomingApproval;

  /**
   * @generated from field: badges.MsgSetOutgoingApproval setOutgoingApprovalMsg = 16;
   */
  setOutgoingApprovalMsg?: MsgSetOutgoingApproval;

  /**
   * @generated from field: badges.MsgDeleteOutgoingApproval deleteOutgoingApprovalMsg = 17;
   */
  deleteOutgoingApprovalMsg?: MsgDeleteOutgoingApproval;

  /**
   * @generated from field: badges.MsgPurgeApprovals purgeApprovalsMsg = 18;
   */
  purgeApprovalsMsg?: MsgPurgeApprovals;

  /**
   * Helper message types for UniversalUpdateCollection subsets
   *
   * @generated from field: badges.MsgSetValidBadgeIds setValidBadgeIdsMsg = 19;
   */
  setValidBadgeIdsMsg?: MsgSetValidBadgeIds;

  /**
   * @generated from field: badges.MsgSetManager setManagerMsg = 20;
   */
  setManagerMsg?: MsgSetManager;

  /**
   * @generated from field: badges.MsgSetCollectionMetadata setCollectionMetadataMsg = 21;
   */
  setCollectionMetadataMsg?: MsgSetCollectionMetadata;

  /**
   * @generated from field: badges.MsgSetBadgeMetadata setBadgeMetadataMsg = 22;
   */
  setBadgeMetadataMsg?: MsgSetBadgeMetadata;

  /**
   * @generated from field: badges.MsgSetCustomData setCustomDataMsg = 23;
   */
  setCustomDataMsg?: MsgSetCustomData;

  /**
   * @generated from field: badges.MsgSetStandards setStandardsMsg = 24;
   */
  setStandardsMsg?: MsgSetStandards;

  /**
   * @generated from field: badges.MsgSetCollectionApprovals setCollectionApprovalsMsg = 25;
   */
  setCollectionApprovalsMsg?: MsgSetCollectionApprovals;

  /**
   * @generated from field: badges.MsgSetIsArchived setIsArchivedMsg = 26;
   */
  setIsArchivedMsg?: MsgSetIsArchived;

  constructor(data?: PartialMessage<BadgeCustomMsgType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BadgeCustomMsgType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "createAddressListsMsg", kind: "message", T: MsgCreateAddressLists },
    { no: 2, name: "universalUpdateCollectionMsg", kind: "message", T: MsgUniversalUpdateCollection },
    { no: 3, name: "deleteCollectionMsg", kind: "message", T: MsgDeleteCollection },
    { no: 4, name: "transferBadgesMsg", kind: "message", T: MsgTransferBadges },
    { no: 5, name: "updateUserApprovalsMsg", kind: "message", T: MsgUpdateUserApprovals },
    { no: 6, name: "updateCollectionMsg", kind: "message", T: MsgUpdateCollection },
    { no: 7, name: "createCollectionMsg", kind: "message", T: MsgCreateCollection },
    { no: 8, name: "createDynamicStoreMsg", kind: "message", T: MsgCreateDynamicStore },
    { no: 9, name: "updateDynamicStoreMsg", kind: "message", T: MsgUpdateDynamicStore },
    { no: 10, name: "deleteDynamicStoreMsg", kind: "message", T: MsgDeleteDynamicStore },
    { no: 11, name: "setDynamicStoreValueMsg", kind: "message", T: MsgSetDynamicStoreValue },
    { no: 12, name: "incrementStoreValueMsg", kind: "message", T: MsgIncrementStoreValue },
    { no: 13, name: "decrementStoreValueMsg", kind: "message", T: MsgDecrementStoreValue },
    { no: 14, name: "setIncomingApprovalMsg", kind: "message", T: MsgSetIncomingApproval },
    { no: 15, name: "deleteIncomingApprovalMsg", kind: "message", T: MsgDeleteIncomingApproval },
    { no: 16, name: "setOutgoingApprovalMsg", kind: "message", T: MsgSetOutgoingApproval },
    { no: 17, name: "deleteOutgoingApprovalMsg", kind: "message", T: MsgDeleteOutgoingApproval },
    { no: 18, name: "purgeApprovalsMsg", kind: "message", T: MsgPurgeApprovals },
    { no: 19, name: "setValidBadgeIdsMsg", kind: "message", T: MsgSetValidBadgeIds },
    { no: 20, name: "setManagerMsg", kind: "message", T: MsgSetManager },
    { no: 21, name: "setCollectionMetadataMsg", kind: "message", T: MsgSetCollectionMetadata },
    { no: 22, name: "setBadgeMetadataMsg", kind: "message", T: MsgSetBadgeMetadata },
    { no: 23, name: "setCustomDataMsg", kind: "message", T: MsgSetCustomData },
    { no: 24, name: "setStandardsMsg", kind: "message", T: MsgSetStandards },
    { no: 25, name: "setCollectionApprovalsMsg", kind: "message", T: MsgSetCollectionApprovals },
    { no: 26, name: "setIsArchivedMsg", kind: "message", T: MsgSetIsArchived },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromJsonString(jsonString, options);
  }

  static equals(a: BadgeCustomMsgType | PlainMessage<BadgeCustomMsgType> | undefined, b: BadgeCustomMsgType | PlainMessage<BadgeCustomMsgType> | undefined): boolean {
    return proto3.util.equals(BadgeCustomMsgType, a, b);
  }
}

/**
 * MsgUpdateParams is the Msg/UpdateParams request type.
 *
 * @generated from message badges.MsgUpdateParams
 */
export class MsgUpdateParams extends Message<MsgUpdateParams> {
  /**
   * authority is the address that controls the module (defaults to x/gov unless overwritten).
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * params defines the module parameters to update.
   *
   * NOTE: All parameters must be supplied.
   *
   * @generated from field: badges.Params params = 2;
   */
  params?: Params;

  constructor(data?: PartialMessage<MsgUpdateParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined, b: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParams, a, b);
  }
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 *
 * @generated from message badges.MsgUpdateParamsResponse
 */
export class MsgUpdateParamsResponse extends Message<MsgUpdateParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined, b: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParamsResponse, a, b);
  }
}

/**
 * @generated from message badges.CosmosCoinWrapperPathAddObject
 */
export class CosmosCoinWrapperPathAddObject extends Message<CosmosCoinWrapperPathAddObject> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: repeated badges.Balance balances = 2;
   */
  balances: Balance[] = [];

  /**
   * @generated from field: string symbol = 3;
   */
  symbol = "";

  /**
   * @generated from field: repeated badges.DenomUnit denomUnits = 4;
   */
  denomUnits: DenomUnit[] = [];

  /**
   * @generated from field: bool allowOverrideWithAnyValidToken = 5;
   */
  allowOverrideWithAnyValidToken = false;

  /**
   * @generated from field: bool allowCosmosWrapping = 6;
   */
  allowCosmosWrapping = false;

  constructor(data?: PartialMessage<CosmosCoinWrapperPathAddObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CosmosCoinWrapperPathAddObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 3, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "denomUnits", kind: "message", T: DenomUnit, repeated: true },
    { no: 5, name: "allowOverrideWithAnyValidToken", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "allowCosmosWrapping", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CosmosCoinWrapperPathAddObject {
    return new CosmosCoinWrapperPathAddObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPathAddObject {
    return new CosmosCoinWrapperPathAddObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPathAddObject {
    return new CosmosCoinWrapperPathAddObject().fromJsonString(jsonString, options);
  }

  static equals(a: CosmosCoinWrapperPathAddObject | PlainMessage<CosmosCoinWrapperPathAddObject> | undefined, b: CosmosCoinWrapperPathAddObject | PlainMessage<CosmosCoinWrapperPathAddObject> | undefined): boolean {
    return proto3.util.equals(CosmosCoinWrapperPathAddObject, a, b);
  }
}

/**
 * MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.
 * It is a universal interface that can be used for both creating and updating collections.
 * We have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.
 *
 * @generated from message badges.MsgUniversalUpdateCollection
 */
export class MsgUniversalUpdateCollection extends Message<MsgUniversalUpdateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection (0 for new collection).
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Type of balances "Standard" or "Off-Chain - Indexed" or "Off-Chain - Non-Indexed" or "Non-Public".
   *
   * @generated from field: string balancesType = 3;
   */
  balancesType = "";

  /**
   * The default balances for the user
   *
   * @generated from field: badges.UserBalanceStore defaultBalances = 4;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateValidBadgeIds = 5;
   */
  updateValidBadgeIds = false;

  /**
   * New token IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validBadgeIds = 6;
   */
  validBadgeIds: UintRange[] = [];

  /**
   * Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionPermissions = 7;
   */
  updateCollectionPermissions = false;

  /**
   * New collection permissions to set.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 8;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateManagerTimeline = 9;
   */
  updateManagerTimeline = false;

  /**
   * New manager timeline to set.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 10;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionMetadataTimeline = 11;
   */
  updateCollectionMetadataTimeline = false;

  /**
   * New collection metadata timeline to set.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 12;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateBadgeMetadataTimeline = 13;
   */
  updateBadgeMetadataTimeline = false;

  /**
   * New token metadata timeline to set.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 14;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOffChainBalancesMetadataTimeline = 15;
   */
  updateOffChainBalancesMetadataTimeline = false;

  /**
   * New off-chain balances metadata timeline to set.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 16;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCustomDataTimeline = 17;
   */
  updateCustomDataTimeline = false;

  /**
   * New custom data timeline to set.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 18;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionApprovals = 21;
   */
  updateCollectionApprovals = false;

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 22;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateStandardsTimeline = 23;
   */
  updateStandardsTimeline = false;

  /**
   * New standards timeline to set.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 24;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIsArchivedTimeline = 25;
   */
  updateIsArchivedTimeline = false;

  /**
   * New isArchived timeline to set.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 26;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Coins to be transferred to the mint escrow address.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 27;
   */
  mintEscrowCoinsToTransfer: Coin[] = [];

  /**
   * IBC wrapper paths to add.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 28;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   * These are set upon genesis and cannot be modified.
   *
   * @generated from field: badges.CollectionInvariants invariants = 29;
   */
  invariants?: CollectionInvariants;

  constructor(data?: PartialMessage<MsgUniversalUpdateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 5, name: "updateValidBadgeIds", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "validBadgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 7, name: "updateCollectionPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 9, name: "updateManagerTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 11, name: "updateCollectionMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 13, name: "updateBadgeMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 15, name: "updateOffChainBalancesMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 17, name: "updateCustomDataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 21, name: "updateCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 23, name: "updateStandardsTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 24, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 25, name: "updateIsArchivedTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 26, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 27, name: "mintEscrowCoinsToTransfer", kind: "message", T: Coin, repeated: true },
    { no: 28, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
    { no: 29, name: "invariants", kind: "message", T: CollectionInvariants },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollection | PlainMessage<MsgUniversalUpdateCollection> | undefined, b: MsgUniversalUpdateCollection | PlainMessage<MsgUniversalUpdateCollection> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollection, a, b);
  }
}

/**
 * MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.
 *
 * @generated from message badges.MsgUniversalUpdateCollectionResponse
 */
export class MsgUniversalUpdateCollectionResponse extends Message<MsgUniversalUpdateCollectionResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgUniversalUpdateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollectionResponse | PlainMessage<MsgUniversalUpdateCollectionResponse> | undefined, b: MsgUniversalUpdateCollectionResponse | PlainMessage<MsgUniversalUpdateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollectionResponse, a, b);
  }
}

/**
 * MsgUpdateCollection is used to update a collection.
 *
 * @generated from message badges.MsgUpdateCollection
 */
export class MsgUpdateCollection extends Message<MsgUpdateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection (0 for new collection).
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateValidBadgeIds = 3;
   */
  updateValidBadgeIds = false;

  /**
   * New token IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validBadgeIds = 4;
   */
  validBadgeIds: UintRange[] = [];

  /**
   * Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionPermissions = 7;
   */
  updateCollectionPermissions = false;

  /**
   * New collection permissions to set.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 8;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateManagerTimeline = 9;
   */
  updateManagerTimeline = false;

  /**
   * New manager timeline to set.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 10;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionMetadataTimeline = 11;
   */
  updateCollectionMetadataTimeline = false;

  /**
   * New collection metadata timeline to set.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 12;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateBadgeMetadataTimeline = 13;
   */
  updateBadgeMetadataTimeline = false;

  /**
   * New token metadata timeline to set.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 14;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOffChainBalancesMetadataTimeline = 15;
   */
  updateOffChainBalancesMetadataTimeline = false;

  /**
   * New off-chain balances metadata timeline to set.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 16;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCustomDataTimeline = 17;
   */
  updateCustomDataTimeline = false;

  /**
   * New custom data timeline to set.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 18;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionApprovals = 21;
   */
  updateCollectionApprovals = false;

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 22;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateStandardsTimeline = 23;
   */
  updateStandardsTimeline = false;

  /**
   * New standards timeline to set.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 24;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIsArchivedTimeline = 27;
   */
  updateIsArchivedTimeline = false;

  /**
   * New isArchived timeline to set.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 28;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Coins to be transferred to the mint escrow address.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 29;
   */
  mintEscrowCoinsToTransfer: Coin[] = [];

  /**
   * IBC wrapper paths to add.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 30;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   * These are set upon genesis and cannot be modified.
   *
   * @generated from field: badges.CollectionInvariants invariants = 31;
   */
  invariants?: CollectionInvariants;

  constructor(data?: PartialMessage<MsgUpdateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "updateValidBadgeIds", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "validBadgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 7, name: "updateCollectionPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 9, name: "updateManagerTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 11, name: "updateCollectionMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 13, name: "updateBadgeMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 15, name: "updateOffChainBalancesMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 17, name: "updateCustomDataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 21, name: "updateCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 23, name: "updateStandardsTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 24, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 27, name: "updateIsArchivedTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 28, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 29, name: "mintEscrowCoinsToTransfer", kind: "message", T: Coin, repeated: true },
    { no: 30, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
    { no: 31, name: "invariants", kind: "message", T: CollectionInvariants },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateCollection | PlainMessage<MsgUpdateCollection> | undefined, b: MsgUpdateCollection | PlainMessage<MsgUpdateCollection> | undefined): boolean {
    return proto3.util.equals(MsgUpdateCollection, a, b);
  }
}

/**
 * MsgUpdateCollectionResponse is the response to MsgUpdateCollection.
 *
 * @generated from message badges.MsgUpdateCollectionResponse
 */
export class MsgUpdateCollectionResponse extends Message<MsgUpdateCollectionResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgUpdateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateCollectionResponse | PlainMessage<MsgUpdateCollectionResponse> | undefined, b: MsgUpdateCollectionResponse | PlainMessage<MsgUpdateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateCollectionResponse, a, b);
  }
}

/**
 * MsgCreateCollection is used to create a new collection.
 *
 * @generated from message badges.MsgCreateCollection
 */
export class MsgCreateCollection extends Message<MsgCreateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * Type of balances "Standard" or "Off-Chain - Indexed" or "Off-Chain - Non-Indexed" or "Non-Public".
   *
   * @generated from field: string balancesType = 2;
   */
  balancesType = "";

  /**
   * The default balances for the user
   *
   * @generated from field: badges.UserBalanceStore defaultBalances = 4;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * New token IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validBadgeIds = 5;
   */
  validBadgeIds: UintRange[] = [];

  /**
   * Collection permissions.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 6;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Manager timeline entries.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 7;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Collection metadata timeline entries.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 8;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Token metadata timeline entries.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 9;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Off-chain balances metadata timeline entries.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 10;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * Custom data timeline entries.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 11;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Collection approvals.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 12;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards timeline entries.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 13;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * isArchived timeline entries.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 14;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Coins to be transferred to the mint escrow address.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 16;
   */
  mintEscrowCoinsToTransfer: Coin[] = [];

  /**
   * IBC wrapper paths to add.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 17;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   *
   * @generated from field: badges.CollectionInvariants invariants = 18;
   */
  invariants?: CollectionInvariants;

  constructor(data?: PartialMessage<MsgCreateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 5, name: "validBadgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 7, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 8, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 9, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 10, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 11, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 12, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 13, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 14, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 16, name: "mintEscrowCoinsToTransfer", kind: "message", T: Coin, repeated: true },
    { no: 17, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
    { no: 18, name: "invariants", kind: "message", T: CollectionInvariants },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateCollection | PlainMessage<MsgCreateCollection> | undefined, b: MsgCreateCollection | PlainMessage<MsgCreateCollection> | undefined): boolean {
    return proto3.util.equals(MsgCreateCollection, a, b);
  }
}

/**
 * MsgCreateCollectionResponse is the response to MsgCreateCollection.
 *
 * @generated from message badges.MsgCreateCollectionResponse
 */
export class MsgCreateCollectionResponse extends Message<MsgCreateCollectionResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgCreateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateCollectionResponse | PlainMessage<MsgCreateCollectionResponse> | undefined, b: MsgCreateCollectionResponse | PlainMessage<MsgCreateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateCollectionResponse, a, b);
  }
}

/**
 * MsgCreateAddressLists is used to create address lists.
 *
 * @generated from message badges.MsgCreateAddressLists
 */
export class MsgCreateAddressLists extends Message<MsgCreateAddressLists> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * Address lists to create.
   *
   * @generated from field: repeated badges.AddressList addressLists = 2;
   */
  addressLists: AddressList[] = [];

  constructor(data?: PartialMessage<MsgCreateAddressLists>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateAddressLists";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "addressLists", kind: "message", T: AddressList, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateAddressLists {
    return new MsgCreateAddressLists().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateAddressLists {
    return new MsgCreateAddressLists().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateAddressLists {
    return new MsgCreateAddressLists().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateAddressLists | PlainMessage<MsgCreateAddressLists> | undefined, b: MsgCreateAddressLists | PlainMessage<MsgCreateAddressLists> | undefined): boolean {
    return proto3.util.equals(MsgCreateAddressLists, a, b);
  }
}

/**
 * MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.
 *
 * @generated from message badges.MsgCreateAddressListsResponse
 */
export class MsgCreateAddressListsResponse extends Message<MsgCreateAddressListsResponse> {
  constructor(data?: PartialMessage<MsgCreateAddressListsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateAddressListsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateAddressListsResponse {
    return new MsgCreateAddressListsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateAddressListsResponse {
    return new MsgCreateAddressListsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateAddressListsResponse {
    return new MsgCreateAddressListsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateAddressListsResponse | PlainMessage<MsgCreateAddressListsResponse> | undefined, b: MsgCreateAddressListsResponse | PlainMessage<MsgCreateAddressListsResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateAddressListsResponse, a, b);
  }
}

/**
 * MsgTransferBadges is used to transfer tokens.
 *
 * @generated from message badges.MsgTransferBadges
 */
export class MsgTransferBadges extends Message<MsgTransferBadges> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Transfers to execute.
   *
   * @generated from field: repeated badges.Transfer transfers = 3;
   */
  transfers: Transfer[] = [];

  constructor(data?: PartialMessage<MsgTransferBadges>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgTransferBadges";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transfers", kind: "message", T: Transfer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgTransferBadges {
    return new MsgTransferBadges().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgTransferBadges {
    return new MsgTransferBadges().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgTransferBadges {
    return new MsgTransferBadges().fromJsonString(jsonString, options);
  }

  static equals(a: MsgTransferBadges | PlainMessage<MsgTransferBadges> | undefined, b: MsgTransferBadges | PlainMessage<MsgTransferBadges> | undefined): boolean {
    return proto3.util.equals(MsgTransferBadges, a, b);
  }
}

/**
 * MsgTransferBadgesResponse is the response to MsgTransferBadges.
 *
 * @generated from message badges.MsgTransferBadgesResponse
 */
export class MsgTransferBadgesResponse extends Message<MsgTransferBadgesResponse> {
  constructor(data?: PartialMessage<MsgTransferBadgesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgTransferBadgesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgTransferBadgesResponse {
    return new MsgTransferBadgesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgTransferBadgesResponse {
    return new MsgTransferBadgesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgTransferBadgesResponse {
    return new MsgTransferBadgesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgTransferBadgesResponse | PlainMessage<MsgTransferBadgesResponse> | undefined, b: MsgTransferBadgesResponse | PlainMessage<MsgTransferBadgesResponse> | undefined): boolean {
    return proto3.util.equals(MsgTransferBadgesResponse, a, b);
  }
}

/**
 * MsgDeleteCollection is used to delete a collection.
 *
 * @generated from message badges.MsgDeleteCollection
 */
export class MsgDeleteCollection extends Message<MsgDeleteCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgDeleteCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteCollection | PlainMessage<MsgDeleteCollection> | undefined, b: MsgDeleteCollection | PlainMessage<MsgDeleteCollection> | undefined): boolean {
    return proto3.util.equals(MsgDeleteCollection, a, b);
  }
}

/**
 * MsgDeleteCollectionResponse is the response to MsgDeleteCollection.
 *
 * @generated from message badges.MsgDeleteCollectionResponse
 */
export class MsgDeleteCollectionResponse extends Message<MsgDeleteCollectionResponse> {
  constructor(data?: PartialMessage<MsgDeleteCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteCollectionResponse | PlainMessage<MsgDeleteCollectionResponse> | undefined, b: MsgDeleteCollectionResponse | PlainMessage<MsgDeleteCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteCollectionResponse, a, b);
  }
}

/**
 * MsgUpdateUserApprovals is used to update user approvals.
 *
 * @generated from message badges.MsgUpdateUserApprovals
 */
export class MsgUpdateUserApprovals extends Message<MsgUpdateUserApprovals> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOutgoingApprovals = 3;
   */
  updateOutgoingApprovals = false;

  /**
   * New outgoing approvals to set. 
   *
   * @generated from field: repeated badges.UserOutgoingApproval outgoingApprovals = 4;
   */
  outgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIncomingApprovals = 5;
   */
  updateIncomingApprovals = false;

  /**
   * New incoming approvals to set.
   *
   * @generated from field: repeated badges.UserIncomingApproval incomingApprovals = 6;
   */
  incomingApprovals: UserIncomingApproval[] = [];

  /**
   * Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveSelfInitiatedOutgoingTransfers = 7;
   */
  updateAutoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Auto-approve setting for self-initiated outgoing transfers.
   *
   * @generated from field: bool autoApproveSelfInitiatedOutgoingTransfers = 8;
   */
  autoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveSelfInitiatedIncomingTransfers = 9;
   */
  updateAutoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Auto-approve setting for self-initiated incoming transfers.
   *
   * @generated from field: bool autoApproveSelfInitiatedIncomingTransfers = 10;
   */
  autoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveAllIncomingTransfers = 11;
   */
  updateAutoApproveAllIncomingTransfers = false;

  /**
   * Auto-approve setting for all incoming transfers.
   *
   * @generated from field: bool autoApproveAllIncomingTransfers = 12;
   */
  autoApproveAllIncomingTransfers = false;

  /**
   * Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateUserPermissions = 13;
   */
  updateUserPermissions = false;

  /**
   * New user permissions to set.
   *
   * @generated from field: badges.UserPermissions userPermissions = 14;
   */
  userPermissions?: UserPermissions;

  constructor(data?: PartialMessage<MsgUpdateUserApprovals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserApprovals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "updateOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "outgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 5, name: "updateIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "incomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 7, name: "updateAutoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "autoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "updateAutoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "autoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "updateAutoApproveAllIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "autoApproveAllIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "updateUserPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "userPermissions", kind: "message", T: UserPermissions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserApprovals | PlainMessage<MsgUpdateUserApprovals> | undefined, b: MsgUpdateUserApprovals | PlainMessage<MsgUpdateUserApprovals> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserApprovals, a, b);
  }
}

/**
 * MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.
 *
 * @generated from message badges.MsgUpdateUserApprovalsResponse
 */
export class MsgUpdateUserApprovalsResponse extends Message<MsgUpdateUserApprovalsResponse> {
  constructor(data?: PartialMessage<MsgUpdateUserApprovalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserApprovalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserApprovalsResponse | PlainMessage<MsgUpdateUserApprovalsResponse> | undefined, b: MsgUpdateUserApprovalsResponse | PlainMessage<MsgUpdateUserApprovalsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserApprovalsResponse, a, b);
  }
}

/**
 * MsgSetIncomingApproval is a helper message to set a single incoming approval.
 *
 * @generated from message badges.MsgSetIncomingApproval
 */
export class MsgSetIncomingApproval extends Message<MsgSetIncomingApproval> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The incoming approval to set.
   *
   * @generated from field: badges.UserIncomingApproval approval = 3;
   */
  approval?: UserIncomingApproval;

  constructor(data?: PartialMessage<MsgSetIncomingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetIncomingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approval", kind: "message", T: UserIncomingApproval },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetIncomingApproval {
    return new MsgSetIncomingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetIncomingApproval {
    return new MsgSetIncomingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetIncomingApproval {
    return new MsgSetIncomingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetIncomingApproval | PlainMessage<MsgSetIncomingApproval> | undefined, b: MsgSetIncomingApproval | PlainMessage<MsgSetIncomingApproval> | undefined): boolean {
    return proto3.util.equals(MsgSetIncomingApproval, a, b);
  }
}

/**
 * MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.
 *
 * @generated from message badges.MsgSetIncomingApprovalResponse
 */
export class MsgSetIncomingApprovalResponse extends Message<MsgSetIncomingApprovalResponse> {
  constructor(data?: PartialMessage<MsgSetIncomingApprovalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetIncomingApprovalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetIncomingApprovalResponse {
    return new MsgSetIncomingApprovalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetIncomingApprovalResponse {
    return new MsgSetIncomingApprovalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetIncomingApprovalResponse {
    return new MsgSetIncomingApprovalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetIncomingApprovalResponse | PlainMessage<MsgSetIncomingApprovalResponse> | undefined, b: MsgSetIncomingApprovalResponse | PlainMessage<MsgSetIncomingApprovalResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetIncomingApprovalResponse, a, b);
  }
}

/**
 * MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.
 *
 * @generated from message badges.MsgDeleteIncomingApproval
 */
export class MsgDeleteIncomingApproval extends Message<MsgDeleteIncomingApproval> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The ID of the approval to delete.
   *
   * @generated from field: string approvalId = 3;
   */
  approvalId = "";

  constructor(data?: PartialMessage<MsgDeleteIncomingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteIncomingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteIncomingApproval {
    return new MsgDeleteIncomingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteIncomingApproval {
    return new MsgDeleteIncomingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteIncomingApproval {
    return new MsgDeleteIncomingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteIncomingApproval | PlainMessage<MsgDeleteIncomingApproval> | undefined, b: MsgDeleteIncomingApproval | PlainMessage<MsgDeleteIncomingApproval> | undefined): boolean {
    return proto3.util.equals(MsgDeleteIncomingApproval, a, b);
  }
}

/**
 * MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.
 *
 * @generated from message badges.MsgDeleteIncomingApprovalResponse
 */
export class MsgDeleteIncomingApprovalResponse extends Message<MsgDeleteIncomingApprovalResponse> {
  constructor(data?: PartialMessage<MsgDeleteIncomingApprovalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteIncomingApprovalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteIncomingApprovalResponse {
    return new MsgDeleteIncomingApprovalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteIncomingApprovalResponse {
    return new MsgDeleteIncomingApprovalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteIncomingApprovalResponse {
    return new MsgDeleteIncomingApprovalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteIncomingApprovalResponse | PlainMessage<MsgDeleteIncomingApprovalResponse> | undefined, b: MsgDeleteIncomingApprovalResponse | PlainMessage<MsgDeleteIncomingApprovalResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteIncomingApprovalResponse, a, b);
  }
}

/**
 * MsgSetOutgoingApproval is a helper message to set a single outgoing approval.
 *
 * @generated from message badges.MsgSetOutgoingApproval
 */
export class MsgSetOutgoingApproval extends Message<MsgSetOutgoingApproval> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The outgoing approval to set.
   *
   * @generated from field: badges.UserOutgoingApproval approval = 3;
   */
  approval?: UserOutgoingApproval;

  constructor(data?: PartialMessage<MsgSetOutgoingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetOutgoingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approval", kind: "message", T: UserOutgoingApproval },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetOutgoingApproval {
    return new MsgSetOutgoingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetOutgoingApproval {
    return new MsgSetOutgoingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetOutgoingApproval {
    return new MsgSetOutgoingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetOutgoingApproval | PlainMessage<MsgSetOutgoingApproval> | undefined, b: MsgSetOutgoingApproval | PlainMessage<MsgSetOutgoingApproval> | undefined): boolean {
    return proto3.util.equals(MsgSetOutgoingApproval, a, b);
  }
}

/**
 * MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.
 *
 * @generated from message badges.MsgSetOutgoingApprovalResponse
 */
export class MsgSetOutgoingApprovalResponse extends Message<MsgSetOutgoingApprovalResponse> {
  constructor(data?: PartialMessage<MsgSetOutgoingApprovalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetOutgoingApprovalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetOutgoingApprovalResponse {
    return new MsgSetOutgoingApprovalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetOutgoingApprovalResponse {
    return new MsgSetOutgoingApprovalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetOutgoingApprovalResponse {
    return new MsgSetOutgoingApprovalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetOutgoingApprovalResponse | PlainMessage<MsgSetOutgoingApprovalResponse> | undefined, b: MsgSetOutgoingApprovalResponse | PlainMessage<MsgSetOutgoingApprovalResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetOutgoingApprovalResponse, a, b);
  }
}

/**
 * MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.
 *
 * @generated from message badges.MsgDeleteOutgoingApproval
 */
export class MsgDeleteOutgoingApproval extends Message<MsgDeleteOutgoingApproval> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The ID of the approval to delete.
   *
   * @generated from field: string approvalId = 3;
   */
  approvalId = "";

  constructor(data?: PartialMessage<MsgDeleteOutgoingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteOutgoingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteOutgoingApproval {
    return new MsgDeleteOutgoingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteOutgoingApproval {
    return new MsgDeleteOutgoingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteOutgoingApproval {
    return new MsgDeleteOutgoingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteOutgoingApproval | PlainMessage<MsgDeleteOutgoingApproval> | undefined, b: MsgDeleteOutgoingApproval | PlainMessage<MsgDeleteOutgoingApproval> | undefined): boolean {
    return proto3.util.equals(MsgDeleteOutgoingApproval, a, b);
  }
}

/**
 * MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.
 *
 * @generated from message badges.MsgDeleteOutgoingApprovalResponse
 */
export class MsgDeleteOutgoingApprovalResponse extends Message<MsgDeleteOutgoingApprovalResponse> {
  constructor(data?: PartialMessage<MsgDeleteOutgoingApprovalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteOutgoingApprovalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteOutgoingApprovalResponse {
    return new MsgDeleteOutgoingApprovalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteOutgoingApprovalResponse {
    return new MsgDeleteOutgoingApprovalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteOutgoingApprovalResponse {
    return new MsgDeleteOutgoingApprovalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteOutgoingApprovalResponse | PlainMessage<MsgDeleteOutgoingApprovalResponse> | undefined, b: MsgDeleteOutgoingApprovalResponse | PlainMessage<MsgDeleteOutgoingApprovalResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteOutgoingApprovalResponse, a, b);
  }
}

/**
 * MsgPurgeApprovals is a helper message to purge expired approvals.
 *
 * @generated from message badges.MsgPurgeApprovals
 */
export class MsgPurgeApprovals extends Message<MsgPurgeApprovals> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Whether to purge expired approvals (approvals with no future valid transfer times).
   *
   * @generated from field: bool purgeExpired = 3;
   */
  purgeExpired = false;

  /**
   * Address of the user whose approvals to purge. If empty, defaults to creator.
   *
   * @generated from field: string approverAddress = 4;
   */
  approverAddress = "";

  /**
   * Whether to purge counterparty approvals (approvals where the creator is the only initiator).
   *
   * @generated from field: bool purgeCounterpartyApprovals = 5;
   */
  purgeCounterpartyApprovals = false;

  /**
   * Specific approvals to purge. If empty, purges all applicable approvals based on other flags.
   *
   * @generated from field: repeated badges.ApprovalIdentifierDetails approvalsToPurge = 6;
   */
  approvalsToPurge: ApprovalIdentifierDetails[] = [];

  constructor(data?: PartialMessage<MsgPurgeApprovals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgPurgeApprovals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "purgeExpired", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "approverAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "purgeCounterpartyApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "approvalsToPurge", kind: "message", T: ApprovalIdentifierDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgPurgeApprovals {
    return new MsgPurgeApprovals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgPurgeApprovals {
    return new MsgPurgeApprovals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgPurgeApprovals {
    return new MsgPurgeApprovals().fromJsonString(jsonString, options);
  }

  static equals(a: MsgPurgeApprovals | PlainMessage<MsgPurgeApprovals> | undefined, b: MsgPurgeApprovals | PlainMessage<MsgPurgeApprovals> | undefined): boolean {
    return proto3.util.equals(MsgPurgeApprovals, a, b);
  }
}

/**
 * MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.
 *
 * @generated from message badges.MsgPurgeApprovalsResponse
 */
export class MsgPurgeApprovalsResponse extends Message<MsgPurgeApprovalsResponse> {
  /**
   * Number of approvals purged.
   *
   * @generated from field: string numPurged = 1;
   */
  numPurged = "";

  constructor(data?: PartialMessage<MsgPurgeApprovalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgPurgeApprovalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "numPurged", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgPurgeApprovalsResponse {
    return new MsgPurgeApprovalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgPurgeApprovalsResponse {
    return new MsgPurgeApprovalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgPurgeApprovalsResponse {
    return new MsgPurgeApprovalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgPurgeApprovalsResponse | PlainMessage<MsgPurgeApprovalsResponse> | undefined, b: MsgPurgeApprovalsResponse | PlainMessage<MsgPurgeApprovalsResponse> | undefined): boolean {
    return proto3.util.equals(MsgPurgeApprovalsResponse, a, b);
  }
}

/**
 * MsgCreateDynamicStore is used to create a new dynamic store.
 *
 * @generated from message badges.MsgCreateDynamicStore
 */
export class MsgCreateDynamicStore extends Message<MsgCreateDynamicStore> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * The default value for uninitialized addresses (number of uses).
   *
   * @generated from field: string defaultValue = 2;
   */
  defaultValue = "";

  constructor(data?: PartialMessage<MsgCreateDynamicStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateDynamicStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "defaultValue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDynamicStore {
    return new MsgCreateDynamicStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDynamicStore {
    return new MsgCreateDynamicStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDynamicStore {
    return new MsgCreateDynamicStore().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDynamicStore | PlainMessage<MsgCreateDynamicStore> | undefined, b: MsgCreateDynamicStore | PlainMessage<MsgCreateDynamicStore> | undefined): boolean {
    return proto3.util.equals(MsgCreateDynamicStore, a, b);
  }
}

/**
 * MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.
 *
 * @generated from message badges.MsgCreateDynamicStoreResponse
 */
export class MsgCreateDynamicStoreResponse extends Message<MsgCreateDynamicStoreResponse> {
  /**
   * ID of the dynamic store.
   *
   * @generated from field: string storeId = 1;
   */
  storeId = "";

  constructor(data?: PartialMessage<MsgCreateDynamicStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateDynamicStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDynamicStoreResponse {
    return new MsgCreateDynamicStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDynamicStoreResponse {
    return new MsgCreateDynamicStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDynamicStoreResponse {
    return new MsgCreateDynamicStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDynamicStoreResponse | PlainMessage<MsgCreateDynamicStoreResponse> | undefined, b: MsgCreateDynamicStoreResponse | PlainMessage<MsgCreateDynamicStoreResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateDynamicStoreResponse, a, b);
  }
}

/**
 * MsgUpdateDynamicStore is used to update an existing dynamic store.
 *
 * @generated from message badges.MsgUpdateDynamicStore
 */
export class MsgUpdateDynamicStore extends Message<MsgUpdateDynamicStore> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store to update.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  /**
   * The new default value for uninitialized addresses (optional, only set if updating).
   *
   * @generated from field: string defaultValue = 3;
   */
  defaultValue = "";

  constructor(data?: PartialMessage<MsgUpdateDynamicStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateDynamicStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "defaultValue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateDynamicStore {
    return new MsgUpdateDynamicStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStore {
    return new MsgUpdateDynamicStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStore {
    return new MsgUpdateDynamicStore().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateDynamicStore | PlainMessage<MsgUpdateDynamicStore> | undefined, b: MsgUpdateDynamicStore | PlainMessage<MsgUpdateDynamicStore> | undefined): boolean {
    return proto3.util.equals(MsgUpdateDynamicStore, a, b);
  }
}

/**
 * MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.
 *
 * @generated from message badges.MsgUpdateDynamicStoreResponse
 */
export class MsgUpdateDynamicStoreResponse extends Message<MsgUpdateDynamicStoreResponse> {
  constructor(data?: PartialMessage<MsgUpdateDynamicStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateDynamicStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateDynamicStoreResponse {
    return new MsgUpdateDynamicStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStoreResponse {
    return new MsgUpdateDynamicStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStoreResponse {
    return new MsgUpdateDynamicStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateDynamicStoreResponse | PlainMessage<MsgUpdateDynamicStoreResponse> | undefined, b: MsgUpdateDynamicStoreResponse | PlainMessage<MsgUpdateDynamicStoreResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateDynamicStoreResponse, a, b);
  }
}

/**
 * MsgDeleteDynamicStore is used to delete a dynamic store.
 *
 * @generated from message badges.MsgDeleteDynamicStore
 */
export class MsgDeleteDynamicStore extends Message<MsgDeleteDynamicStore> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store to delete.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  constructor(data?: PartialMessage<MsgDeleteDynamicStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteDynamicStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteDynamicStore {
    return new MsgDeleteDynamicStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStore {
    return new MsgDeleteDynamicStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStore {
    return new MsgDeleteDynamicStore().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteDynamicStore | PlainMessage<MsgDeleteDynamicStore> | undefined, b: MsgDeleteDynamicStore | PlainMessage<MsgDeleteDynamicStore> | undefined): boolean {
    return proto3.util.equals(MsgDeleteDynamicStore, a, b);
  }
}

/**
 * MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.
 *
 * @generated from message badges.MsgDeleteDynamicStoreResponse
 */
export class MsgDeleteDynamicStoreResponse extends Message<MsgDeleteDynamicStoreResponse> {
  constructor(data?: PartialMessage<MsgDeleteDynamicStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteDynamicStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteDynamicStoreResponse {
    return new MsgDeleteDynamicStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStoreResponse {
    return new MsgDeleteDynamicStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStoreResponse {
    return new MsgDeleteDynamicStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteDynamicStoreResponse | PlainMessage<MsgDeleteDynamicStoreResponse> | undefined, b: MsgDeleteDynamicStoreResponse | PlainMessage<MsgDeleteDynamicStoreResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteDynamicStoreResponse, a, b);
  }
}

/**
 * MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.
 *
 * @generated from message badges.MsgSetDynamicStoreValue
 */
export class MsgSetDynamicStoreValue extends Message<MsgSetDynamicStoreValue> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  /**
   * The address for which to set the value.
   *
   * @generated from field: string address = 3;
   */
  address = "";

  /**
   * The usage count to set (number of times this address can use the approval).
   *
   * @generated from field: string value = 4;
   */
  value = "";

  constructor(data?: PartialMessage<MsgSetDynamicStoreValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetDynamicStoreValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDynamicStoreValue {
    return new MsgSetDynamicStoreValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValue {
    return new MsgSetDynamicStoreValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValue {
    return new MsgSetDynamicStoreValue().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDynamicStoreValue | PlainMessage<MsgSetDynamicStoreValue> | undefined, b: MsgSetDynamicStoreValue | PlainMessage<MsgSetDynamicStoreValue> | undefined): boolean {
    return proto3.util.equals(MsgSetDynamicStoreValue, a, b);
  }
}

/**
 * MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.
 *
 * @generated from message badges.MsgSetDynamicStoreValueResponse
 */
export class MsgSetDynamicStoreValueResponse extends Message<MsgSetDynamicStoreValueResponse> {
  constructor(data?: PartialMessage<MsgSetDynamicStoreValueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetDynamicStoreValueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDynamicStoreValueResponse {
    return new MsgSetDynamicStoreValueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValueResponse {
    return new MsgSetDynamicStoreValueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValueResponse {
    return new MsgSetDynamicStoreValueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDynamicStoreValueResponse | PlainMessage<MsgSetDynamicStoreValueResponse> | undefined, b: MsgSetDynamicStoreValueResponse | PlainMessage<MsgSetDynamicStoreValueResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetDynamicStoreValueResponse, a, b);
  }
}

/**
 * MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.
 *
 * @generated from message badges.MsgIncrementStoreValue
 */
export class MsgIncrementStoreValue extends Message<MsgIncrementStoreValue> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  /**
   * The address for which to increment the value.
   *
   * @generated from field: string address = 3;
   */
  address = "";

  /**
   * The amount to increment by.
   *
   * @generated from field: string amount = 4;
   */
  amount = "";

  constructor(data?: PartialMessage<MsgIncrementStoreValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgIncrementStoreValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgIncrementStoreValue {
    return new MsgIncrementStoreValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgIncrementStoreValue {
    return new MsgIncrementStoreValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgIncrementStoreValue {
    return new MsgIncrementStoreValue().fromJsonString(jsonString, options);
  }

  static equals(a: MsgIncrementStoreValue | PlainMessage<MsgIncrementStoreValue> | undefined, b: MsgIncrementStoreValue | PlainMessage<MsgIncrementStoreValue> | undefined): boolean {
    return proto3.util.equals(MsgIncrementStoreValue, a, b);
  }
}

/**
 * MsgIncrementStoreValueResponse is the response to MsgIncrementStoreValue.
 *
 * @generated from message badges.MsgIncrementStoreValueResponse
 */
export class MsgIncrementStoreValueResponse extends Message<MsgIncrementStoreValueResponse> {
  constructor(data?: PartialMessage<MsgIncrementStoreValueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgIncrementStoreValueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgIncrementStoreValueResponse {
    return new MsgIncrementStoreValueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgIncrementStoreValueResponse {
    return new MsgIncrementStoreValueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgIncrementStoreValueResponse {
    return new MsgIncrementStoreValueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgIncrementStoreValueResponse | PlainMessage<MsgIncrementStoreValueResponse> | undefined, b: MsgIncrementStoreValueResponse | PlainMessage<MsgIncrementStoreValueResponse> | undefined): boolean {
    return proto3.util.equals(MsgIncrementStoreValueResponse, a, b);
  }
}

/**
 * MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.
 *
 * @generated from message badges.MsgDecrementStoreValue
 */
export class MsgDecrementStoreValue extends Message<MsgDecrementStoreValue> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  /**
   * The address for which to decrement the value.
   *
   * @generated from field: string address = 3;
   */
  address = "";

  /**
   * The amount to decrement by.
   *
   * @generated from field: string amount = 4;
   */
  amount = "";

  /**
   * If true, set to zero on underflow. If false, throw error on underflow.
   *
   * @generated from field: bool setToZeroOnUnderflow = 5;
   */
  setToZeroOnUnderflow = false;

  constructor(data?: PartialMessage<MsgDecrementStoreValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDecrementStoreValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "setToZeroOnUnderflow", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDecrementStoreValue {
    return new MsgDecrementStoreValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDecrementStoreValue {
    return new MsgDecrementStoreValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDecrementStoreValue {
    return new MsgDecrementStoreValue().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDecrementStoreValue | PlainMessage<MsgDecrementStoreValue> | undefined, b: MsgDecrementStoreValue | PlainMessage<MsgDecrementStoreValue> | undefined): boolean {
    return proto3.util.equals(MsgDecrementStoreValue, a, b);
  }
}

/**
 * MsgDecrementStoreValueResponse is the response to MsgDecrementStoreValue.
 *
 * @generated from message badges.MsgDecrementStoreValueResponse
 */
export class MsgDecrementStoreValueResponse extends Message<MsgDecrementStoreValueResponse> {
  constructor(data?: PartialMessage<MsgDecrementStoreValueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDecrementStoreValueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDecrementStoreValueResponse {
    return new MsgDecrementStoreValueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDecrementStoreValueResponse {
    return new MsgDecrementStoreValueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDecrementStoreValueResponse {
    return new MsgDecrementStoreValueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDecrementStoreValueResponse | PlainMessage<MsgDecrementStoreValueResponse> | undefined, b: MsgDecrementStoreValueResponse | PlainMessage<MsgDecrementStoreValueResponse> | undefined): boolean {
    return proto3.util.equals(MsgDecrementStoreValueResponse, a, b);
  }
}

/**
 * MsgSetValidBadgeIds sets the validBadgeIds and canUpdateValidBadgeIds permission
 *
 * @generated from message badges.MsgSetValidBadgeIds
 */
export class MsgSetValidBadgeIds extends Message<MsgSetValidBadgeIds> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New token IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validBadgeIds = 3;
   */
  validBadgeIds: UintRange[] = [];

  /**
   * Permission to update valid token IDs
   *
   * @generated from field: repeated badges.BadgeIdsActionPermission canUpdateValidBadgeIds = 4;
   */
  canUpdateValidBadgeIds: BadgeIdsActionPermission[] = [];

  constructor(data?: PartialMessage<MsgSetValidBadgeIds>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetValidBadgeIds";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "validBadgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "canUpdateValidBadgeIds", kind: "message", T: BadgeIdsActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetValidBadgeIds {
    return new MsgSetValidBadgeIds().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetValidBadgeIds {
    return new MsgSetValidBadgeIds().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetValidBadgeIds {
    return new MsgSetValidBadgeIds().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetValidBadgeIds | PlainMessage<MsgSetValidBadgeIds> | undefined, b: MsgSetValidBadgeIds | PlainMessage<MsgSetValidBadgeIds> | undefined): boolean {
    return proto3.util.equals(MsgSetValidBadgeIds, a, b);
  }
}

/**
 * MsgSetValidBadgeIdsResponse is the response to MsgSetValidBadgeIds.
 *
 * @generated from message badges.MsgSetValidBadgeIdsResponse
 */
export class MsgSetValidBadgeIdsResponse extends Message<MsgSetValidBadgeIdsResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetValidBadgeIdsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetValidBadgeIdsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetValidBadgeIdsResponse {
    return new MsgSetValidBadgeIdsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetValidBadgeIdsResponse {
    return new MsgSetValidBadgeIdsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetValidBadgeIdsResponse {
    return new MsgSetValidBadgeIdsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetValidBadgeIdsResponse | PlainMessage<MsgSetValidBadgeIdsResponse> | undefined, b: MsgSetValidBadgeIdsResponse | PlainMessage<MsgSetValidBadgeIdsResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetValidBadgeIdsResponse, a, b);
  }
}

/**
 * MsgSetManager sets the manager timeline and canUpdateManager permission
 *
 * @generated from message badges.MsgSetManager
 */
export class MsgSetManager extends Message<MsgSetManager> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New manager timeline to set.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 3;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Permission to update manager timeline
   *
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateManager = 4;
   */
  canUpdateManager: TimedUpdatePermission[] = [];

  constructor(data?: PartialMessage<MsgSetManager>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetManager";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 4, name: "canUpdateManager", kind: "message", T: TimedUpdatePermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetManager {
    return new MsgSetManager().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetManager {
    return new MsgSetManager().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetManager {
    return new MsgSetManager().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetManager | PlainMessage<MsgSetManager> | undefined, b: MsgSetManager | PlainMessage<MsgSetManager> | undefined): boolean {
    return proto3.util.equals(MsgSetManager, a, b);
  }
}

/**
 * MsgSetManagerResponse is the response to MsgSetManager.
 *
 * @generated from message badges.MsgSetManagerResponse
 */
export class MsgSetManagerResponse extends Message<MsgSetManagerResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetManagerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetManagerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetManagerResponse {
    return new MsgSetManagerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetManagerResponse {
    return new MsgSetManagerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetManagerResponse {
    return new MsgSetManagerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetManagerResponse | PlainMessage<MsgSetManagerResponse> | undefined, b: MsgSetManagerResponse | PlainMessage<MsgSetManagerResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetManagerResponse, a, b);
  }
}

/**
 * MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission
 *
 * @generated from message badges.MsgSetCollectionMetadata
 */
export class MsgSetCollectionMetadata extends Message<MsgSetCollectionMetadata> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New collection metadata timeline to set.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 3;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Permission to update collection metadata timeline
   *
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateCollectionMetadata = 4;
   */
  canUpdateCollectionMetadata: TimedUpdatePermission[] = [];

  constructor(data?: PartialMessage<MsgSetCollectionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCollectionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 4, name: "canUpdateCollectionMetadata", kind: "message", T: TimedUpdatePermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCollectionMetadata {
    return new MsgSetCollectionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCollectionMetadata {
    return new MsgSetCollectionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCollectionMetadata {
    return new MsgSetCollectionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCollectionMetadata | PlainMessage<MsgSetCollectionMetadata> | undefined, b: MsgSetCollectionMetadata | PlainMessage<MsgSetCollectionMetadata> | undefined): boolean {
    return proto3.util.equals(MsgSetCollectionMetadata, a, b);
  }
}

/**
 * MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.
 *
 * @generated from message badges.MsgSetCollectionMetadataResponse
 */
export class MsgSetCollectionMetadataResponse extends Message<MsgSetCollectionMetadataResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetCollectionMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCollectionMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCollectionMetadataResponse {
    return new MsgSetCollectionMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCollectionMetadataResponse {
    return new MsgSetCollectionMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCollectionMetadataResponse {
    return new MsgSetCollectionMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCollectionMetadataResponse | PlainMessage<MsgSetCollectionMetadataResponse> | undefined, b: MsgSetCollectionMetadataResponse | PlainMessage<MsgSetCollectionMetadataResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetCollectionMetadataResponse, a, b);
  }
}

/**
 * MsgSetBadgeMetadata sets the token metadata timeline and canUpdateBadgeMetadata permission
 *
 * @generated from message badges.MsgSetBadgeMetadata
 */
export class MsgSetBadgeMetadata extends Message<MsgSetBadgeMetadata> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New token metadata timeline to set.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 3;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Permission to update token metadata timeline
   *
   * @generated from field: repeated badges.TimedUpdateWithBadgeIdsPermission canUpdateBadgeMetadata = 4;
   */
  canUpdateBadgeMetadata: TimedUpdateWithBadgeIdsPermission[] = [];

  constructor(data?: PartialMessage<MsgSetBadgeMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetBadgeMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 4, name: "canUpdateBadgeMetadata", kind: "message", T: TimedUpdateWithBadgeIdsPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetBadgeMetadata {
    return new MsgSetBadgeMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetBadgeMetadata {
    return new MsgSetBadgeMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetBadgeMetadata {
    return new MsgSetBadgeMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetBadgeMetadata | PlainMessage<MsgSetBadgeMetadata> | undefined, b: MsgSetBadgeMetadata | PlainMessage<MsgSetBadgeMetadata> | undefined): boolean {
    return proto3.util.equals(MsgSetBadgeMetadata, a, b);
  }
}

/**
 * MsgSetBadgeMetadataResponse is the response to MsgSetBadgeMetadata.
 *
 * @generated from message badges.MsgSetBadgeMetadataResponse
 */
export class MsgSetBadgeMetadataResponse extends Message<MsgSetBadgeMetadataResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetBadgeMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetBadgeMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetBadgeMetadataResponse {
    return new MsgSetBadgeMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetBadgeMetadataResponse {
    return new MsgSetBadgeMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetBadgeMetadataResponse {
    return new MsgSetBadgeMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetBadgeMetadataResponse | PlainMessage<MsgSetBadgeMetadataResponse> | undefined, b: MsgSetBadgeMetadataResponse | PlainMessage<MsgSetBadgeMetadataResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetBadgeMetadataResponse, a, b);
  }
}

/**
 * MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission
 *
 * @generated from message badges.MsgSetCustomData
 */
export class MsgSetCustomData extends Message<MsgSetCustomData> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New custom data timeline to set.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 3;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Permission to update custom data timeline
   *
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateCustomData = 4;
   */
  canUpdateCustomData: TimedUpdatePermission[] = [];

  constructor(data?: PartialMessage<MsgSetCustomData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCustomData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 4, name: "canUpdateCustomData", kind: "message", T: TimedUpdatePermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCustomData {
    return new MsgSetCustomData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCustomData {
    return new MsgSetCustomData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCustomData {
    return new MsgSetCustomData().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCustomData | PlainMessage<MsgSetCustomData> | undefined, b: MsgSetCustomData | PlainMessage<MsgSetCustomData> | undefined): boolean {
    return proto3.util.equals(MsgSetCustomData, a, b);
  }
}

/**
 * MsgSetCustomDataResponse is the response to MsgSetCustomData.
 *
 * @generated from message badges.MsgSetCustomDataResponse
 */
export class MsgSetCustomDataResponse extends Message<MsgSetCustomDataResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetCustomDataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCustomDataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCustomDataResponse {
    return new MsgSetCustomDataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCustomDataResponse {
    return new MsgSetCustomDataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCustomDataResponse {
    return new MsgSetCustomDataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCustomDataResponse | PlainMessage<MsgSetCustomDataResponse> | undefined, b: MsgSetCustomDataResponse | PlainMessage<MsgSetCustomDataResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetCustomDataResponse, a, b);
  }
}

/**
 * MsgSetStandards sets the standards timeline and canUpdateStandards permission
 *
 * @generated from message badges.MsgSetStandards
 */
export class MsgSetStandards extends Message<MsgSetStandards> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New standards timeline to set.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 3;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Permission to update standards timeline
   *
   * @generated from field: repeated badges.TimedUpdatePermission canUpdateStandards = 4;
   */
  canUpdateStandards: TimedUpdatePermission[] = [];

  constructor(data?: PartialMessage<MsgSetStandards>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetStandards";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 4, name: "canUpdateStandards", kind: "message", T: TimedUpdatePermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetStandards {
    return new MsgSetStandards().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetStandards {
    return new MsgSetStandards().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetStandards {
    return new MsgSetStandards().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetStandards | PlainMessage<MsgSetStandards> | undefined, b: MsgSetStandards | PlainMessage<MsgSetStandards> | undefined): boolean {
    return proto3.util.equals(MsgSetStandards, a, b);
  }
}

/**
 * MsgSetStandardsResponse is the response to MsgSetStandards.
 *
 * @generated from message badges.MsgSetStandardsResponse
 */
export class MsgSetStandardsResponse extends Message<MsgSetStandardsResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetStandardsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetStandardsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetStandardsResponse {
    return new MsgSetStandardsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetStandardsResponse {
    return new MsgSetStandardsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetStandardsResponse {
    return new MsgSetStandardsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetStandardsResponse | PlainMessage<MsgSetStandardsResponse> | undefined, b: MsgSetStandardsResponse | PlainMessage<MsgSetStandardsResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetStandardsResponse, a, b);
  }
}

/**
 * MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission
 *
 * @generated from message badges.MsgSetCollectionApprovals
 */
export class MsgSetCollectionApprovals extends Message<MsgSetCollectionApprovals> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 3;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Permission to update collection approvals
   *
   * @generated from field: repeated badges.CollectionApprovalPermission canUpdateCollectionApprovals = 4;
   */
  canUpdateCollectionApprovals: CollectionApprovalPermission[] = [];

  constructor(data?: PartialMessage<MsgSetCollectionApprovals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCollectionApprovals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 4, name: "canUpdateCollectionApprovals", kind: "message", T: CollectionApprovalPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCollectionApprovals {
    return new MsgSetCollectionApprovals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCollectionApprovals {
    return new MsgSetCollectionApprovals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCollectionApprovals {
    return new MsgSetCollectionApprovals().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCollectionApprovals | PlainMessage<MsgSetCollectionApprovals> | undefined, b: MsgSetCollectionApprovals | PlainMessage<MsgSetCollectionApprovals> | undefined): boolean {
    return proto3.util.equals(MsgSetCollectionApprovals, a, b);
  }
}

/**
 * MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.
 *
 * @generated from message badges.MsgSetCollectionApprovalsResponse
 */
export class MsgSetCollectionApprovalsResponse extends Message<MsgSetCollectionApprovalsResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetCollectionApprovalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCollectionApprovalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCollectionApprovalsResponse {
    return new MsgSetCollectionApprovalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCollectionApprovalsResponse {
    return new MsgSetCollectionApprovalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCollectionApprovalsResponse {
    return new MsgSetCollectionApprovalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCollectionApprovalsResponse | PlainMessage<MsgSetCollectionApprovalsResponse> | undefined, b: MsgSetCollectionApprovalsResponse | PlainMessage<MsgSetCollectionApprovalsResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetCollectionApprovalsResponse, a, b);
  }
}

/**
 * MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission
 *
 * @generated from message badges.MsgSetIsArchived
 */
export class MsgSetIsArchived extends Message<MsgSetIsArchived> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New isArchived timeline to set.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 3;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Permission to archive collection
   *
   * @generated from field: repeated badges.TimedUpdatePermission canArchiveCollection = 4;
   */
  canArchiveCollection: TimedUpdatePermission[] = [];

  constructor(data?: PartialMessage<MsgSetIsArchived>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetIsArchived";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 4, name: "canArchiveCollection", kind: "message", T: TimedUpdatePermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetIsArchived {
    return new MsgSetIsArchived().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetIsArchived {
    return new MsgSetIsArchived().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetIsArchived {
    return new MsgSetIsArchived().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetIsArchived | PlainMessage<MsgSetIsArchived> | undefined, b: MsgSetIsArchived | PlainMessage<MsgSetIsArchived> | undefined): boolean {
    return proto3.util.equals(MsgSetIsArchived, a, b);
  }
}

/**
 * MsgSetIsArchivedResponse is the response to MsgSetIsArchived.
 *
 * @generated from message badges.MsgSetIsArchivedResponse
 */
export class MsgSetIsArchivedResponse extends Message<MsgSetIsArchivedResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetIsArchivedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetIsArchivedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetIsArchivedResponse {
    return new MsgSetIsArchivedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetIsArchivedResponse {
    return new MsgSetIsArchivedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetIsArchivedResponse {
    return new MsgSetIsArchivedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetIsArchivedResponse | PlainMessage<MsgSetIsArchivedResponse> | undefined, b: MsgSetIsArchivedResponse | PlainMessage<MsgSetIsArchivedResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetIsArchivedResponse, a, b);
  }
}

