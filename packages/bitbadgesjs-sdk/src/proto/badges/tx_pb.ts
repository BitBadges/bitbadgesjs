// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file badges/tx.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Params } from "./params_pb.js";
import { Conversion, ConversionWithoutDenom, DenomUnit } from "./collections_pb.js";
import { CollectionMetadata, PathMetadata, TokenMetadata } from "./metadata_pb.js";
import { UserBalanceStore } from "./user_balance_store_pb.js";
import { UintRange } from "./balances_pb.js";
import { ActionPermission, CollectionApprovalPermission, CollectionPermissions, TokenIdsActionPermission, UserPermissions } from "./permissions_pb.js";
import { ApprovalIdentifierDetails, CollectionApproval, UserIncomingApproval, UserOutgoingApproval } from "./approvals_pb.js";
import { Coin } from "../cosmos/base/v1beta1/coin_pb.js";
import { AddressListInput } from "./address_lists_pb.js";
import { Transfer } from "./transfers_pb.js";

/**
 * Used for WASM bindings and JSON parsing
 *
 * @generated from message badges.BadgeCustomMsgType
 */
export class BadgeCustomMsgType extends Message<BadgeCustomMsgType> {
  /**
   * @generated from field: badges.MsgCreateAddressLists createAddressListsMsg = 1;
   */
  createAddressListsMsg?: MsgCreateAddressLists;

  /**
   * @generated from field: badges.MsgUniversalUpdateCollection universalUpdateCollectionMsg = 2;
   */
  universalUpdateCollectionMsg?: MsgUniversalUpdateCollection;

  /**
   * @generated from field: badges.MsgDeleteCollection deleteCollectionMsg = 3;
   */
  deleteCollectionMsg?: MsgDeleteCollection;

  /**
   * @generated from field: badges.MsgTransferTokens transferTokensMsg = 4;
   */
  transferTokensMsg?: MsgTransferTokens;

  /**
   * @generated from field: badges.MsgUpdateUserApprovals updateUserApprovalsMsg = 5;
   */
  updateUserApprovalsMsg?: MsgUpdateUserApprovals;

  /**
   * @generated from field: badges.MsgUpdateCollection updateCollectionMsg = 6;
   */
  updateCollectionMsg?: MsgUpdateCollection;

  /**
   * @generated from field: badges.MsgCreateCollection createCollectionMsg = 7;
   */
  createCollectionMsg?: MsgCreateCollection;

  /**
   * @generated from field: badges.MsgCreateDynamicStore createDynamicStoreMsg = 8;
   */
  createDynamicStoreMsg?: MsgCreateDynamicStore;

  /**
   * @generated from field: badges.MsgUpdateDynamicStore updateDynamicStoreMsg = 9;
   */
  updateDynamicStoreMsg?: MsgUpdateDynamicStore;

  /**
   * @generated from field: badges.MsgDeleteDynamicStore deleteDynamicStoreMsg = 10;
   */
  deleteDynamicStoreMsg?: MsgDeleteDynamicStore;

  /**
   * @generated from field: badges.MsgSetDynamicStoreValue setDynamicStoreValueMsg = 11;
   */
  setDynamicStoreValueMsg?: MsgSetDynamicStoreValue;

  /**
   * @generated from field: badges.MsgSetIncomingApproval setIncomingApprovalMsg = 14;
   */
  setIncomingApprovalMsg?: MsgSetIncomingApproval;

  /**
   * @generated from field: badges.MsgDeleteIncomingApproval deleteIncomingApprovalMsg = 15;
   */
  deleteIncomingApprovalMsg?: MsgDeleteIncomingApproval;

  /**
   * @generated from field: badges.MsgSetOutgoingApproval setOutgoingApprovalMsg = 16;
   */
  setOutgoingApprovalMsg?: MsgSetOutgoingApproval;

  /**
   * @generated from field: badges.MsgDeleteOutgoingApproval deleteOutgoingApprovalMsg = 17;
   */
  deleteOutgoingApprovalMsg?: MsgDeleteOutgoingApproval;

  /**
   * @generated from field: badges.MsgPurgeApprovals purgeApprovalsMsg = 18;
   */
  purgeApprovalsMsg?: MsgPurgeApprovals;

  /**
   * Helper message types for UniversalUpdateCollection subsets
   *
   * @generated from field: badges.MsgSetValidTokenIds setValidTokenIdsMsg = 19;
   */
  setValidTokenIdsMsg?: MsgSetValidTokenIds;

  /**
   * @generated from field: badges.MsgSetManager setManagerMsg = 20;
   */
  setManagerMsg?: MsgSetManager;

  /**
   * @generated from field: badges.MsgSetCollectionMetadata setCollectionMetadataMsg = 21;
   */
  setCollectionMetadataMsg?: MsgSetCollectionMetadata;

  /**
   * @generated from field: badges.MsgSetTokenMetadata setTokenMetadataMsg = 22;
   */
  setTokenMetadataMsg?: MsgSetTokenMetadata;

  /**
   * @generated from field: badges.MsgSetCustomData setCustomDataMsg = 23;
   */
  setCustomDataMsg?: MsgSetCustomData;

  /**
   * @generated from field: badges.MsgSetStandards setStandardsMsg = 24;
   */
  setStandardsMsg?: MsgSetStandards;

  /**
   * @generated from field: badges.MsgSetCollectionApprovals setCollectionApprovalsMsg = 25;
   */
  setCollectionApprovalsMsg?: MsgSetCollectionApprovals;

  /**
   * @generated from field: badges.MsgSetIsArchived setIsArchivedMsg = 26;
   */
  setIsArchivedMsg?: MsgSetIsArchived;

  /**
   * @generated from field: badges.MsgSetReservedProtocolAddress setReservedProtocolAddressMsg = 27;
   */
  setReservedProtocolAddressMsg?: MsgSetReservedProtocolAddress;

  /**
   * @generated from field: badges.MsgCastVote castVoteMsg = 28;
   */
  castVoteMsg?: MsgCastVote;

  constructor(data?: PartialMessage<BadgeCustomMsgType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BadgeCustomMsgType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "createAddressListsMsg", kind: "message", T: MsgCreateAddressLists },
    { no: 2, name: "universalUpdateCollectionMsg", kind: "message", T: MsgUniversalUpdateCollection },
    { no: 3, name: "deleteCollectionMsg", kind: "message", T: MsgDeleteCollection },
    { no: 4, name: "transferTokensMsg", kind: "message", T: MsgTransferTokens },
    { no: 5, name: "updateUserApprovalsMsg", kind: "message", T: MsgUpdateUserApprovals },
    { no: 6, name: "updateCollectionMsg", kind: "message", T: MsgUpdateCollection },
    { no: 7, name: "createCollectionMsg", kind: "message", T: MsgCreateCollection },
    { no: 8, name: "createDynamicStoreMsg", kind: "message", T: MsgCreateDynamicStore },
    { no: 9, name: "updateDynamicStoreMsg", kind: "message", T: MsgUpdateDynamicStore },
    { no: 10, name: "deleteDynamicStoreMsg", kind: "message", T: MsgDeleteDynamicStore },
    { no: 11, name: "setDynamicStoreValueMsg", kind: "message", T: MsgSetDynamicStoreValue },
    { no: 14, name: "setIncomingApprovalMsg", kind: "message", T: MsgSetIncomingApproval },
    { no: 15, name: "deleteIncomingApprovalMsg", kind: "message", T: MsgDeleteIncomingApproval },
    { no: 16, name: "setOutgoingApprovalMsg", kind: "message", T: MsgSetOutgoingApproval },
    { no: 17, name: "deleteOutgoingApprovalMsg", kind: "message", T: MsgDeleteOutgoingApproval },
    { no: 18, name: "purgeApprovalsMsg", kind: "message", T: MsgPurgeApprovals },
    { no: 19, name: "setValidTokenIdsMsg", kind: "message", T: MsgSetValidTokenIds },
    { no: 20, name: "setManagerMsg", kind: "message", T: MsgSetManager },
    { no: 21, name: "setCollectionMetadataMsg", kind: "message", T: MsgSetCollectionMetadata },
    { no: 22, name: "setTokenMetadataMsg", kind: "message", T: MsgSetTokenMetadata },
    { no: 23, name: "setCustomDataMsg", kind: "message", T: MsgSetCustomData },
    { no: 24, name: "setStandardsMsg", kind: "message", T: MsgSetStandards },
    { no: 25, name: "setCollectionApprovalsMsg", kind: "message", T: MsgSetCollectionApprovals },
    { no: 26, name: "setIsArchivedMsg", kind: "message", T: MsgSetIsArchived },
    { no: 27, name: "setReservedProtocolAddressMsg", kind: "message", T: MsgSetReservedProtocolAddress },
    { no: 28, name: "castVoteMsg", kind: "message", T: MsgCastVote },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromJsonString(jsonString, options);
  }

  static equals(a: BadgeCustomMsgType | PlainMessage<BadgeCustomMsgType> | undefined, b: BadgeCustomMsgType | PlainMessage<BadgeCustomMsgType> | undefined): boolean {
    return proto3.util.equals(BadgeCustomMsgType, a, b);
  }
}

/**
 * MsgUpdateParams is the Msg/UpdateParams request type.
 *
 * @generated from message badges.MsgUpdateParams
 */
export class MsgUpdateParams extends Message<MsgUpdateParams> {
  /**
   * authority is the address that controls the module (defaults to x/gov unless overwritten).
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * params defines the module parameters to update.
   *
   * NOTE: All parameters must be supplied.
   *
   * @generated from field: badges.Params params = 2;
   */
  params?: Params;

  constructor(data?: PartialMessage<MsgUpdateParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined, b: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParams, a, b);
  }
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 *
 * @generated from message badges.MsgUpdateParamsResponse
 */
export class MsgUpdateParamsResponse extends Message<MsgUpdateParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined, b: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParamsResponse, a, b);
  }
}

/**
 * @generated from message badges.CosmosCoinWrapperPathAddObject
 */
export class CosmosCoinWrapperPathAddObject extends Message<CosmosCoinWrapperPathAddObject> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: badges.ConversionWithoutDenom conversion = 2;
   */
  conversion?: ConversionWithoutDenom;

  /**
   * @generated from field: string symbol = 3;
   */
  symbol = "";

  /**
   * @generated from field: repeated badges.DenomUnit denomUnits = 4;
   */
  denomUnits: DenomUnit[] = [];

  /**
   * @generated from field: bool allowOverrideWithAnyValidToken = 5;
   */
  allowOverrideWithAnyValidToken = false;

  /**
   * The metadata for this wrapper path.
   *
   * @generated from field: badges.PathMetadata metadata = 6;
   */
  metadata?: PathMetadata;

  constructor(data?: PartialMessage<CosmosCoinWrapperPathAddObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CosmosCoinWrapperPathAddObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "conversion", kind: "message", T: ConversionWithoutDenom },
    { no: 3, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "denomUnits", kind: "message", T: DenomUnit, repeated: true },
    { no: 5, name: "allowOverrideWithAnyValidToken", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "metadata", kind: "message", T: PathMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CosmosCoinWrapperPathAddObject {
    return new CosmosCoinWrapperPathAddObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPathAddObject {
    return new CosmosCoinWrapperPathAddObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPathAddObject {
    return new CosmosCoinWrapperPathAddObject().fromJsonString(jsonString, options);
  }

  static equals(a: CosmosCoinWrapperPathAddObject | PlainMessage<CosmosCoinWrapperPathAddObject> | undefined, b: CosmosCoinWrapperPathAddObject | PlainMessage<CosmosCoinWrapperPathAddObject> | undefined): boolean {
    return proto3.util.equals(CosmosCoinWrapperPathAddObject, a, b);
  }
}

/**
 * @generated from message badges.AliasPathAddObject
 */
export class AliasPathAddObject extends Message<AliasPathAddObject> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: badges.ConversionWithoutDenom conversion = 2;
   */
  conversion?: ConversionWithoutDenom;

  /**
   * @generated from field: string symbol = 3;
   */
  symbol = "";

  /**
   * @generated from field: repeated badges.DenomUnit denomUnits = 4;
   */
  denomUnits: DenomUnit[] = [];

  /**
   * The metadata for this alias path.
   *
   * @generated from field: badges.PathMetadata metadata = 5;
   */
  metadata?: PathMetadata;

  constructor(data?: PartialMessage<AliasPathAddObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.AliasPathAddObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "conversion", kind: "message", T: ConversionWithoutDenom },
    { no: 3, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "denomUnits", kind: "message", T: DenomUnit, repeated: true },
    { no: 5, name: "metadata", kind: "message", T: PathMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AliasPathAddObject {
    return new AliasPathAddObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AliasPathAddObject {
    return new AliasPathAddObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AliasPathAddObject {
    return new AliasPathAddObject().fromJsonString(jsonString, options);
  }

  static equals(a: AliasPathAddObject | PlainMessage<AliasPathAddObject> | undefined, b: AliasPathAddObject | PlainMessage<AliasPathAddObject> | undefined): boolean {
    return proto3.util.equals(AliasPathAddObject, a, b);
  }
}

/**
 * @generated from message badges.CosmosCoinBackedPathAddObject
 */
export class CosmosCoinBackedPathAddObject extends Message<CosmosCoinBackedPathAddObject> {
  /**
   * @generated from field: badges.Conversion conversion = 1;
   */
  conversion?: Conversion;

  constructor(data?: PartialMessage<CosmosCoinBackedPathAddObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CosmosCoinBackedPathAddObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conversion", kind: "message", T: Conversion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CosmosCoinBackedPathAddObject {
    return new CosmosCoinBackedPathAddObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CosmosCoinBackedPathAddObject {
    return new CosmosCoinBackedPathAddObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CosmosCoinBackedPathAddObject {
    return new CosmosCoinBackedPathAddObject().fromJsonString(jsonString, options);
  }

  static equals(a: CosmosCoinBackedPathAddObject | PlainMessage<CosmosCoinBackedPathAddObject> | undefined, b: CosmosCoinBackedPathAddObject | PlainMessage<CosmosCoinBackedPathAddObject> | undefined): boolean {
    return proto3.util.equals(CosmosCoinBackedPathAddObject, a, b);
  }
}

/**
 * InvariantsAddObject is used for adding invariants without specifying addresses.
 * Addresses are generated by the keeper and stored in the collection.
 *
 * @generated from message badges.InvariantsAddObject
 */
export class InvariantsAddObject extends Message<InvariantsAddObject> {
  /**
   * If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
   * This prevents time-based restrictions on token ownership.
   *
   * @generated from field: bool noCustomOwnershipTimes = 1;
   */
  noCustomOwnershipTimes = false;

  /**
   * Maximum supply per token ID. If set, no balance can exceed this amount.
   * This prevents any single token ID from having more than the specified supply.
   *
   * @generated from field: string maxSupplyPerId = 2;
   */
  maxSupplyPerId = "";

  /**
   * The IBC backed (sdk.coin) path for the collection. Only one path is allowed.
   * Address will be generated by the keeper.
   *
   * @generated from field: badges.CosmosCoinBackedPathAddObject cosmosCoinBackedPath = 3;
   */
  cosmosCoinBackedPath?: CosmosCoinBackedPathAddObject;

  /**
   * If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.
   * This prevents forceful transfers that bypass user-level approvals.
   * This only applies to transfers where the from address does not equal "Mint".
   *
   * @generated from field: bool noForcefulPostMintTransfers = 4;
   */
  noForcefulPostMintTransfers = false;

  /**
   * If true, disallows pool creation with this collection's assets.
   * When true, any attempt to create a pool with badges assets from this collection will fail.
   *
   * @generated from field: bool disablePoolCreation = 5;
   */
  disablePoolCreation = false;

  constructor(data?: PartialMessage<InvariantsAddObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.InvariantsAddObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "noCustomOwnershipTimes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "maxSupplyPerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cosmosCoinBackedPath", kind: "message", T: CosmosCoinBackedPathAddObject },
    { no: 4, name: "noForcefulPostMintTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "disablePoolCreation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InvariantsAddObject {
    return new InvariantsAddObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InvariantsAddObject {
    return new InvariantsAddObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InvariantsAddObject {
    return new InvariantsAddObject().fromJsonString(jsonString, options);
  }

  static equals(a: InvariantsAddObject | PlainMessage<InvariantsAddObject> | undefined, b: InvariantsAddObject | PlainMessage<InvariantsAddObject> | undefined): boolean {
    return proto3.util.equals(InvariantsAddObject, a, b);
  }
}

/**
 * MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.
 * It is a universal interface that can be used for both creating and updating collections.
 * We have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.
 *
 * @generated from message badges.MsgUniversalUpdateCollection
 */
export class MsgUniversalUpdateCollection extends Message<MsgUniversalUpdateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection (0 for new collection).
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The default balances for the user
   *
   * @generated from field: badges.UserBalanceStore defaultBalances = 3;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateValidTokenIds = 4;
   */
  updateValidTokenIds = false;

  /**
   * New token IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validTokenIds = 5;
   */
  validTokenIds: UintRange[] = [];

  /**
   * Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionPermissions = 6;
   */
  updateCollectionPermissions = false;

  /**
   * New collection permissions to set.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 7;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Indicates if the manager should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateManager = 8;
   */
  updateManager = false;

  /**
   * New manager to set.
   *
   * @generated from field: string manager = 9;
   */
  manager = "";

  /**
   * Indicates if the collection metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionMetadata = 10;
   */
  updateCollectionMetadata = false;

  /**
   * New collection metadata to set.
   *
   * @generated from field: badges.CollectionMetadata collectionMetadata = 11;
   */
  collectionMetadata?: CollectionMetadata;

  /**
   * Indicates if the token metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateTokenMetadata = 12;
   */
  updateTokenMetadata = false;

  /**
   * New token metadata to set.
   *
   * @generated from field: repeated badges.TokenMetadata tokenMetadata = 13;
   */
  tokenMetadata: TokenMetadata[] = [];

  /**
   * Indicates if the custom data should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCustomData = 14;
   */
  updateCustomData = false;

  /**
   * New custom data to set.
   *
   * @generated from field: string customData = 15;
   */
  customData = "";

  /**
   * Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionApprovals = 16;
   */
  updateCollectionApprovals = false;

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 17;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Indicates if the standards should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateStandards = 18;
   */
  updateStandards = false;

  /**
   * New standards to set.
   *
   * @generated from field: repeated string standards = 19;
   */
  standards: string[] = [];

  /**
   * Indicates if the isArchived should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIsArchived = 20;
   */
  updateIsArchived = false;

  /**
   * New isArchived to set.
   *
   * @generated from field: bool isArchived = 21;
   */
  isArchived = false;

  /**
   * Coins to be transferred to the mint escrow address.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 22;
   */
  mintEscrowCoinsToTransfer: Coin[] = [];

  /**
   * IBC wrapper paths to add.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 23;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   * These are set upon genesis and cannot be modified.
   * Addresses are generated by the keeper and stored in the collection.
   *
   * @generated from field: badges.InvariantsAddObject invariants = 24;
   */
  invariants?: InvariantsAddObject;

  /**
   * Alias (non-wrapping) paths to add.
   *
   * @generated from field: repeated badges.AliasPathAddObject aliasPathsToAdd = 25;
   */
  aliasPathsToAdd: AliasPathAddObject[] = [];

  constructor(data?: PartialMessage<MsgUniversalUpdateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 4, name: "updateValidTokenIds", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "validTokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "updateCollectionPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 8, name: "updateManager", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "manager", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "updateCollectionMetadata", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "collectionMetadata", kind: "message", T: CollectionMetadata },
    { no: 12, name: "updateTokenMetadata", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "tokenMetadata", kind: "message", T: TokenMetadata, repeated: true },
    { no: 14, name: "updateCustomData", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "updateCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 18, name: "updateStandards", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "standards", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 20, name: "updateIsArchived", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 21, name: "isArchived", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "mintEscrowCoinsToTransfer", kind: "message", T: Coin, repeated: true },
    { no: 23, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
    { no: 24, name: "invariants", kind: "message", T: InvariantsAddObject },
    { no: 25, name: "aliasPathsToAdd", kind: "message", T: AliasPathAddObject, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollection | PlainMessage<MsgUniversalUpdateCollection> | undefined, b: MsgUniversalUpdateCollection | PlainMessage<MsgUniversalUpdateCollection> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollection, a, b);
  }
}

/**
 * MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.
 *
 * @generated from message badges.MsgUniversalUpdateCollectionResponse
 */
export class MsgUniversalUpdateCollectionResponse extends Message<MsgUniversalUpdateCollectionResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgUniversalUpdateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollectionResponse | PlainMessage<MsgUniversalUpdateCollectionResponse> | undefined, b: MsgUniversalUpdateCollectionResponse | PlainMessage<MsgUniversalUpdateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollectionResponse, a, b);
  }
}

/**
 * MsgUpdateCollection is used to update a collection.
 *
 * @generated from message badges.MsgUpdateCollection
 */
export class MsgUpdateCollection extends Message<MsgUpdateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection (0 for new collection).
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateValidTokenIds = 3;
   */
  updateValidTokenIds = false;

  /**
   * New token IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validTokenIds = 4;
   */
  validTokenIds: UintRange[] = [];

  /**
   * Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionPermissions = 5;
   */
  updateCollectionPermissions = false;

  /**
   * New collection permissions to set.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 6;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Indicates if the manager should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateManager = 7;
   */
  updateManager = false;

  /**
   * New manager to set.
   *
   * @generated from field: string manager = 8;
   */
  manager = "";

  /**
   * Indicates if the collection metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionMetadata = 9;
   */
  updateCollectionMetadata = false;

  /**
   * New collection metadata to set.
   *
   * @generated from field: badges.CollectionMetadata collectionMetadata = 10;
   */
  collectionMetadata?: CollectionMetadata;

  /**
   * Indicates if the token metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateTokenMetadata = 11;
   */
  updateTokenMetadata = false;

  /**
   * New token metadata to set.
   *
   * @generated from field: repeated badges.TokenMetadata tokenMetadata = 12;
   */
  tokenMetadata: TokenMetadata[] = [];

  /**
   * Indicates if the custom data should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCustomData = 13;
   */
  updateCustomData = false;

  /**
   * New custom data to set.
   *
   * @generated from field: string customData = 14;
   */
  customData = "";

  /**
   * Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionApprovals = 15;
   */
  updateCollectionApprovals = false;

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 16;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Indicates if the standards should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateStandards = 17;
   */
  updateStandards = false;

  /**
   * New standards to set.
   *
   * @generated from field: repeated string standards = 18;
   */
  standards: string[] = [];

  /**
   * Indicates if the isArchived should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIsArchived = 19;
   */
  updateIsArchived = false;

  /**
   * New isArchived to set.
   *
   * @generated from field: bool isArchived = 20;
   */
  isArchived = false;

  /**
   * Coins to be transferred to the mint escrow address.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 21;
   */
  mintEscrowCoinsToTransfer: Coin[] = [];

  /**
   * IBC wrapper paths to add.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 22;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   * These are set upon genesis and cannot be modified.
   * Addresses are generated by the keeper and stored in the collection.
   *
   * @generated from field: badges.InvariantsAddObject invariants = 23;
   */
  invariants?: InvariantsAddObject;

  /**
   * Alias (non-wrapping) paths to add.
   *
   * @generated from field: repeated badges.AliasPathAddObject aliasPathsToAdd = 24;
   */
  aliasPathsToAdd: AliasPathAddObject[] = [];

  constructor(data?: PartialMessage<MsgUpdateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "updateValidTokenIds", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "validTokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 5, name: "updateCollectionPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 7, name: "updateManager", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "manager", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "updateCollectionMetadata", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "collectionMetadata", kind: "message", T: CollectionMetadata },
    { no: 11, name: "updateTokenMetadata", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "tokenMetadata", kind: "message", T: TokenMetadata, repeated: true },
    { no: 13, name: "updateCustomData", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "updateCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 17, name: "updateStandards", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "standards", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 19, name: "updateIsArchived", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 20, name: "isArchived", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 21, name: "mintEscrowCoinsToTransfer", kind: "message", T: Coin, repeated: true },
    { no: 22, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
    { no: 23, name: "invariants", kind: "message", T: InvariantsAddObject },
    { no: 24, name: "aliasPathsToAdd", kind: "message", T: AliasPathAddObject, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateCollection | PlainMessage<MsgUpdateCollection> | undefined, b: MsgUpdateCollection | PlainMessage<MsgUpdateCollection> | undefined): boolean {
    return proto3.util.equals(MsgUpdateCollection, a, b);
  }
}

/**
 * MsgUpdateCollectionResponse is the response to MsgUpdateCollection.
 *
 * @generated from message badges.MsgUpdateCollectionResponse
 */
export class MsgUpdateCollectionResponse extends Message<MsgUpdateCollectionResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgUpdateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateCollectionResponse | PlainMessage<MsgUpdateCollectionResponse> | undefined, b: MsgUpdateCollectionResponse | PlainMessage<MsgUpdateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateCollectionResponse, a, b);
  }
}

/**
 * MsgCreateCollection is used to create a new collection.
 *
 * @generated from message badges.MsgCreateCollection
 */
export class MsgCreateCollection extends Message<MsgCreateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * The default balances for the user
   *
   * @generated from field: badges.UserBalanceStore defaultBalances = 2;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * New token IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validTokenIds = 3;
   */
  validTokenIds: UintRange[] = [];

  /**
   * Collection permissions.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 4;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Manager address.
   *
   * @generated from field: string manager = 5;
   */
  manager = "";

  /**
   * Collection metadata.
   *
   * @generated from field: badges.CollectionMetadata collectionMetadata = 6;
   */
  collectionMetadata?: CollectionMetadata;

  /**
   * Token metadata entries.
   *
   * @generated from field: repeated badges.TokenMetadata tokenMetadata = 7;
   */
  tokenMetadata: TokenMetadata[] = [];

  /**
   * Custom data.
   *
   * @generated from field: string customData = 8;
   */
  customData = "";

  /**
   * Collection approvals.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 9;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards entries.
   *
   * @generated from field: repeated string standards = 10;
   */
  standards: string[] = [];

  /**
   * isArchived flag.
   *
   * @generated from field: bool isArchived = 11;
   */
  isArchived = false;

  /**
   * Coins to be transferred to the mint escrow address.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 12;
   */
  mintEscrowCoinsToTransfer: Coin[] = [];

  /**
   * IBC wrapper paths to add.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 13;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   * Addresses are generated by the keeper and stored in the collection.
   *
   * @generated from field: badges.InvariantsAddObject invariants = 14;
   */
  invariants?: InvariantsAddObject;

  /**
   * Alias (non-wrapping) paths to add.
   *
   * @generated from field: repeated badges.AliasPathAddObject aliasPathsToAdd = 15;
   */
  aliasPathsToAdd: AliasPathAddObject[] = [];

  constructor(data?: PartialMessage<MsgCreateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 3, name: "validTokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 5, name: "manager", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "collectionMetadata", kind: "message", T: CollectionMetadata },
    { no: 7, name: "tokenMetadata", kind: "message", T: TokenMetadata, repeated: true },
    { no: 8, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 10, name: "standards", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "isArchived", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "mintEscrowCoinsToTransfer", kind: "message", T: Coin, repeated: true },
    { no: 13, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
    { no: 14, name: "invariants", kind: "message", T: InvariantsAddObject },
    { no: 15, name: "aliasPathsToAdd", kind: "message", T: AliasPathAddObject, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateCollection | PlainMessage<MsgCreateCollection> | undefined, b: MsgCreateCollection | PlainMessage<MsgCreateCollection> | undefined): boolean {
    return proto3.util.equals(MsgCreateCollection, a, b);
  }
}

/**
 * MsgCreateCollectionResponse is the response to MsgCreateCollection.
 *
 * @generated from message badges.MsgCreateCollectionResponse
 */
export class MsgCreateCollectionResponse extends Message<MsgCreateCollectionResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgCreateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateCollectionResponse | PlainMessage<MsgCreateCollectionResponse> | undefined, b: MsgCreateCollectionResponse | PlainMessage<MsgCreateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateCollectionResponse, a, b);
  }
}

/**
 * MsgCreateAddressLists is used to create address lists.
 *
 * @generated from message badges.MsgCreateAddressLists
 */
export class MsgCreateAddressLists extends Message<MsgCreateAddressLists> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * Address lists to create. The createdBy field will be automatically set to the creator address.
   *
   * @generated from field: repeated badges.AddressListInput addressLists = 2;
   */
  addressLists: AddressListInput[] = [];

  constructor(data?: PartialMessage<MsgCreateAddressLists>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateAddressLists";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "addressLists", kind: "message", T: AddressListInput, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateAddressLists {
    return new MsgCreateAddressLists().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateAddressLists {
    return new MsgCreateAddressLists().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateAddressLists {
    return new MsgCreateAddressLists().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateAddressLists | PlainMessage<MsgCreateAddressLists> | undefined, b: MsgCreateAddressLists | PlainMessage<MsgCreateAddressLists> | undefined): boolean {
    return proto3.util.equals(MsgCreateAddressLists, a, b);
  }
}

/**
 * MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.
 *
 * @generated from message badges.MsgCreateAddressListsResponse
 */
export class MsgCreateAddressListsResponse extends Message<MsgCreateAddressListsResponse> {
  constructor(data?: PartialMessage<MsgCreateAddressListsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateAddressListsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateAddressListsResponse {
    return new MsgCreateAddressListsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateAddressListsResponse {
    return new MsgCreateAddressListsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateAddressListsResponse {
    return new MsgCreateAddressListsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateAddressListsResponse | PlainMessage<MsgCreateAddressListsResponse> | undefined, b: MsgCreateAddressListsResponse | PlainMessage<MsgCreateAddressListsResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateAddressListsResponse, a, b);
  }
}

/**
 * MsgTransferTokens is used to transfer tokens.
 *
 * @generated from message badges.MsgTransferTokens
 */
export class MsgTransferTokens extends Message<MsgTransferTokens> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Transfers to execute.
   *
   * @generated from field: repeated badges.Transfer transfers = 3;
   */
  transfers: Transfer[] = [];

  constructor(data?: PartialMessage<MsgTransferTokens>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgTransferTokens";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transfers", kind: "message", T: Transfer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgTransferTokens {
    return new MsgTransferTokens().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgTransferTokens {
    return new MsgTransferTokens().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgTransferTokens {
    return new MsgTransferTokens().fromJsonString(jsonString, options);
  }

  static equals(a: MsgTransferTokens | PlainMessage<MsgTransferTokens> | undefined, b: MsgTransferTokens | PlainMessage<MsgTransferTokens> | undefined): boolean {
    return proto3.util.equals(MsgTransferTokens, a, b);
  }
}

/**
 * MsgTransferTokensResponse is the response to MsgTransferTokens.
 *
 * @generated from message badges.MsgTransferTokensResponse
 */
export class MsgTransferTokensResponse extends Message<MsgTransferTokensResponse> {
  constructor(data?: PartialMessage<MsgTransferTokensResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgTransferTokensResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgTransferTokensResponse {
    return new MsgTransferTokensResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgTransferTokensResponse {
    return new MsgTransferTokensResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgTransferTokensResponse {
    return new MsgTransferTokensResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgTransferTokensResponse | PlainMessage<MsgTransferTokensResponse> | undefined, b: MsgTransferTokensResponse | PlainMessage<MsgTransferTokensResponse> | undefined): boolean {
    return proto3.util.equals(MsgTransferTokensResponse, a, b);
  }
}

/**
 * MsgDeleteCollection is used to delete a collection.
 *
 * @generated from message badges.MsgDeleteCollection
 */
export class MsgDeleteCollection extends Message<MsgDeleteCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgDeleteCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteCollection | PlainMessage<MsgDeleteCollection> | undefined, b: MsgDeleteCollection | PlainMessage<MsgDeleteCollection> | undefined): boolean {
    return proto3.util.equals(MsgDeleteCollection, a, b);
  }
}

/**
 * MsgDeleteCollectionResponse is the response to MsgDeleteCollection.
 *
 * @generated from message badges.MsgDeleteCollectionResponse
 */
export class MsgDeleteCollectionResponse extends Message<MsgDeleteCollectionResponse> {
  constructor(data?: PartialMessage<MsgDeleteCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteCollectionResponse | PlainMessage<MsgDeleteCollectionResponse> | undefined, b: MsgDeleteCollectionResponse | PlainMessage<MsgDeleteCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteCollectionResponse, a, b);
  }
}

/**
 * MsgUpdateUserApprovals is used to update user approvals.
 *
 * @generated from message badges.MsgUpdateUserApprovals
 */
export class MsgUpdateUserApprovals extends Message<MsgUpdateUserApprovals> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOutgoingApprovals = 3;
   */
  updateOutgoingApprovals = false;

  /**
   * New outgoing approvals to set. 
   *
   * @generated from field: repeated badges.UserOutgoingApproval outgoingApprovals = 4;
   */
  outgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIncomingApprovals = 5;
   */
  updateIncomingApprovals = false;

  /**
   * New incoming approvals to set.
   *
   * @generated from field: repeated badges.UserIncomingApproval incomingApprovals = 6;
   */
  incomingApprovals: UserIncomingApproval[] = [];

  /**
   * Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveSelfInitiatedOutgoingTransfers = 7;
   */
  updateAutoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Auto-approve setting for self-initiated outgoing transfers.
   *
   * @generated from field: bool autoApproveSelfInitiatedOutgoingTransfers = 8;
   */
  autoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveSelfInitiatedIncomingTransfers = 9;
   */
  updateAutoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Auto-approve setting for self-initiated incoming transfers.
   *
   * @generated from field: bool autoApproveSelfInitiatedIncomingTransfers = 10;
   */
  autoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveAllIncomingTransfers = 11;
   */
  updateAutoApproveAllIncomingTransfers = false;

  /**
   * Auto-approve setting for all incoming transfers.
   *
   * @generated from field: bool autoApproveAllIncomingTransfers = 12;
   */
  autoApproveAllIncomingTransfers = false;

  /**
   * Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateUserPermissions = 13;
   */
  updateUserPermissions = false;

  /**
   * New user permissions to set.
   *
   * @generated from field: badges.UserPermissions userPermissions = 14;
   */
  userPermissions?: UserPermissions;

  constructor(data?: PartialMessage<MsgUpdateUserApprovals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserApprovals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "updateOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "outgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 5, name: "updateIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "incomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 7, name: "updateAutoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "autoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "updateAutoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "autoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "updateAutoApproveAllIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "autoApproveAllIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "updateUserPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "userPermissions", kind: "message", T: UserPermissions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserApprovals | PlainMessage<MsgUpdateUserApprovals> | undefined, b: MsgUpdateUserApprovals | PlainMessage<MsgUpdateUserApprovals> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserApprovals, a, b);
  }
}

/**
 * MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.
 *
 * @generated from message badges.MsgUpdateUserApprovalsResponse
 */
export class MsgUpdateUserApprovalsResponse extends Message<MsgUpdateUserApprovalsResponse> {
  constructor(data?: PartialMessage<MsgUpdateUserApprovalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserApprovalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserApprovalsResponse | PlainMessage<MsgUpdateUserApprovalsResponse> | undefined, b: MsgUpdateUserApprovalsResponse | PlainMessage<MsgUpdateUserApprovalsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserApprovalsResponse, a, b);
  }
}

/**
 * MsgSetIncomingApproval is a helper message to set a single incoming approval.
 *
 * @generated from message badges.MsgSetIncomingApproval
 */
export class MsgSetIncomingApproval extends Message<MsgSetIncomingApproval> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The incoming approval to set.
   *
   * @generated from field: badges.UserIncomingApproval approval = 3;
   */
  approval?: UserIncomingApproval;

  constructor(data?: PartialMessage<MsgSetIncomingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetIncomingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approval", kind: "message", T: UserIncomingApproval },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetIncomingApproval {
    return new MsgSetIncomingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetIncomingApproval {
    return new MsgSetIncomingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetIncomingApproval {
    return new MsgSetIncomingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetIncomingApproval | PlainMessage<MsgSetIncomingApproval> | undefined, b: MsgSetIncomingApproval | PlainMessage<MsgSetIncomingApproval> | undefined): boolean {
    return proto3.util.equals(MsgSetIncomingApproval, a, b);
  }
}

/**
 * MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.
 *
 * @generated from message badges.MsgSetIncomingApprovalResponse
 */
export class MsgSetIncomingApprovalResponse extends Message<MsgSetIncomingApprovalResponse> {
  constructor(data?: PartialMessage<MsgSetIncomingApprovalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetIncomingApprovalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetIncomingApprovalResponse {
    return new MsgSetIncomingApprovalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetIncomingApprovalResponse {
    return new MsgSetIncomingApprovalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetIncomingApprovalResponse {
    return new MsgSetIncomingApprovalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetIncomingApprovalResponse | PlainMessage<MsgSetIncomingApprovalResponse> | undefined, b: MsgSetIncomingApprovalResponse | PlainMessage<MsgSetIncomingApprovalResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetIncomingApprovalResponse, a, b);
  }
}

/**
 * MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.
 *
 * @generated from message badges.MsgDeleteIncomingApproval
 */
export class MsgDeleteIncomingApproval extends Message<MsgDeleteIncomingApproval> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The ID of the approval to delete.
   *
   * @generated from field: string approvalId = 3;
   */
  approvalId = "";

  constructor(data?: PartialMessage<MsgDeleteIncomingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteIncomingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteIncomingApproval {
    return new MsgDeleteIncomingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteIncomingApproval {
    return new MsgDeleteIncomingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteIncomingApproval {
    return new MsgDeleteIncomingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteIncomingApproval | PlainMessage<MsgDeleteIncomingApproval> | undefined, b: MsgDeleteIncomingApproval | PlainMessage<MsgDeleteIncomingApproval> | undefined): boolean {
    return proto3.util.equals(MsgDeleteIncomingApproval, a, b);
  }
}

/**
 * MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.
 *
 * @generated from message badges.MsgDeleteIncomingApprovalResponse
 */
export class MsgDeleteIncomingApprovalResponse extends Message<MsgDeleteIncomingApprovalResponse> {
  constructor(data?: PartialMessage<MsgDeleteIncomingApprovalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteIncomingApprovalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteIncomingApprovalResponse {
    return new MsgDeleteIncomingApprovalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteIncomingApprovalResponse {
    return new MsgDeleteIncomingApprovalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteIncomingApprovalResponse {
    return new MsgDeleteIncomingApprovalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteIncomingApprovalResponse | PlainMessage<MsgDeleteIncomingApprovalResponse> | undefined, b: MsgDeleteIncomingApprovalResponse | PlainMessage<MsgDeleteIncomingApprovalResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteIncomingApprovalResponse, a, b);
  }
}

/**
 * MsgSetOutgoingApproval is a helper message to set a single outgoing approval.
 *
 * @generated from message badges.MsgSetOutgoingApproval
 */
export class MsgSetOutgoingApproval extends Message<MsgSetOutgoingApproval> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The outgoing approval to set.
   *
   * @generated from field: badges.UserOutgoingApproval approval = 3;
   */
  approval?: UserOutgoingApproval;

  constructor(data?: PartialMessage<MsgSetOutgoingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetOutgoingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approval", kind: "message", T: UserOutgoingApproval },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetOutgoingApproval {
    return new MsgSetOutgoingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetOutgoingApproval {
    return new MsgSetOutgoingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetOutgoingApproval {
    return new MsgSetOutgoingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetOutgoingApproval | PlainMessage<MsgSetOutgoingApproval> | undefined, b: MsgSetOutgoingApproval | PlainMessage<MsgSetOutgoingApproval> | undefined): boolean {
    return proto3.util.equals(MsgSetOutgoingApproval, a, b);
  }
}

/**
 * MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.
 *
 * @generated from message badges.MsgSetOutgoingApprovalResponse
 */
export class MsgSetOutgoingApprovalResponse extends Message<MsgSetOutgoingApprovalResponse> {
  constructor(data?: PartialMessage<MsgSetOutgoingApprovalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetOutgoingApprovalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetOutgoingApprovalResponse {
    return new MsgSetOutgoingApprovalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetOutgoingApprovalResponse {
    return new MsgSetOutgoingApprovalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetOutgoingApprovalResponse {
    return new MsgSetOutgoingApprovalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetOutgoingApprovalResponse | PlainMessage<MsgSetOutgoingApprovalResponse> | undefined, b: MsgSetOutgoingApprovalResponse | PlainMessage<MsgSetOutgoingApprovalResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetOutgoingApprovalResponse, a, b);
  }
}

/**
 * MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.
 *
 * @generated from message badges.MsgDeleteOutgoingApproval
 */
export class MsgDeleteOutgoingApproval extends Message<MsgDeleteOutgoingApproval> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The ID of the approval to delete.
   *
   * @generated from field: string approvalId = 3;
   */
  approvalId = "";

  constructor(data?: PartialMessage<MsgDeleteOutgoingApproval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteOutgoingApproval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteOutgoingApproval {
    return new MsgDeleteOutgoingApproval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteOutgoingApproval {
    return new MsgDeleteOutgoingApproval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteOutgoingApproval {
    return new MsgDeleteOutgoingApproval().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteOutgoingApproval | PlainMessage<MsgDeleteOutgoingApproval> | undefined, b: MsgDeleteOutgoingApproval | PlainMessage<MsgDeleteOutgoingApproval> | undefined): boolean {
    return proto3.util.equals(MsgDeleteOutgoingApproval, a, b);
  }
}

/**
 * MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.
 *
 * @generated from message badges.MsgDeleteOutgoingApprovalResponse
 */
export class MsgDeleteOutgoingApprovalResponse extends Message<MsgDeleteOutgoingApprovalResponse> {
  constructor(data?: PartialMessage<MsgDeleteOutgoingApprovalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteOutgoingApprovalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteOutgoingApprovalResponse {
    return new MsgDeleteOutgoingApprovalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteOutgoingApprovalResponse {
    return new MsgDeleteOutgoingApprovalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteOutgoingApprovalResponse {
    return new MsgDeleteOutgoingApprovalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteOutgoingApprovalResponse | PlainMessage<MsgDeleteOutgoingApprovalResponse> | undefined, b: MsgDeleteOutgoingApprovalResponse | PlainMessage<MsgDeleteOutgoingApprovalResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteOutgoingApprovalResponse, a, b);
  }
}

/**
 * MsgPurgeApprovals is a helper message to purge expired approvals.
 *
 * @generated from message badges.MsgPurgeApprovals
 */
export class MsgPurgeApprovals extends Message<MsgPurgeApprovals> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Whether to purge expired approvals (approvals with no future valid transfer times).
   *
   * @generated from field: bool purgeExpired = 3;
   */
  purgeExpired = false;

  /**
   * Address of the user whose approvals to purge. If empty, defaults to creator.
   *
   * @generated from field: string approverAddress = 4;
   */
  approverAddress = "";

  /**
   * Whether to purge counterparty approvals (approvals where the creator is the only initiator).
   *
   * @generated from field: bool purgeCounterpartyApprovals = 5;
   */
  purgeCounterpartyApprovals = false;

  /**
   * Specific approvals to purge. If empty, purges all applicable approvals based on other flags.
   *
   * @generated from field: repeated badges.ApprovalIdentifierDetails approvalsToPurge = 6;
   */
  approvalsToPurge: ApprovalIdentifierDetails[] = [];

  constructor(data?: PartialMessage<MsgPurgeApprovals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgPurgeApprovals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "purgeExpired", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "approverAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "purgeCounterpartyApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "approvalsToPurge", kind: "message", T: ApprovalIdentifierDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgPurgeApprovals {
    return new MsgPurgeApprovals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgPurgeApprovals {
    return new MsgPurgeApprovals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgPurgeApprovals {
    return new MsgPurgeApprovals().fromJsonString(jsonString, options);
  }

  static equals(a: MsgPurgeApprovals | PlainMessage<MsgPurgeApprovals> | undefined, b: MsgPurgeApprovals | PlainMessage<MsgPurgeApprovals> | undefined): boolean {
    return proto3.util.equals(MsgPurgeApprovals, a, b);
  }
}

/**
 * MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.
 *
 * @generated from message badges.MsgPurgeApprovalsResponse
 */
export class MsgPurgeApprovalsResponse extends Message<MsgPurgeApprovalsResponse> {
  /**
   * Number of approvals purged.
   *
   * @generated from field: string numPurged = 1;
   */
  numPurged = "";

  constructor(data?: PartialMessage<MsgPurgeApprovalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgPurgeApprovalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "numPurged", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgPurgeApprovalsResponse {
    return new MsgPurgeApprovalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgPurgeApprovalsResponse {
    return new MsgPurgeApprovalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgPurgeApprovalsResponse {
    return new MsgPurgeApprovalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgPurgeApprovalsResponse | PlainMessage<MsgPurgeApprovalsResponse> | undefined, b: MsgPurgeApprovalsResponse | PlainMessage<MsgPurgeApprovalsResponse> | undefined): boolean {
    return proto3.util.equals(MsgPurgeApprovalsResponse, a, b);
  }
}

/**
 * MsgCreateDynamicStore is used to create a new dynamic store.
 *
 * @generated from message badges.MsgCreateDynamicStore
 */
export class MsgCreateDynamicStore extends Message<MsgCreateDynamicStore> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * The default value for uninitialized addresses (true/false).
   *
   * @generated from field: bool defaultValue = 2;
   */
  defaultValue = false;

  constructor(data?: PartialMessage<MsgCreateDynamicStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateDynamicStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "defaultValue", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDynamicStore {
    return new MsgCreateDynamicStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDynamicStore {
    return new MsgCreateDynamicStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDynamicStore {
    return new MsgCreateDynamicStore().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDynamicStore | PlainMessage<MsgCreateDynamicStore> | undefined, b: MsgCreateDynamicStore | PlainMessage<MsgCreateDynamicStore> | undefined): boolean {
    return proto3.util.equals(MsgCreateDynamicStore, a, b);
  }
}

/**
 * MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.
 *
 * @generated from message badges.MsgCreateDynamicStoreResponse
 */
export class MsgCreateDynamicStoreResponse extends Message<MsgCreateDynamicStoreResponse> {
  /**
   * ID of the dynamic store.
   *
   * @generated from field: string storeId = 1;
   */
  storeId = "";

  constructor(data?: PartialMessage<MsgCreateDynamicStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateDynamicStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDynamicStoreResponse {
    return new MsgCreateDynamicStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDynamicStoreResponse {
    return new MsgCreateDynamicStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDynamicStoreResponse {
    return new MsgCreateDynamicStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDynamicStoreResponse | PlainMessage<MsgCreateDynamicStoreResponse> | undefined, b: MsgCreateDynamicStoreResponse | PlainMessage<MsgCreateDynamicStoreResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateDynamicStoreResponse, a, b);
  }
}

/**
 * MsgUpdateDynamicStore is used to update an existing dynamic store.
 *
 * @generated from message badges.MsgUpdateDynamicStore
 */
export class MsgUpdateDynamicStore extends Message<MsgUpdateDynamicStore> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store to update.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  /**
   * The new default value for uninitialized addresses (true/false).
   *
   * @generated from field: bool defaultValue = 3;
   */
  defaultValue = false;

  constructor(data?: PartialMessage<MsgUpdateDynamicStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateDynamicStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "defaultValue", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateDynamicStore {
    return new MsgUpdateDynamicStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStore {
    return new MsgUpdateDynamicStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStore {
    return new MsgUpdateDynamicStore().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateDynamicStore | PlainMessage<MsgUpdateDynamicStore> | undefined, b: MsgUpdateDynamicStore | PlainMessage<MsgUpdateDynamicStore> | undefined): boolean {
    return proto3.util.equals(MsgUpdateDynamicStore, a, b);
  }
}

/**
 * MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.
 *
 * @generated from message badges.MsgUpdateDynamicStoreResponse
 */
export class MsgUpdateDynamicStoreResponse extends Message<MsgUpdateDynamicStoreResponse> {
  constructor(data?: PartialMessage<MsgUpdateDynamicStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateDynamicStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateDynamicStoreResponse {
    return new MsgUpdateDynamicStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStoreResponse {
    return new MsgUpdateDynamicStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStoreResponse {
    return new MsgUpdateDynamicStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateDynamicStoreResponse | PlainMessage<MsgUpdateDynamicStoreResponse> | undefined, b: MsgUpdateDynamicStoreResponse | PlainMessage<MsgUpdateDynamicStoreResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateDynamicStoreResponse, a, b);
  }
}

/**
 * MsgDeleteDynamicStore is used to delete a dynamic store.
 *
 * @generated from message badges.MsgDeleteDynamicStore
 */
export class MsgDeleteDynamicStore extends Message<MsgDeleteDynamicStore> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store to delete.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  constructor(data?: PartialMessage<MsgDeleteDynamicStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteDynamicStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteDynamicStore {
    return new MsgDeleteDynamicStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStore {
    return new MsgDeleteDynamicStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStore {
    return new MsgDeleteDynamicStore().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteDynamicStore | PlainMessage<MsgDeleteDynamicStore> | undefined, b: MsgDeleteDynamicStore | PlainMessage<MsgDeleteDynamicStore> | undefined): boolean {
    return proto3.util.equals(MsgDeleteDynamicStore, a, b);
  }
}

/**
 * MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.
 *
 * @generated from message badges.MsgDeleteDynamicStoreResponse
 */
export class MsgDeleteDynamicStoreResponse extends Message<MsgDeleteDynamicStoreResponse> {
  constructor(data?: PartialMessage<MsgDeleteDynamicStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteDynamicStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteDynamicStoreResponse {
    return new MsgDeleteDynamicStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStoreResponse {
    return new MsgDeleteDynamicStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStoreResponse {
    return new MsgDeleteDynamicStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteDynamicStoreResponse | PlainMessage<MsgDeleteDynamicStoreResponse> | undefined, b: MsgDeleteDynamicStoreResponse | PlainMessage<MsgDeleteDynamicStoreResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteDynamicStoreResponse, a, b);
  }
}

/**
 * MsgSetDynamicStoreValue is used to set a boolean value for a specific address in a dynamic store.
 *
 * @generated from message badges.MsgSetDynamicStoreValue
 */
export class MsgSetDynamicStoreValue extends Message<MsgSetDynamicStoreValue> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  /**
   * The address for which to set the value.
   *
   * @generated from field: string address = 3;
   */
  address = "";

  /**
   * The boolean value to set (true/false).
   *
   * @generated from field: bool value = 4;
   */
  value = false;

  constructor(data?: PartialMessage<MsgSetDynamicStoreValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetDynamicStoreValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "value", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDynamicStoreValue {
    return new MsgSetDynamicStoreValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValue {
    return new MsgSetDynamicStoreValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValue {
    return new MsgSetDynamicStoreValue().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDynamicStoreValue | PlainMessage<MsgSetDynamicStoreValue> | undefined, b: MsgSetDynamicStoreValue | PlainMessage<MsgSetDynamicStoreValue> | undefined): boolean {
    return proto3.util.equals(MsgSetDynamicStoreValue, a, b);
  }
}

/**
 * MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.
 *
 * @generated from message badges.MsgSetDynamicStoreValueResponse
 */
export class MsgSetDynamicStoreValueResponse extends Message<MsgSetDynamicStoreValueResponse> {
  constructor(data?: PartialMessage<MsgSetDynamicStoreValueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetDynamicStoreValueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDynamicStoreValueResponse {
    return new MsgSetDynamicStoreValueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValueResponse {
    return new MsgSetDynamicStoreValueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValueResponse {
    return new MsgSetDynamicStoreValueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDynamicStoreValueResponse | PlainMessage<MsgSetDynamicStoreValueResponse> | undefined, b: MsgSetDynamicStoreValueResponse | PlainMessage<MsgSetDynamicStoreValueResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetDynamicStoreValueResponse, a, b);
  }
}

/**
 * MsgSetValidTokenIds sets the validTokenIds and canUpdateValidTokenIds permission
 *
 * @generated from message badges.MsgSetValidTokenIds
 */
export class MsgSetValidTokenIds extends Message<MsgSetValidTokenIds> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New token IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validTokenIds = 3;
   */
  validTokenIds: UintRange[] = [];

  /**
   * Permission to update valid token IDs
   *
   * @generated from field: repeated badges.TokenIdsActionPermission canUpdateValidTokenIds = 4;
   */
  canUpdateValidTokenIds: TokenIdsActionPermission[] = [];

  constructor(data?: PartialMessage<MsgSetValidTokenIds>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetValidTokenIds";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "validTokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 4, name: "canUpdateValidTokenIds", kind: "message", T: TokenIdsActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetValidTokenIds {
    return new MsgSetValidTokenIds().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetValidTokenIds {
    return new MsgSetValidTokenIds().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetValidTokenIds {
    return new MsgSetValidTokenIds().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetValidTokenIds | PlainMessage<MsgSetValidTokenIds> | undefined, b: MsgSetValidTokenIds | PlainMessage<MsgSetValidTokenIds> | undefined): boolean {
    return proto3.util.equals(MsgSetValidTokenIds, a, b);
  }
}

/**
 * MsgSetValidTokenIdsResponse is the response to MsgSetValidTokenIds.
 *
 * @generated from message badges.MsgSetValidTokenIdsResponse
 */
export class MsgSetValidTokenIdsResponse extends Message<MsgSetValidTokenIdsResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetValidTokenIdsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetValidTokenIdsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetValidTokenIdsResponse {
    return new MsgSetValidTokenIdsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetValidTokenIdsResponse {
    return new MsgSetValidTokenIdsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetValidTokenIdsResponse {
    return new MsgSetValidTokenIdsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetValidTokenIdsResponse | PlainMessage<MsgSetValidTokenIdsResponse> | undefined, b: MsgSetValidTokenIdsResponse | PlainMessage<MsgSetValidTokenIdsResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetValidTokenIdsResponse, a, b);
  }
}

/**
 * MsgSetManager sets the manager and canUpdateManager permission
 *
 * @generated from message badges.MsgSetManager
 */
export class MsgSetManager extends Message<MsgSetManager> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New manager to set.
   *
   * @generated from field: string manager = 3;
   */
  manager = "";

  /**
   * Permission to update manager
   *
   * @generated from field: repeated badges.ActionPermission canUpdateManager = 4;
   */
  canUpdateManager: ActionPermission[] = [];

  constructor(data?: PartialMessage<MsgSetManager>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetManager";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "manager", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "canUpdateManager", kind: "message", T: ActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetManager {
    return new MsgSetManager().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetManager {
    return new MsgSetManager().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetManager {
    return new MsgSetManager().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetManager | PlainMessage<MsgSetManager> | undefined, b: MsgSetManager | PlainMessage<MsgSetManager> | undefined): boolean {
    return proto3.util.equals(MsgSetManager, a, b);
  }
}

/**
 * MsgSetManagerResponse is the response to MsgSetManager.
 *
 * @generated from message badges.MsgSetManagerResponse
 */
export class MsgSetManagerResponse extends Message<MsgSetManagerResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetManagerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetManagerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetManagerResponse {
    return new MsgSetManagerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetManagerResponse {
    return new MsgSetManagerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetManagerResponse {
    return new MsgSetManagerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetManagerResponse | PlainMessage<MsgSetManagerResponse> | undefined, b: MsgSetManagerResponse | PlainMessage<MsgSetManagerResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetManagerResponse, a, b);
  }
}

/**
 * MsgSetCollectionMetadata sets the collection metadata and canUpdateCollectionMetadata permission
 *
 * @generated from message badges.MsgSetCollectionMetadata
 */
export class MsgSetCollectionMetadata extends Message<MsgSetCollectionMetadata> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New collection metadata to set.
   *
   * @generated from field: badges.CollectionMetadata collectionMetadata = 3;
   */
  collectionMetadata?: CollectionMetadata;

  /**
   * Permission to update collection metadata
   *
   * @generated from field: repeated badges.ActionPermission canUpdateCollectionMetadata = 4;
   */
  canUpdateCollectionMetadata: ActionPermission[] = [];

  constructor(data?: PartialMessage<MsgSetCollectionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCollectionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "collectionMetadata", kind: "message", T: CollectionMetadata },
    { no: 4, name: "canUpdateCollectionMetadata", kind: "message", T: ActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCollectionMetadata {
    return new MsgSetCollectionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCollectionMetadata {
    return new MsgSetCollectionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCollectionMetadata {
    return new MsgSetCollectionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCollectionMetadata | PlainMessage<MsgSetCollectionMetadata> | undefined, b: MsgSetCollectionMetadata | PlainMessage<MsgSetCollectionMetadata> | undefined): boolean {
    return proto3.util.equals(MsgSetCollectionMetadata, a, b);
  }
}

/**
 * MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.
 *
 * @generated from message badges.MsgSetCollectionMetadataResponse
 */
export class MsgSetCollectionMetadataResponse extends Message<MsgSetCollectionMetadataResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetCollectionMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCollectionMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCollectionMetadataResponse {
    return new MsgSetCollectionMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCollectionMetadataResponse {
    return new MsgSetCollectionMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCollectionMetadataResponse {
    return new MsgSetCollectionMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCollectionMetadataResponse | PlainMessage<MsgSetCollectionMetadataResponse> | undefined, b: MsgSetCollectionMetadataResponse | PlainMessage<MsgSetCollectionMetadataResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetCollectionMetadataResponse, a, b);
  }
}

/**
 * MsgSetTokenMetadata sets the token metadata and canUpdateTokenMetadata permission
 *
 * @generated from message badges.MsgSetTokenMetadata
 */
export class MsgSetTokenMetadata extends Message<MsgSetTokenMetadata> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New token metadata to set.
   *
   * @generated from field: repeated badges.TokenMetadata tokenMetadata = 3;
   */
  tokenMetadata: TokenMetadata[] = [];

  /**
   * Permission to update token metadata
   *
   * @generated from field: repeated badges.TokenIdsActionPermission canUpdateTokenMetadata = 4;
   */
  canUpdateTokenMetadata: TokenIdsActionPermission[] = [];

  constructor(data?: PartialMessage<MsgSetTokenMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetTokenMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "tokenMetadata", kind: "message", T: TokenMetadata, repeated: true },
    { no: 4, name: "canUpdateTokenMetadata", kind: "message", T: TokenIdsActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetTokenMetadata {
    return new MsgSetTokenMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetTokenMetadata {
    return new MsgSetTokenMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetTokenMetadata {
    return new MsgSetTokenMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetTokenMetadata | PlainMessage<MsgSetTokenMetadata> | undefined, b: MsgSetTokenMetadata | PlainMessage<MsgSetTokenMetadata> | undefined): boolean {
    return proto3.util.equals(MsgSetTokenMetadata, a, b);
  }
}

/**
 * MsgSetTokenMetadataResponse is the response to MsgSetTokenMetadata.
 *
 * @generated from message badges.MsgSetTokenMetadataResponse
 */
export class MsgSetTokenMetadataResponse extends Message<MsgSetTokenMetadataResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetTokenMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetTokenMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetTokenMetadataResponse {
    return new MsgSetTokenMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetTokenMetadataResponse {
    return new MsgSetTokenMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetTokenMetadataResponse {
    return new MsgSetTokenMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetTokenMetadataResponse | PlainMessage<MsgSetTokenMetadataResponse> | undefined, b: MsgSetTokenMetadataResponse | PlainMessage<MsgSetTokenMetadataResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetTokenMetadataResponse, a, b);
  }
}

/**
 * MsgSetCustomData sets the custom data and canUpdateCustomData permission
 *
 * @generated from message badges.MsgSetCustomData
 */
export class MsgSetCustomData extends Message<MsgSetCustomData> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New custom data to set.
   *
   * @generated from field: string customData = 3;
   */
  customData = "";

  /**
   * Permission to update custom data
   *
   * @generated from field: repeated badges.ActionPermission canUpdateCustomData = 4;
   */
  canUpdateCustomData: ActionPermission[] = [];

  constructor(data?: PartialMessage<MsgSetCustomData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCustomData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "canUpdateCustomData", kind: "message", T: ActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCustomData {
    return new MsgSetCustomData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCustomData {
    return new MsgSetCustomData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCustomData {
    return new MsgSetCustomData().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCustomData | PlainMessage<MsgSetCustomData> | undefined, b: MsgSetCustomData | PlainMessage<MsgSetCustomData> | undefined): boolean {
    return proto3.util.equals(MsgSetCustomData, a, b);
  }
}

/**
 * MsgSetCustomDataResponse is the response to MsgSetCustomData.
 *
 * @generated from message badges.MsgSetCustomDataResponse
 */
export class MsgSetCustomDataResponse extends Message<MsgSetCustomDataResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetCustomDataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCustomDataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCustomDataResponse {
    return new MsgSetCustomDataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCustomDataResponse {
    return new MsgSetCustomDataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCustomDataResponse {
    return new MsgSetCustomDataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCustomDataResponse | PlainMessage<MsgSetCustomDataResponse> | undefined, b: MsgSetCustomDataResponse | PlainMessage<MsgSetCustomDataResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetCustomDataResponse, a, b);
  }
}

/**
 * MsgSetStandards sets the standards and canUpdateStandards permission
 *
 * @generated from message badges.MsgSetStandards
 */
export class MsgSetStandards extends Message<MsgSetStandards> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New standards to set.
   *
   * @generated from field: repeated string standards = 3;
   */
  standards: string[] = [];

  /**
   * Permission to update standards
   *
   * @generated from field: repeated badges.ActionPermission canUpdateStandards = 4;
   */
  canUpdateStandards: ActionPermission[] = [];

  constructor(data?: PartialMessage<MsgSetStandards>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetStandards";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "standards", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "canUpdateStandards", kind: "message", T: ActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetStandards {
    return new MsgSetStandards().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetStandards {
    return new MsgSetStandards().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetStandards {
    return new MsgSetStandards().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetStandards | PlainMessage<MsgSetStandards> | undefined, b: MsgSetStandards | PlainMessage<MsgSetStandards> | undefined): boolean {
    return proto3.util.equals(MsgSetStandards, a, b);
  }
}

/**
 * MsgSetStandardsResponse is the response to MsgSetStandards.
 *
 * @generated from message badges.MsgSetStandardsResponse
 */
export class MsgSetStandardsResponse extends Message<MsgSetStandardsResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetStandardsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetStandardsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetStandardsResponse {
    return new MsgSetStandardsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetStandardsResponse {
    return new MsgSetStandardsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetStandardsResponse {
    return new MsgSetStandardsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetStandardsResponse | PlainMessage<MsgSetStandardsResponse> | undefined, b: MsgSetStandardsResponse | PlainMessage<MsgSetStandardsResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetStandardsResponse, a, b);
  }
}

/**
 * MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission
 *
 * @generated from message badges.MsgSetCollectionApprovals
 */
export class MsgSetCollectionApprovals extends Message<MsgSetCollectionApprovals> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 3;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Permission to update collection approvals
   *
   * @generated from field: repeated badges.CollectionApprovalPermission canUpdateCollectionApprovals = 4;
   */
  canUpdateCollectionApprovals: CollectionApprovalPermission[] = [];

  constructor(data?: PartialMessage<MsgSetCollectionApprovals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCollectionApprovals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 4, name: "canUpdateCollectionApprovals", kind: "message", T: CollectionApprovalPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCollectionApprovals {
    return new MsgSetCollectionApprovals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCollectionApprovals {
    return new MsgSetCollectionApprovals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCollectionApprovals {
    return new MsgSetCollectionApprovals().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCollectionApprovals | PlainMessage<MsgSetCollectionApprovals> | undefined, b: MsgSetCollectionApprovals | PlainMessage<MsgSetCollectionApprovals> | undefined): boolean {
    return proto3.util.equals(MsgSetCollectionApprovals, a, b);
  }
}

/**
 * MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.
 *
 * @generated from message badges.MsgSetCollectionApprovalsResponse
 */
export class MsgSetCollectionApprovalsResponse extends Message<MsgSetCollectionApprovalsResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetCollectionApprovalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetCollectionApprovalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetCollectionApprovalsResponse {
    return new MsgSetCollectionApprovalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetCollectionApprovalsResponse {
    return new MsgSetCollectionApprovalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetCollectionApprovalsResponse {
    return new MsgSetCollectionApprovalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetCollectionApprovalsResponse | PlainMessage<MsgSetCollectionApprovalsResponse> | undefined, b: MsgSetCollectionApprovalsResponse | PlainMessage<MsgSetCollectionApprovalsResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetCollectionApprovalsResponse, a, b);
  }
}

/**
 * MsgSetIsArchived sets the isArchived and canArchiveCollection permission
 *
 * @generated from message badges.MsgSetIsArchived
 */
export class MsgSetIsArchived extends Message<MsgSetIsArchived> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * New isArchived to set.
   *
   * @generated from field: bool isArchived = 3;
   */
  isArchived = false;

  /**
   * Permission to archive collection
   *
   * @generated from field: repeated badges.ActionPermission canArchiveCollection = 4;
   */
  canArchiveCollection: ActionPermission[] = [];

  constructor(data?: PartialMessage<MsgSetIsArchived>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetIsArchived";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isArchived", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "canArchiveCollection", kind: "message", T: ActionPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetIsArchived {
    return new MsgSetIsArchived().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetIsArchived {
    return new MsgSetIsArchived().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetIsArchived {
    return new MsgSetIsArchived().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetIsArchived | PlainMessage<MsgSetIsArchived> | undefined, b: MsgSetIsArchived | PlainMessage<MsgSetIsArchived> | undefined): boolean {
    return proto3.util.equals(MsgSetIsArchived, a, b);
  }
}

/**
 * MsgSetIsArchivedResponse is the response to MsgSetIsArchived.
 *
 * @generated from message badges.MsgSetIsArchivedResponse
 */
export class MsgSetIsArchivedResponse extends Message<MsgSetIsArchivedResponse> {
  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgSetIsArchivedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetIsArchivedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetIsArchivedResponse {
    return new MsgSetIsArchivedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetIsArchivedResponse {
    return new MsgSetIsArchivedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetIsArchivedResponse {
    return new MsgSetIsArchivedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetIsArchivedResponse | PlainMessage<MsgSetIsArchivedResponse> | undefined, b: MsgSetIsArchivedResponse | PlainMessage<MsgSetIsArchivedResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetIsArchivedResponse, a, b);
  }
}

/**
 * MsgSetReservedProtocolAddress sets or unsets a reserved protocol address (governance-only).
 *
 * @generated from message badges.MsgSetReservedProtocolAddress
 */
export class MsgSetReservedProtocolAddress extends Message<MsgSetReservedProtocolAddress> {
  /**
   * authority is the address that controls the module (defaults to x/gov unless overwritten).
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * Address to set or unset as reserved protocol address.
   *
   * @generated from field: string address = 2;
   */
  address = "";

  /**
   * Whether the address should be a reserved protocol address (true) or not (false).
   *
   * @generated from field: bool isReservedProtocol = 3;
   */
  isReservedProtocol = false;

  constructor(data?: PartialMessage<MsgSetReservedProtocolAddress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetReservedProtocolAddress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isReservedProtocol", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetReservedProtocolAddress {
    return new MsgSetReservedProtocolAddress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetReservedProtocolAddress {
    return new MsgSetReservedProtocolAddress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetReservedProtocolAddress {
    return new MsgSetReservedProtocolAddress().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetReservedProtocolAddress | PlainMessage<MsgSetReservedProtocolAddress> | undefined, b: MsgSetReservedProtocolAddress | PlainMessage<MsgSetReservedProtocolAddress> | undefined): boolean {
    return proto3.util.equals(MsgSetReservedProtocolAddress, a, b);
  }
}

/**
 * MsgSetReservedProtocolAddressResponse is the response to MsgSetReservedProtocolAddress.
 *
 * @generated from message badges.MsgSetReservedProtocolAddressResponse
 */
export class MsgSetReservedProtocolAddressResponse extends Message<MsgSetReservedProtocolAddressResponse> {
  constructor(data?: PartialMessage<MsgSetReservedProtocolAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetReservedProtocolAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetReservedProtocolAddressResponse {
    return new MsgSetReservedProtocolAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetReservedProtocolAddressResponse {
    return new MsgSetReservedProtocolAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetReservedProtocolAddressResponse {
    return new MsgSetReservedProtocolAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetReservedProtocolAddressResponse | PlainMessage<MsgSetReservedProtocolAddressResponse> | undefined, b: MsgSetReservedProtocolAddressResponse | PlainMessage<MsgSetReservedProtocolAddressResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetReservedProtocolAddressResponse, a, b);
  }
}

/**
 * MsgCastVote allows a voter to cast or update their vote for a voting challenge.
 *
 * @generated from message badges.MsgCastVote
 */
export class MsgCastVote extends Message<MsgCastVote> {
  /**
   * The address of the voter casting the vote.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * The collection ID for the voting challenge.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * The approval level ("collection", "incoming", or "outgoing").
   *
   * @generated from field: string approvalLevel = 3;
   */
  approvalLevel = "";

  /**
   * The approver address (empty string for collection-level approvals).
   *
   * @generated from field: string approverAddress = 4;
   */
  approverAddress = "";

  /**
   * The approval ID.
   *
   * @generated from field: string approvalId = 5;
   */
  approvalId = "";

  /**
   * The proposal ID (challenge ID) from the VotingChallenge.
   *
   * @generated from field: string proposalId = 6;
   */
  proposalId = "";

  /**
   * The percentage weight (0-100) allocated to "yes" vote.
   * The remaining percentage (100 - yesWeight) is allocated to "no" vote.
   * Example: yesWeight=70 means 70% yes, 30% no.
   *
   * @generated from field: string yesWeight = 7;
   */
  yesWeight = "";

  constructor(data?: PartialMessage<MsgCastVote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCastVote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approvalLevel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "approverAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "proposalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "yesWeight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCastVote {
    return new MsgCastVote().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCastVote {
    return new MsgCastVote().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCastVote {
    return new MsgCastVote().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCastVote | PlainMessage<MsgCastVote> | undefined, b: MsgCastVote | PlainMessage<MsgCastVote> | undefined): boolean {
    return proto3.util.equals(MsgCastVote, a, b);
  }
}

/**
 * @generated from message badges.MsgCastVoteResponse
 */
export class MsgCastVoteResponse extends Message<MsgCastVoteResponse> {
  constructor(data?: PartialMessage<MsgCastVoteResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCastVoteResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCastVoteResponse {
    return new MsgCastVoteResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCastVoteResponse {
    return new MsgCastVoteResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCastVoteResponse {
    return new MsgCastVoteResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCastVoteResponse | PlainMessage<MsgCastVoteResponse> | undefined, b: MsgCastVoteResponse | PlainMessage<MsgCastVoteResponse> | undefined): boolean {
    return proto3.util.equals(MsgCastVoteResponse, a, b);
  }
}

