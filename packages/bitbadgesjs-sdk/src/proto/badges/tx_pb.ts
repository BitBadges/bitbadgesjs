// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file badges/tx.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Params } from "./params_pb.js";
import { Balance, UintRange } from "./balances_pb.js";
import { DenomUnit } from "./collections_pb.js";
import { CollectionApproval, Transfer, UserBalanceStore, UserIncomingApproval, UserOutgoingApproval } from "./transfers_pb.js";
import { CollectionPermissions, UserPermissions } from "./permissions_pb.js";
import { BadgeMetadataTimeline, CollectionMetadataTimeline, CustomDataTimeline, IsArchivedTimeline, ManagerTimeline, OffChainBalancesMetadataTimeline, StandardsTimeline } from "./timelines_pb.js";
import { Coin } from "../cosmos/base/v1beta1/coin_pb.js";
import { AddressList } from "./address_lists_pb.js";

/**
 * Used for WASM bindings and JSON parsing
 *
 * @generated from message badges.BadgeCustomMsgType
 */
export class BadgeCustomMsgType extends Message<BadgeCustomMsgType> {
  /**
   * @generated from field: badges.MsgCreateAddressLists createAddressListsMsg = 1;
   */
  createAddressListsMsg?: MsgCreateAddressLists;

  /**
   * @generated from field: badges.MsgUniversalUpdateCollection universalUpdateCollectionMsg = 2;
   */
  universalUpdateCollectionMsg?: MsgUniversalUpdateCollection;

  /**
   * @generated from field: badges.MsgDeleteCollection deleteCollectionMsg = 3;
   */
  deleteCollectionMsg?: MsgDeleteCollection;

  /**
   * @generated from field: badges.MsgTransferBadges transferBadgesMsg = 4;
   */
  transferBadgesMsg?: MsgTransferBadges;

  /**
   * @generated from field: badges.MsgUpdateUserApprovals updateUserApprovalsMsg = 5;
   */
  updateUserApprovalsMsg?: MsgUpdateUserApprovals;

  /**
   * @generated from field: badges.MsgUpdateCollection updateCollectionMsg = 6;
   */
  updateCollectionMsg?: MsgUpdateCollection;

  /**
   * @generated from field: badges.MsgCreateCollection createCollectionMsg = 7;
   */
  createCollectionMsg?: MsgCreateCollection;

  /**
   * @generated from field: badges.MsgCreateDynamicStore createDynamicStoreMsg = 8;
   */
  createDynamicStoreMsg?: MsgCreateDynamicStore;

  /**
   * @generated from field: badges.MsgUpdateDynamicStore updateDynamicStoreMsg = 9;
   */
  updateDynamicStoreMsg?: MsgUpdateDynamicStore;

  /**
   * @generated from field: badges.MsgDeleteDynamicStore deleteDynamicStoreMsg = 10;
   */
  deleteDynamicStoreMsg?: MsgDeleteDynamicStore;

  /**
   * @generated from field: badges.MsgSetDynamicStoreValue setDynamicStoreValueMsg = 11;
   */
  setDynamicStoreValueMsg?: MsgSetDynamicStoreValue;

  constructor(data?: PartialMessage<BadgeCustomMsgType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.BadgeCustomMsgType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "createAddressListsMsg", kind: "message", T: MsgCreateAddressLists },
    { no: 2, name: "universalUpdateCollectionMsg", kind: "message", T: MsgUniversalUpdateCollection },
    { no: 3, name: "deleteCollectionMsg", kind: "message", T: MsgDeleteCollection },
    { no: 4, name: "transferBadgesMsg", kind: "message", T: MsgTransferBadges },
    { no: 5, name: "updateUserApprovalsMsg", kind: "message", T: MsgUpdateUserApprovals },
    { no: 6, name: "updateCollectionMsg", kind: "message", T: MsgUpdateCollection },
    { no: 7, name: "createCollectionMsg", kind: "message", T: MsgCreateCollection },
    { no: 8, name: "createDynamicStoreMsg", kind: "message", T: MsgCreateDynamicStore },
    { no: 9, name: "updateDynamicStoreMsg", kind: "message", T: MsgUpdateDynamicStore },
    { no: 10, name: "deleteDynamicStoreMsg", kind: "message", T: MsgDeleteDynamicStore },
    { no: 11, name: "setDynamicStoreValueMsg", kind: "message", T: MsgSetDynamicStoreValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadgeCustomMsgType {
    return new BadgeCustomMsgType().fromJsonString(jsonString, options);
  }

  static equals(a: BadgeCustomMsgType | PlainMessage<BadgeCustomMsgType> | undefined, b: BadgeCustomMsgType | PlainMessage<BadgeCustomMsgType> | undefined): boolean {
    return proto3.util.equals(BadgeCustomMsgType, a, b);
  }
}

/**
 * MsgUpdateParams is the Msg/UpdateParams request type.
 *
 * @generated from message badges.MsgUpdateParams
 */
export class MsgUpdateParams extends Message<MsgUpdateParams> {
  /**
   * authority is the address that controls the module (defaults to x/gov unless overwritten).
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * params defines the module parameters to update.
   *
   * NOTE: All parameters must be supplied.
   *
   * @generated from field: badges.Params params = 2;
   */
  params?: Params;

  constructor(data?: PartialMessage<MsgUpdateParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined, b: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParams, a, b);
  }
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 *
 * @generated from message badges.MsgUpdateParamsResponse
 */
export class MsgUpdateParamsResponse extends Message<MsgUpdateParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined, b: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParamsResponse, a, b);
  }
}

/**
 * @generated from message badges.CosmosCoinWrapperPathAddObject
 */
export class CosmosCoinWrapperPathAddObject extends Message<CosmosCoinWrapperPathAddObject> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: repeated badges.Balance balances = 2;
   */
  balances: Balance[] = [];

  /**
   * @generated from field: string symbol = 3;
   */
  symbol = "";

  /**
   * @generated from field: repeated badges.DenomUnit denomUnits = 4;
   */
  denomUnits: DenomUnit[] = [];

  constructor(data?: PartialMessage<CosmosCoinWrapperPathAddObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.CosmosCoinWrapperPathAddObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 3, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "denomUnits", kind: "message", T: DenomUnit, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CosmosCoinWrapperPathAddObject {
    return new CosmosCoinWrapperPathAddObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPathAddObject {
    return new CosmosCoinWrapperPathAddObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPathAddObject {
    return new CosmosCoinWrapperPathAddObject().fromJsonString(jsonString, options);
  }

  static equals(a: CosmosCoinWrapperPathAddObject | PlainMessage<CosmosCoinWrapperPathAddObject> | undefined, b: CosmosCoinWrapperPathAddObject | PlainMessage<CosmosCoinWrapperPathAddObject> | undefined): boolean {
    return proto3.util.equals(CosmosCoinWrapperPathAddObject, a, b);
  }
}

/**
 * MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.
 * It is a universal interface that can be used for both creating and updating collections.
 * We have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.
 *
 * @generated from message badges.MsgUniversalUpdateCollection
 */
export class MsgUniversalUpdateCollection extends Message<MsgUniversalUpdateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection (0 for new collection).
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Type of balances "Standard" or "Off-Chain - Indexed" or "Off-Chain - Non-Indexed" or "Non-Public".
   *
   * @generated from field: string balancesType = 3;
   */
  balancesType = "";

  /**
   * The default balances for the user
   *
   * @generated from field: badges.UserBalanceStore defaultBalances = 4;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateValidBadgeIds = 5;
   */
  updateValidBadgeIds = false;

  /**
   * New badge IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validBadgeIds = 6;
   */
  validBadgeIds: UintRange[] = [];

  /**
   * Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionPermissions = 7;
   */
  updateCollectionPermissions = false;

  /**
   * New collection permissions to set.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 8;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateManagerTimeline = 9;
   */
  updateManagerTimeline = false;

  /**
   * New manager timeline to set.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 10;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionMetadataTimeline = 11;
   */
  updateCollectionMetadataTimeline = false;

  /**
   * New collection metadata timeline to set.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 12;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateBadgeMetadataTimeline = 13;
   */
  updateBadgeMetadataTimeline = false;

  /**
   * New badge metadata timeline to set.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 14;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOffChainBalancesMetadataTimeline = 15;
   */
  updateOffChainBalancesMetadataTimeline = false;

  /**
   * New off-chain balances metadata timeline to set.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 16;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCustomDataTimeline = 17;
   */
  updateCustomDataTimeline = false;

  /**
   * New custom data timeline to set.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 18;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionApprovals = 21;
   */
  updateCollectionApprovals = false;

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 22;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateStandardsTimeline = 23;
   */
  updateStandardsTimeline = false;

  /**
   * New standards timeline to set.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 24;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIsArchivedTimeline = 25;
   */
  updateIsArchivedTimeline = false;

  /**
   * New isArchived timeline to set.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 26;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Coins to be transferred to the mint escrow address.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 27;
   */
  mintEscrowCoinsToTransfer: Coin[] = [];

  /**
   * IBC wrapper paths to add.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 28;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  constructor(data?: PartialMessage<MsgUniversalUpdateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 5, name: "updateValidBadgeIds", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "validBadgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 7, name: "updateCollectionPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 9, name: "updateManagerTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 11, name: "updateCollectionMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 13, name: "updateBadgeMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 15, name: "updateOffChainBalancesMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 17, name: "updateCustomDataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 21, name: "updateCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 23, name: "updateStandardsTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 24, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 25, name: "updateIsArchivedTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 26, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 27, name: "mintEscrowCoinsToTransfer", kind: "message", T: Coin, repeated: true },
    { no: 28, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollection {
    return new MsgUniversalUpdateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollection | PlainMessage<MsgUniversalUpdateCollection> | undefined, b: MsgUniversalUpdateCollection | PlainMessage<MsgUniversalUpdateCollection> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollection, a, b);
  }
}

/**
 * MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.
 *
 * @generated from message badges.MsgUniversalUpdateCollectionResponse
 */
export class MsgUniversalUpdateCollectionResponse extends Message<MsgUniversalUpdateCollectionResponse> {
  /**
   * ID of the badge collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgUniversalUpdateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUniversalUpdateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUniversalUpdateCollectionResponse {
    return new MsgUniversalUpdateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUniversalUpdateCollectionResponse | PlainMessage<MsgUniversalUpdateCollectionResponse> | undefined, b: MsgUniversalUpdateCollectionResponse | PlainMessage<MsgUniversalUpdateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgUniversalUpdateCollectionResponse, a, b);
  }
}

/**
 * MsgUpdateCollection is used to update a collection.
 *
 * @generated from message badges.MsgUpdateCollection
 */
export class MsgUpdateCollection extends Message<MsgUpdateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection (0 for new collection).
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateValidBadgeIds = 3;
   */
  updateValidBadgeIds = false;

  /**
   * New badge IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validBadgeIds = 4;
   */
  validBadgeIds: UintRange[] = [];

  /**
   * Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionPermissions = 7;
   */
  updateCollectionPermissions = false;

  /**
   * New collection permissions to set.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 8;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateManagerTimeline = 9;
   */
  updateManagerTimeline = false;

  /**
   * New manager timeline to set.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 10;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionMetadataTimeline = 11;
   */
  updateCollectionMetadataTimeline = false;

  /**
   * New collection metadata timeline to set.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 12;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateBadgeMetadataTimeline = 13;
   */
  updateBadgeMetadataTimeline = false;

  /**
   * New badge metadata timeline to set.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 14;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOffChainBalancesMetadataTimeline = 15;
   */
  updateOffChainBalancesMetadataTimeline = false;

  /**
   * New off-chain balances metadata timeline to set.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 16;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCustomDataTimeline = 17;
   */
  updateCustomDataTimeline = false;

  /**
   * New custom data timeline to set.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 18;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateCollectionApprovals = 21;
   */
  updateCollectionApprovals = false;

  /**
   * New collection approvals to set.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 22;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateStandardsTimeline = 23;
   */
  updateStandardsTimeline = false;

  /**
   * New standards timeline to set.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 24;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIsArchivedTimeline = 27;
   */
  updateIsArchivedTimeline = false;

  /**
   * New isArchived timeline to set.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 28;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Coins to be transferred to the mint escrow address.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 29;
   */
  mintEscrowCoinsToTransfer: Coin[] = [];

  /**
   * IBC wrapper paths to add.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 30;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  constructor(data?: PartialMessage<MsgUpdateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "updateValidBadgeIds", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "validBadgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 7, name: "updateCollectionPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 9, name: "updateManagerTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 11, name: "updateCollectionMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 13, name: "updateBadgeMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 15, name: "updateOffChainBalancesMetadataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 17, name: "updateCustomDataTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 21, name: "updateCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 23, name: "updateStandardsTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 24, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 27, name: "updateIsArchivedTimeline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 28, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 29, name: "mintEscrowCoinsToTransfer", kind: "message", T: Coin, repeated: true },
    { no: 30, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateCollection {
    return new MsgUpdateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateCollection | PlainMessage<MsgUpdateCollection> | undefined, b: MsgUpdateCollection | PlainMessage<MsgUpdateCollection> | undefined): boolean {
    return proto3.util.equals(MsgUpdateCollection, a, b);
  }
}

/**
 * MsgUpdateCollectionResponse is the response to MsgUpdateCollection.
 *
 * @generated from message badges.MsgUpdateCollectionResponse
 */
export class MsgUpdateCollectionResponse extends Message<MsgUpdateCollectionResponse> {
  /**
   * ID of the badge collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgUpdateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateCollectionResponse {
    return new MsgUpdateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateCollectionResponse | PlainMessage<MsgUpdateCollectionResponse> | undefined, b: MsgUpdateCollectionResponse | PlainMessage<MsgUpdateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateCollectionResponse, a, b);
  }
}

/**
 * MsgCreateCollection is used to create a new collection.
 *
 * @generated from message badges.MsgCreateCollection
 */
export class MsgCreateCollection extends Message<MsgCreateCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * Type of balances "Standard" or "Off-Chain - Indexed" or "Off-Chain - Non-Indexed" or "Non-Public".
   *
   * @generated from field: string balancesType = 2;
   */
  balancesType = "";

  /**
   * The default balances for the user
   *
   * @generated from field: badges.UserBalanceStore defaultBalances = 4;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * New badge IDs to add to this collection
   *
   * @generated from field: repeated badges.UintRange validBadgeIds = 5;
   */
  validBadgeIds: UintRange[] = [];

  /**
   * Collection permissions.
   *
   * @generated from field: badges.CollectionPermissions collectionPermissions = 6;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Manager timeline entries.
   *
   * @generated from field: repeated badges.ManagerTimeline managerTimeline = 7;
   */
  managerTimeline: ManagerTimeline[] = [];

  /**
   * Collection metadata timeline entries.
   *
   * @generated from field: repeated badges.CollectionMetadataTimeline collectionMetadataTimeline = 8;
   */
  collectionMetadataTimeline: CollectionMetadataTimeline[] = [];

  /**
   * Badge metadata timeline entries.
   *
   * @generated from field: repeated badges.BadgeMetadataTimeline badgeMetadataTimeline = 9;
   */
  badgeMetadataTimeline: BadgeMetadataTimeline[] = [];

  /**
   * Off-chain balances metadata timeline entries.
   *
   * @generated from field: repeated badges.OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 10;
   */
  offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline[] = [];

  /**
   * Custom data timeline entries.
   *
   * @generated from field: repeated badges.CustomDataTimeline customDataTimeline = 11;
   */
  customDataTimeline: CustomDataTimeline[] = [];

  /**
   * Collection approvals.
   *
   * @generated from field: repeated badges.CollectionApproval collectionApprovals = 12;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards timeline entries.
   *
   * @generated from field: repeated badges.StandardsTimeline standardsTimeline = 13;
   */
  standardsTimeline: StandardsTimeline[] = [];

  /**
   * isArchived timeline entries.
   *
   * @generated from field: repeated badges.IsArchivedTimeline isArchivedTimeline = 14;
   */
  isArchivedTimeline: IsArchivedTimeline[] = [];

  /**
   * Coins to be transferred to the mint escrow address.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 16;
   */
  mintEscrowCoinsToTransfer: Coin[] = [];

  /**
   * IBC wrapper paths to add.
   *
   * @generated from field: repeated badges.CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 17;
   */
  cosmosCoinWrapperPathsToAdd: CosmosCoinWrapperPathAddObject[] = [];

  constructor(data?: PartialMessage<MsgCreateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "balancesType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 5, name: "validBadgeIds", kind: "message", T: UintRange, repeated: true },
    { no: 6, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 7, name: "managerTimeline", kind: "message", T: ManagerTimeline, repeated: true },
    { no: 8, name: "collectionMetadataTimeline", kind: "message", T: CollectionMetadataTimeline, repeated: true },
    { no: 9, name: "badgeMetadataTimeline", kind: "message", T: BadgeMetadataTimeline, repeated: true },
    { no: 10, name: "offChainBalancesMetadataTimeline", kind: "message", T: OffChainBalancesMetadataTimeline, repeated: true },
    { no: 11, name: "customDataTimeline", kind: "message", T: CustomDataTimeline, repeated: true },
    { no: 12, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 13, name: "standardsTimeline", kind: "message", T: StandardsTimeline, repeated: true },
    { no: 14, name: "isArchivedTimeline", kind: "message", T: IsArchivedTimeline, repeated: true },
    { no: 16, name: "mintEscrowCoinsToTransfer", kind: "message", T: Coin, repeated: true },
    { no: 17, name: "cosmosCoinWrapperPathsToAdd", kind: "message", T: CosmosCoinWrapperPathAddObject, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateCollection {
    return new MsgCreateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateCollection | PlainMessage<MsgCreateCollection> | undefined, b: MsgCreateCollection | PlainMessage<MsgCreateCollection> | undefined): boolean {
    return proto3.util.equals(MsgCreateCollection, a, b);
  }
}

/**
 * MsgCreateCollectionResponse is the response to MsgCreateCollection.
 *
 * @generated from message badges.MsgCreateCollectionResponse
 */
export class MsgCreateCollectionResponse extends Message<MsgCreateCollectionResponse> {
  /**
   * ID of the badge collection.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgCreateCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateCollectionResponse {
    return new MsgCreateCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateCollectionResponse | PlainMessage<MsgCreateCollectionResponse> | undefined, b: MsgCreateCollectionResponse | PlainMessage<MsgCreateCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateCollectionResponse, a, b);
  }
}

/**
 * MsgCreateAddressLists is used to create address lists.
 *
 * @generated from message badges.MsgCreateAddressLists
 */
export class MsgCreateAddressLists extends Message<MsgCreateAddressLists> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * Address lists to create.
   *
   * @generated from field: repeated badges.AddressList addressLists = 2;
   */
  addressLists: AddressList[] = [];

  constructor(data?: PartialMessage<MsgCreateAddressLists>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateAddressLists";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "addressLists", kind: "message", T: AddressList, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateAddressLists {
    return new MsgCreateAddressLists().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateAddressLists {
    return new MsgCreateAddressLists().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateAddressLists {
    return new MsgCreateAddressLists().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateAddressLists | PlainMessage<MsgCreateAddressLists> | undefined, b: MsgCreateAddressLists | PlainMessage<MsgCreateAddressLists> | undefined): boolean {
    return proto3.util.equals(MsgCreateAddressLists, a, b);
  }
}

/**
 * MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.
 *
 * @generated from message badges.MsgCreateAddressListsResponse
 */
export class MsgCreateAddressListsResponse extends Message<MsgCreateAddressListsResponse> {
  constructor(data?: PartialMessage<MsgCreateAddressListsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateAddressListsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateAddressListsResponse {
    return new MsgCreateAddressListsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateAddressListsResponse {
    return new MsgCreateAddressListsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateAddressListsResponse {
    return new MsgCreateAddressListsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateAddressListsResponse | PlainMessage<MsgCreateAddressListsResponse> | undefined, b: MsgCreateAddressListsResponse | PlainMessage<MsgCreateAddressListsResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateAddressListsResponse, a, b);
  }
}

/**
 * MsgTransferBadges is used to transfer badges.
 *
 * @generated from message badges.MsgTransferBadges
 */
export class MsgTransferBadges extends Message<MsgTransferBadges> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Transfers to execute.
   *
   * @generated from field: repeated badges.Transfer transfers = 3;
   */
  transfers: Transfer[] = [];

  constructor(data?: PartialMessage<MsgTransferBadges>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgTransferBadges";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transfers", kind: "message", T: Transfer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgTransferBadges {
    return new MsgTransferBadges().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgTransferBadges {
    return new MsgTransferBadges().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgTransferBadges {
    return new MsgTransferBadges().fromJsonString(jsonString, options);
  }

  static equals(a: MsgTransferBadges | PlainMessage<MsgTransferBadges> | undefined, b: MsgTransferBadges | PlainMessage<MsgTransferBadges> | undefined): boolean {
    return proto3.util.equals(MsgTransferBadges, a, b);
  }
}

/**
 * MsgTransferBadgesResponse is the response to MsgTransferBadges.
 *
 * @generated from message badges.MsgTransferBadgesResponse
 */
export class MsgTransferBadgesResponse extends Message<MsgTransferBadgesResponse> {
  constructor(data?: PartialMessage<MsgTransferBadgesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgTransferBadgesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgTransferBadgesResponse {
    return new MsgTransferBadgesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgTransferBadgesResponse {
    return new MsgTransferBadgesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgTransferBadgesResponse {
    return new MsgTransferBadgesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgTransferBadgesResponse | PlainMessage<MsgTransferBadgesResponse> | undefined, b: MsgTransferBadgesResponse | PlainMessage<MsgTransferBadgesResponse> | undefined): boolean {
    return proto3.util.equals(MsgTransferBadgesResponse, a, b);
  }
}

/**
 * MsgDeleteCollection is used to delete a collection.
 *
 * @generated from message badges.MsgDeleteCollection
 */
export class MsgDeleteCollection extends Message<MsgDeleteCollection> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  constructor(data?: PartialMessage<MsgDeleteCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteCollection {
    return new MsgDeleteCollection().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteCollection | PlainMessage<MsgDeleteCollection> | undefined, b: MsgDeleteCollection | PlainMessage<MsgDeleteCollection> | undefined): boolean {
    return proto3.util.equals(MsgDeleteCollection, a, b);
  }
}

/**
 * MsgDeleteCollectionResponse is the response to MsgDeleteCollection.
 *
 * @generated from message badges.MsgDeleteCollectionResponse
 */
export class MsgDeleteCollectionResponse extends Message<MsgDeleteCollectionResponse> {
  constructor(data?: PartialMessage<MsgDeleteCollectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteCollectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteCollectionResponse {
    return new MsgDeleteCollectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteCollectionResponse | PlainMessage<MsgDeleteCollectionResponse> | undefined, b: MsgDeleteCollectionResponse | PlainMessage<MsgDeleteCollectionResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteCollectionResponse, a, b);
  }
}

/**
 * MsgUpdateUserApprovals is used to update user approvals.
 *
 * @generated from message badges.MsgUpdateUserApprovals
 */
export class MsgUpdateUserApprovals extends Message<MsgUpdateUserApprovals> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the collection.
   *
   * @generated from field: string collectionId = 2;
   */
  collectionId = "";

  /**
   * Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateOutgoingApprovals = 3;
   */
  updateOutgoingApprovals = false;

  /**
   * New outgoing approvals to set. 
   *
   * @generated from field: repeated badges.UserOutgoingApproval outgoingApprovals = 4;
   */
  outgoingApprovals: UserOutgoingApproval[] = [];

  /**
   * Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateIncomingApprovals = 5;
   */
  updateIncomingApprovals = false;

  /**
   * New incoming approvals to set.
   *
   * @generated from field: repeated badges.UserIncomingApproval incomingApprovals = 6;
   */
  incomingApprovals: UserIncomingApproval[] = [];

  /**
   * Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveSelfInitiatedOutgoingTransfers = 7;
   */
  updateAutoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Auto-approve setting for self-initiated outgoing transfers.
   *
   * @generated from field: bool autoApproveSelfInitiatedOutgoingTransfers = 8;
   */
  autoApproveSelfInitiatedOutgoingTransfers = false;

  /**
   * Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveSelfInitiatedIncomingTransfers = 9;
   */
  updateAutoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Auto-approve setting for self-initiated incoming transfers.
   *
   * @generated from field: bool autoApproveSelfInitiatedIncomingTransfers = 10;
   */
  autoApproveSelfInitiatedIncomingTransfers = false;

  /**
   * Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateAutoApproveAllIncomingTransfers = 11;
   */
  updateAutoApproveAllIncomingTransfers = false;

  /**
   * Auto-approve setting for all incoming transfers.
   *
   * @generated from field: bool autoApproveAllIncomingTransfers = 12;
   */
  autoApproveAllIncomingTransfers = false;

  /**
   * Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
   *
   * @generated from field: bool updateUserPermissions = 13;
   */
  updateUserPermissions = false;

  /**
   * New user permissions to set.
   *
   * @generated from field: badges.UserPermissions userPermissions = 14;
   */
  userPermissions?: UserPermissions;

  constructor(data?: PartialMessage<MsgUpdateUserApprovals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserApprovals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "updateOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "outgoingApprovals", kind: "message", T: UserOutgoingApproval, repeated: true },
    { no: 5, name: "updateIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "incomingApprovals", kind: "message", T: UserIncomingApproval, repeated: true },
    { no: 7, name: "updateAutoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "autoApproveSelfInitiatedOutgoingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "updateAutoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "autoApproveSelfInitiatedIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "updateAutoApproveAllIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "autoApproveAllIncomingTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "updateUserPermissions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "userPermissions", kind: "message", T: UserPermissions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovals {
    return new MsgUpdateUserApprovals().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserApprovals | PlainMessage<MsgUpdateUserApprovals> | undefined, b: MsgUpdateUserApprovals | PlainMessage<MsgUpdateUserApprovals> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserApprovals, a, b);
  }
}

/**
 * MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.
 *
 * @generated from message badges.MsgUpdateUserApprovalsResponse
 */
export class MsgUpdateUserApprovalsResponse extends Message<MsgUpdateUserApprovalsResponse> {
  constructor(data?: PartialMessage<MsgUpdateUserApprovalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateUserApprovalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateUserApprovalsResponse {
    return new MsgUpdateUserApprovalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateUserApprovalsResponse | PlainMessage<MsgUpdateUserApprovalsResponse> | undefined, b: MsgUpdateUserApprovalsResponse | PlainMessage<MsgUpdateUserApprovalsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateUserApprovalsResponse, a, b);
  }
}

/**
 * MsgCreateDynamicStore is used to create a new dynamic store.
 *
 * @generated from message badges.MsgCreateDynamicStore
 */
export class MsgCreateDynamicStore extends Message<MsgCreateDynamicStore> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * The default value for uninitialized addresses.
   *
   * @generated from field: bool defaultValue = 2;
   */
  defaultValue = false;

  constructor(data?: PartialMessage<MsgCreateDynamicStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateDynamicStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "defaultValue", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDynamicStore {
    return new MsgCreateDynamicStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDynamicStore {
    return new MsgCreateDynamicStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDynamicStore {
    return new MsgCreateDynamicStore().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDynamicStore | PlainMessage<MsgCreateDynamicStore> | undefined, b: MsgCreateDynamicStore | PlainMessage<MsgCreateDynamicStore> | undefined): boolean {
    return proto3.util.equals(MsgCreateDynamicStore, a, b);
  }
}

/**
 * MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.
 *
 * @generated from message badges.MsgCreateDynamicStoreResponse
 */
export class MsgCreateDynamicStoreResponse extends Message<MsgCreateDynamicStoreResponse> {
  /**
   * ID of the dynamic store.
   *
   * @generated from field: string storeId = 1;
   */
  storeId = "";

  constructor(data?: PartialMessage<MsgCreateDynamicStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgCreateDynamicStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDynamicStoreResponse {
    return new MsgCreateDynamicStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDynamicStoreResponse {
    return new MsgCreateDynamicStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDynamicStoreResponse {
    return new MsgCreateDynamicStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDynamicStoreResponse | PlainMessage<MsgCreateDynamicStoreResponse> | undefined, b: MsgCreateDynamicStoreResponse | PlainMessage<MsgCreateDynamicStoreResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateDynamicStoreResponse, a, b);
  }
}

/**
 * MsgUpdateDynamicStore is used to update an existing dynamic store.
 *
 * @generated from message badges.MsgUpdateDynamicStore
 */
export class MsgUpdateDynamicStore extends Message<MsgUpdateDynamicStore> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store to update.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  /**
   * The new default value for uninitialized addresses (optional, only set if updating).
   *
   * @generated from field: bool defaultValue = 3;
   */
  defaultValue = false;

  constructor(data?: PartialMessage<MsgUpdateDynamicStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateDynamicStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "defaultValue", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateDynamicStore {
    return new MsgUpdateDynamicStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStore {
    return new MsgUpdateDynamicStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStore {
    return new MsgUpdateDynamicStore().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateDynamicStore | PlainMessage<MsgUpdateDynamicStore> | undefined, b: MsgUpdateDynamicStore | PlainMessage<MsgUpdateDynamicStore> | undefined): boolean {
    return proto3.util.equals(MsgUpdateDynamicStore, a, b);
  }
}

/**
 * MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.
 *
 * @generated from message badges.MsgUpdateDynamicStoreResponse
 */
export class MsgUpdateDynamicStoreResponse extends Message<MsgUpdateDynamicStoreResponse> {
  constructor(data?: PartialMessage<MsgUpdateDynamicStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgUpdateDynamicStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateDynamicStoreResponse {
    return new MsgUpdateDynamicStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStoreResponse {
    return new MsgUpdateDynamicStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateDynamicStoreResponse {
    return new MsgUpdateDynamicStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateDynamicStoreResponse | PlainMessage<MsgUpdateDynamicStoreResponse> | undefined, b: MsgUpdateDynamicStoreResponse | PlainMessage<MsgUpdateDynamicStoreResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateDynamicStoreResponse, a, b);
  }
}

/**
 * MsgDeleteDynamicStore is used to delete a dynamic store.
 *
 * @generated from message badges.MsgDeleteDynamicStore
 */
export class MsgDeleteDynamicStore extends Message<MsgDeleteDynamicStore> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store to delete.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  constructor(data?: PartialMessage<MsgDeleteDynamicStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteDynamicStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteDynamicStore {
    return new MsgDeleteDynamicStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStore {
    return new MsgDeleteDynamicStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStore {
    return new MsgDeleteDynamicStore().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteDynamicStore | PlainMessage<MsgDeleteDynamicStore> | undefined, b: MsgDeleteDynamicStore | PlainMessage<MsgDeleteDynamicStore> | undefined): boolean {
    return proto3.util.equals(MsgDeleteDynamicStore, a, b);
  }
}

/**
 * MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.
 *
 * @generated from message badges.MsgDeleteDynamicStoreResponse
 */
export class MsgDeleteDynamicStoreResponse extends Message<MsgDeleteDynamicStoreResponse> {
  constructor(data?: PartialMessage<MsgDeleteDynamicStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgDeleteDynamicStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDeleteDynamicStoreResponse {
    return new MsgDeleteDynamicStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStoreResponse {
    return new MsgDeleteDynamicStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDeleteDynamicStoreResponse {
    return new MsgDeleteDynamicStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDeleteDynamicStoreResponse | PlainMessage<MsgDeleteDynamicStoreResponse> | undefined, b: MsgDeleteDynamicStoreResponse | PlainMessage<MsgDeleteDynamicStoreResponse> | undefined): boolean {
    return proto3.util.equals(MsgDeleteDynamicStoreResponse, a, b);
  }
}

/**
 * MsgSetDynamicStoreValue is used to set a 0/1 flag for a specific address in a dynamic store.
 *
 * @generated from message badges.MsgSetDynamicStoreValue
 */
export class MsgSetDynamicStoreValue extends Message<MsgSetDynamicStoreValue> {
  /**
   * Address of the creator.
   *
   * @generated from field: string creator = 1;
   */
  creator = "";

  /**
   * ID of the dynamic store.
   *
   * @generated from field: string storeId = 2;
   */
  storeId = "";

  /**
   * The address for which to set the value.
   *
   * @generated from field: string address = 3;
   */
  address = "";

  /**
   * The boolean value to set (true = 1, false = 0).
   *
   * @generated from field: bool value = 4;
   */
  value = false;

  constructor(data?: PartialMessage<MsgSetDynamicStoreValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetDynamicStoreValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storeId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "value", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDynamicStoreValue {
    return new MsgSetDynamicStoreValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValue {
    return new MsgSetDynamicStoreValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValue {
    return new MsgSetDynamicStoreValue().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDynamicStoreValue | PlainMessage<MsgSetDynamicStoreValue> | undefined, b: MsgSetDynamicStoreValue | PlainMessage<MsgSetDynamicStoreValue> | undefined): boolean {
    return proto3.util.equals(MsgSetDynamicStoreValue, a, b);
  }
}

/**
 * MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.
 *
 * @generated from message badges.MsgSetDynamicStoreValueResponse
 */
export class MsgSetDynamicStoreValueResponse extends Message<MsgSetDynamicStoreValueResponse> {
  constructor(data?: PartialMessage<MsgSetDynamicStoreValueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.MsgSetDynamicStoreValueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDynamicStoreValueResponse {
    return new MsgSetDynamicStoreValueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValueResponse {
    return new MsgSetDynamicStoreValueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDynamicStoreValueResponse {
    return new MsgSetDynamicStoreValueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDynamicStoreValueResponse | PlainMessage<MsgSetDynamicStoreValueResponse> | undefined, b: MsgSetDynamicStoreValueResponse | PlainMessage<MsgSetDynamicStoreValueResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetDynamicStoreValueResponse, a, b);
  }
}

