// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file badges/approval_criteria.proto (package badges, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ETHSignatureChallenge, MerkleChallenge, VotingChallenge } from "./challenges_pb.js";
import { PredeterminedBalances } from "./predetermined_balances_pb.js";
import { ApprovalAmounts, AutoDeletionOptions, MaxNumTransfers } from "./approval_tracking_pb.js";
import { AddressChecks, AltTimeChecks, CoinTransfer, DynamicStoreChallenge, MustOwnTokens, UserRoyalties } from "./approval_conditions_pb.js";

/**
 * ApprovalCriteria defines the criteria for approving transfers.
 * All criteria must be satisfied for the approval to be considered valid.
 *
 * @generated from message badges.ApprovalCriteria
 */
export class ApprovalCriteria extends Message<ApprovalCriteria> {
  /**
   * Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs
   * that satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.
   *
   * @generated from field: repeated badges.MerkleChallenge merkleChallenges = 1;
   */
  merkleChallenges: MerkleChallenge[] = [];

  /**
   * Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs
   * that can be transferred when using this approval.
   *
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 2;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts
   * transferred and enforces maximum limits per approval.
   *
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 3;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * Maximum number of transfers that can be processed using this approval. Tracks the count of transfers
   * and enforces the limit to prevent exceeding the allowed number of uses.
   *
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 4;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,
   * royalties) that must be executed alongside the badge transfer for the approval to be valid.
   *
   * @generated from field: repeated badges.CoinTransfer coinTransfers = 5;
   */
  coinTransfers: CoinTransfer[] = [];

  /**
   * Require the "to" address to be equal to the "initiated by" address for approval.
   * If true, only transfers where the recipient matches the initiator are allowed.
   *
   * @generated from field: bool requireToEqualsInitiatedBy = 6;
   */
  requireToEqualsInitiatedBy = false;

  /**
   * Require the "from" address to be equal to the "initiated by" address for approval.
   * If true, only transfers where the sender matches the initiator are allowed.
   *
   * @generated from field: bool requireFromEqualsInitiatedBy = 7;
   */
  requireFromEqualsInitiatedBy = false;

  /**
   * Require the "to" address to not be equal to the "initiated by" address for approval.
   * If true, transfers where the recipient equals the initiator are forbidden.
   *
   * @generated from field: bool requireToDoesNotEqualInitiatedBy = 8;
   */
  requireToDoesNotEqualInitiatedBy = false;

  /**
   * Require the "from" address to not be equal to the "initiated by" address for approval.
   * If true, transfers where the sender equals the initiator are forbidden.
   *
   * @generated from field: bool requireFromDoesNotEqualInitiatedBy = 9;
   */
  requireFromDoesNotEqualInitiatedBy = false;

  /**
   * Overrides the user's outgoing approvals for approval. If true, this collection-level approval
   * takes precedence over any outgoing approvals defined by the sender, allowing the collection to
   * control outgoing transfer behavior.
   *
   * @generated from field: bool overridesFromOutgoingApprovals = 10;
   */
  overridesFromOutgoingApprovals = false;

  /**
   * Overrides the user's incoming approvals for approval. If true, this collection-level approval
   * takes precedence over any incoming approvals defined by the recipient, allowing the collection to
   * control incoming transfer behavior.
   *
   * @generated from field: bool overridesToIncomingApprovals = 11;
   */
  overridesToIncomingApprovals = false;

  /**
   * Auto-deletion options for this approval. Defines conditions under which this approval should be
   * automatically deleted (e.g., after a certain number of uses or time period).
   *
   * @generated from field: badges.AutoDeletionOptions autoDeletionOptions = 12;
   */
  autoDeletionOptions?: AutoDeletionOptions;

  /**
   * User level royalties to apply to the transfer. Defines the percentage and payout address for
   * royalties that should be collected when this approval is used for a transfer.
   *
   * @generated from field: badges.UserRoyalties userRoyalties = 13;
   */
  userRoyalties?: UserRoyalties;

  /**
   * Must own tokens for approval. Defines token ownership requirements that must be satisfied for
   * the approval to be valid. The initiator must own the specified tokens at the specified ownership times.
   *
   * @generated from field: repeated badges.MustOwnTokens mustOwnTokens = 14;
   */
  mustOwnTokens: MustOwnTokens[] = [];

  /**
   * Dynamic store challenges that the initiator must pass for approval. The initiator must provide
   * valid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).
   *
   * @generated from field: repeated badges.DynamicStoreChallenge dynamicStoreChallenges = 15;
   */
  dynamicStoreChallenges: DynamicStoreChallenge[] = [];

  /**
   * ETH signature challenges that the initiator must pass for approval. The initiator must provide
   * valid Ethereum signatures for all specified challenges. Each signature can only be used once.
   *
   * @generated from field: repeated badges.ETHSignatureChallenge ethSignatureChallenges = 16;
   */
  ethSignatureChallenges: ETHSignatureChallenge[] = [];

  /**
   * Address checks for the sender of the transfer. Validates that the sender address meets the
   * specified criteria (e.g., whitelist, blacklist, protocol address requirements).
   *
   * @generated from field: badges.AddressChecks senderChecks = 17;
   */
  senderChecks?: AddressChecks;

  /**
   * Address checks for the recipient of the transfer. Validates that the recipient address meets the
   * specified criteria (e.g., whitelist, blacklist, protocol address requirements).
   *
   * @generated from field: badges.AddressChecks recipientChecks = 18;
   */
  recipientChecks?: AddressChecks;

  /**
   * Address checks for the initiator of the transfer. Validates that the initiator address meets the
   * specified criteria (e.g., whitelist, blacklist, protocol address requirements).
   *
   * @generated from field: badges.AddressChecks initiatorChecks = 19;
   */
  initiatorChecks?: AddressChecks;

  /**
   * Alternative time-based checks for approval denial (offline hours/days). Defines time periods
   * during which this approval should be denied, such as specific hours of the day or days of the week.
   *
   * @generated from field: badges.AltTimeChecks altTimeChecks = 20;
   */
  altTimeChecks?: AltTimeChecks;

  /**
   * If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
   * This allows fine-grained control over which approvals are applied when multiple approvals could match.
   *
   * @generated from field: bool mustPrioritize = 21;
   */
  mustPrioritize = false;

  /**
   * Voting challenges that must be satisfied for approval. The initiator must provide
   * valid votes that meet the quorum threshold for all specified challenges.
   *
   * @generated from field: repeated badges.VotingChallenge votingChallenges = 22;
   */
  votingChallenges: VotingChallenge[] = [];

  /**
   * If true, this collection approval allows backed minting operations (CosmosCoinBackedPath).
   * When false, this approval cannot be used for transfers involving backed minting addresses.
   * This prevents accidental allowances when toListIds is "All".
   *
   * @generated from field: bool allowBackedMinting = 23;
   */
  allowBackedMinting = false;

  /**
   * If true, this collection approval allows special wrapping operations (CosmosCoinWrapperPath).
   * When false, this approval cannot be used for transfers involving wrapping addresses.
   * This prevents accidental allowances when toListIds is "All".
   *
   * @generated from field: bool allowSpecialWrapping = 24;
   */
  allowSpecialWrapping = false;

  constructor(data?: PartialMessage<ApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.ApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "merkleChallenges", kind: "message", T: MerkleChallenge, repeated: true },
    { no: 2, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 3, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 4, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 5, name: "coinTransfers", kind: "message", T: CoinTransfer, repeated: true },
    { no: 6, name: "requireToEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "requireFromEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "requireToDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "requireFromDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "overridesFromOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "overridesToIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "autoDeletionOptions", kind: "message", T: AutoDeletionOptions },
    { no: 13, name: "userRoyalties", kind: "message", T: UserRoyalties },
    { no: 14, name: "mustOwnTokens", kind: "message", T: MustOwnTokens, repeated: true },
    { no: 15, name: "dynamicStoreChallenges", kind: "message", T: DynamicStoreChallenge, repeated: true },
    { no: 16, name: "ethSignatureChallenges", kind: "message", T: ETHSignatureChallenge, repeated: true },
    { no: 17, name: "senderChecks", kind: "message", T: AddressChecks },
    { no: 18, name: "recipientChecks", kind: "message", T: AddressChecks },
    { no: 19, name: "initiatorChecks", kind: "message", T: AddressChecks },
    { no: 20, name: "altTimeChecks", kind: "message", T: AltTimeChecks },
    { no: 21, name: "mustPrioritize", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "votingChallenges", kind: "message", T: VotingChallenge, repeated: true },
    { no: 23, name: "allowBackedMinting", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 24, name: "allowSpecialWrapping", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApprovalCriteria {
    return new ApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: ApprovalCriteria | PlainMessage<ApprovalCriteria> | undefined, b: ApprovalCriteria | PlainMessage<ApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(ApprovalCriteria, a, b);
  }
}

/**
 * OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
 * This is used for user-level outgoing approvals and only includes fields relevant to outgoing transfers.
 * All criteria must be satisfied for the approval to be considered valid.
 *
 * @generated from message badges.OutgoingApprovalCriteria
 */
export class OutgoingApprovalCriteria extends Message<OutgoingApprovalCriteria> {
  /**
   * Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs
   * that satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.
   *
   * @generated from field: repeated badges.MerkleChallenge merkleChallenges = 1;
   */
  merkleChallenges: MerkleChallenge[] = [];

  /**
   * Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs
   * that can be transferred when using this approval.
   *
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 2;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts
   * transferred and enforces maximum limits per approval.
   *
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 3;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * Maximum number of transfers that can be processed using this approval. Tracks the count of transfers
   * and enforces the limit to prevent exceeding the allowed number of uses.
   *
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 4;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,
   * royalties) that must be executed alongside the badge transfer for the approval to be valid.
   *
   * @generated from field: repeated badges.CoinTransfer coinTransfers = 5;
   */
  coinTransfers: CoinTransfer[] = [];

  /**
   * Require the "to" address to be equal to the "initiated by" address for approval.
   * If true, only transfers where the recipient matches the initiator are allowed.
   *
   * @generated from field: bool requireToEqualsInitiatedBy = 6;
   */
  requireToEqualsInitiatedBy = false;

  /**
   * Require the "to" address to not be equal to the "initiated by" address for approval.
   * If true, transfers where the recipient equals the initiator are forbidden.
   *
   * @generated from field: bool requireToDoesNotEqualInitiatedBy = 7;
   */
  requireToDoesNotEqualInitiatedBy = false;

  /**
   * Auto-deletion options for this approval. Defines conditions under which this approval should be
   * automatically deleted (e.g., after a certain number of uses or time period).
   *
   * @generated from field: badges.AutoDeletionOptions autoDeletionOptions = 8;
   */
  autoDeletionOptions?: AutoDeletionOptions;

  /**
   * Must own tokens for approval. Defines token ownership requirements that must be satisfied for
   * the approval to be valid. The initiator must own the specified tokens at the specified ownership times.
   *
   * @generated from field: repeated badges.MustOwnTokens mustOwnTokens = 9;
   */
  mustOwnTokens: MustOwnTokens[] = [];

  /**
   * Dynamic store challenges that the initiator must pass for approval. The initiator must provide
   * valid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).
   *
   * @generated from field: repeated badges.DynamicStoreChallenge dynamicStoreChallenges = 10;
   */
  dynamicStoreChallenges: DynamicStoreChallenge[] = [];

  /**
   * ETH signature challenges that the initiator must pass for approval. The initiator must provide
   * valid Ethereum signatures for all specified challenges. Each signature can only be used once.
   *
   * @generated from field: repeated badges.ETHSignatureChallenge ethSignatureChallenges = 11;
   */
  ethSignatureChallenges: ETHSignatureChallenge[] = [];

  /**
   * Address checks for the recipient of the transfer. Validates that the recipient address meets the
   * specified criteria (e.g., whitelist, blacklist, protocol address requirements).
   * Note: No sender checks are included for outgoing approvals since the sender is the user themselves.
   *
   * @generated from field: badges.AddressChecks recipientChecks = 12;
   */
  recipientChecks?: AddressChecks;

  /**
   * Address checks for the initiator of the transfer. Validates that the initiator address meets the
   * specified criteria (e.g., whitelist, blacklist, protocol address requirements).
   *
   * @generated from field: badges.AddressChecks initiatorChecks = 13;
   */
  initiatorChecks?: AddressChecks;

  /**
   * Alternative time-based checks for approval denial (offline hours/days). Defines time periods
   * during which this approval should be denied, such as specific hours of the day or days of the week.
   *
   * @generated from field: badges.AltTimeChecks altTimeChecks = 14;
   */
  altTimeChecks?: AltTimeChecks;

  /**
   * If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
   * This allows fine-grained control over which approvals are applied when multiple approvals could match.
   *
   * @generated from field: bool mustPrioritize = 15;
   */
  mustPrioritize = false;

  /**
   * Voting challenges that must be satisfied for approval. The initiator must provide
   * valid votes that meet the quorum threshold for all specified challenges.
   *
   * @generated from field: repeated badges.VotingChallenge votingChallenges = 16;
   */
  votingChallenges: VotingChallenge[] = [];

  constructor(data?: PartialMessage<OutgoingApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.OutgoingApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "merkleChallenges", kind: "message", T: MerkleChallenge, repeated: true },
    { no: 2, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 3, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 4, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 5, name: "coinTransfers", kind: "message", T: CoinTransfer, repeated: true },
    { no: 6, name: "requireToEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "requireToDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "autoDeletionOptions", kind: "message", T: AutoDeletionOptions },
    { no: 9, name: "mustOwnTokens", kind: "message", T: MustOwnTokens, repeated: true },
    { no: 10, name: "dynamicStoreChallenges", kind: "message", T: DynamicStoreChallenge, repeated: true },
    { no: 11, name: "ethSignatureChallenges", kind: "message", T: ETHSignatureChallenge, repeated: true },
    { no: 12, name: "recipientChecks", kind: "message", T: AddressChecks },
    { no: 13, name: "initiatorChecks", kind: "message", T: AddressChecks },
    { no: 14, name: "altTimeChecks", kind: "message", T: AltTimeChecks },
    { no: 15, name: "mustPrioritize", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "votingChallenges", kind: "message", T: VotingChallenge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutgoingApprovalCriteria {
    return new OutgoingApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: OutgoingApprovalCriteria | PlainMessage<OutgoingApprovalCriteria> | undefined, b: OutgoingApprovalCriteria | PlainMessage<OutgoingApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(OutgoingApprovalCriteria, a, b);
  }
}

/**
 * IncomingApprovalCriteria defines the criteria for approving incoming transfers.
 * This is used for user-level incoming approvals and only includes fields relevant to incoming transfers.
 * All criteria must be satisfied for the approval to be considered valid.
 *
 * @generated from message badges.IncomingApprovalCriteria
 */
export class IncomingApprovalCriteria extends Message<IncomingApprovalCriteria> {
  /**
   * Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs
   * that satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.
   *
   * @generated from field: repeated badges.MerkleChallenge merkleChallenges = 1;
   */
  merkleChallenges: MerkleChallenge[] = [];

  /**
   * Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs
   * that can be transferred when using this approval.
   *
   * @generated from field: badges.PredeterminedBalances predeterminedBalances = 2;
   */
  predeterminedBalances?: PredeterminedBalances;

  /**
   * Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts
   * transferred and enforces maximum limits per approval.
   *
   * @generated from field: badges.ApprovalAmounts approvalAmounts = 3;
   */
  approvalAmounts?: ApprovalAmounts;

  /**
   * Maximum number of transfers that can be processed using this approval. Tracks the count of transfers
   * and enforces the limit to prevent exceeding the allowed number of uses.
   *
   * @generated from field: badges.MaxNumTransfers maxNumTransfers = 4;
   */
  maxNumTransfers?: MaxNumTransfers;

  /**
   * The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,
   * royalties) that must be executed alongside the badge transfer for the approval to be valid.
   *
   * @generated from field: repeated badges.CoinTransfer coinTransfers = 5;
   */
  coinTransfers: CoinTransfer[] = [];

  /**
   * Require the "from" address to be equal to the "initiated by" address for approval.
   * If true, only transfers where the sender matches the initiator are allowed.
   *
   * @generated from field: bool requireFromEqualsInitiatedBy = 6;
   */
  requireFromEqualsInitiatedBy = false;

  /**
   * Require the "from" address to not be equal to the "initiated by" address for approval.
   * If true, transfers where the sender equals the initiator are forbidden.
   *
   * @generated from field: bool requireFromDoesNotEqualInitiatedBy = 7;
   */
  requireFromDoesNotEqualInitiatedBy = false;

  /**
   * Auto-deletion options for this approval. Defines conditions under which this approval should be
   * automatically deleted (e.g., after a certain number of uses or time period).
   *
   * @generated from field: badges.AutoDeletionOptions autoDeletionOptions = 8;
   */
  autoDeletionOptions?: AutoDeletionOptions;

  /**
   * Must own tokens for approval. Defines token ownership requirements that must be satisfied for
   * the approval to be valid. The initiator must own the specified tokens at the specified ownership times.
   *
   * @generated from field: repeated badges.MustOwnTokens mustOwnTokens = 9;
   */
  mustOwnTokens: MustOwnTokens[] = [];

  /**
   * Dynamic store challenges that the initiator must pass for approval. The initiator must provide
   * valid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).
   *
   * @generated from field: repeated badges.DynamicStoreChallenge dynamicStoreChallenges = 10;
   */
  dynamicStoreChallenges: DynamicStoreChallenge[] = [];

  /**
   * ETH signature challenges that the initiator must pass for approval. The initiator must provide
   * valid Ethereum signatures for all specified challenges. Each signature can only be used once.
   *
   * @generated from field: repeated badges.ETHSignatureChallenge ethSignatureChallenges = 11;
   */
  ethSignatureChallenges: ETHSignatureChallenge[] = [];

  /**
   * Address checks for the sender of the transfer. Validates that the sender address meets the
   * specified criteria (e.g., whitelist, blacklist, protocol address requirements).
   * Note: No recipient checks are included for incoming approvals since the recipient is the user themselves.
   *
   * @generated from field: badges.AddressChecks senderChecks = 12;
   */
  senderChecks?: AddressChecks;

  /**
   * Address checks for the initiator of the transfer. Validates that the initiator address meets the
   * specified criteria (e.g., whitelist, blacklist, protocol address requirements).
   *
   * @generated from field: badges.AddressChecks initiatorChecks = 13;
   */
  initiatorChecks?: AddressChecks;

  /**
   * Alternative time-based checks for approval denial (offline hours/days). Defines time periods
   * during which this approval should be denied, such as specific hours of the day or days of the week.
   *
   * @generated from field: badges.AltTimeChecks altTimeChecks = 14;
   */
  altTimeChecks?: AltTimeChecks;

  /**
   * If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
   * This allows fine-grained control over which approvals are applied when multiple approvals could match.
   *
   * @generated from field: bool mustPrioritize = 15;
   */
  mustPrioritize = false;

  /**
   * Voting challenges that must be satisfied for approval. The initiator must provide
   * valid votes that meet the quorum threshold for all specified challenges.
   *
   * @generated from field: repeated badges.VotingChallenge votingChallenges = 16;
   */
  votingChallenges: VotingChallenge[] = [];

  constructor(data?: PartialMessage<IncomingApprovalCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "badges.IncomingApprovalCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "merkleChallenges", kind: "message", T: MerkleChallenge, repeated: true },
    { no: 2, name: "predeterminedBalances", kind: "message", T: PredeterminedBalances },
    { no: 3, name: "approvalAmounts", kind: "message", T: ApprovalAmounts },
    { no: 4, name: "maxNumTransfers", kind: "message", T: MaxNumTransfers },
    { no: 5, name: "coinTransfers", kind: "message", T: CoinTransfer, repeated: true },
    { no: 6, name: "requireFromEqualsInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "requireFromDoesNotEqualInitiatedBy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "autoDeletionOptions", kind: "message", T: AutoDeletionOptions },
    { no: 9, name: "mustOwnTokens", kind: "message", T: MustOwnTokens, repeated: true },
    { no: 10, name: "dynamicStoreChallenges", kind: "message", T: DynamicStoreChallenge, repeated: true },
    { no: 11, name: "ethSignatureChallenges", kind: "message", T: ETHSignatureChallenge, repeated: true },
    { no: 12, name: "senderChecks", kind: "message", T: AddressChecks },
    { no: 13, name: "initiatorChecks", kind: "message", T: AddressChecks },
    { no: 14, name: "altTimeChecks", kind: "message", T: AltTimeChecks },
    { no: 15, name: "mustPrioritize", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "votingChallenges", kind: "message", T: VotingChallenge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IncomingApprovalCriteria {
    return new IncomingApprovalCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: IncomingApprovalCriteria | PlainMessage<IncomingApprovalCriteria> | undefined, b: IncomingApprovalCriteria | PlainMessage<IncomingApprovalCriteria> | undefined): boolean {
    return proto3.util.equals(IncomingApprovalCriteria, a, b);
  }
}

