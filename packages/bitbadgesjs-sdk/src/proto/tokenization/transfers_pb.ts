// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file tokenization/transfers.proto (package tokenization, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Balance, PrecalculationOptions } from "./balances_pb.js";
import { ETHSignatureProof, MerkleProof } from "./challenges_pb.js";
import { ApprovalIdentifierDetails } from "./approvals_pb.js";

/**
 * Transfer defines the details of a transfer of tokens.
 *
 * @generated from message tokenization.Transfer
 */
export class Transfer extends Message<Transfer> {
  /**
   * The address of the sender of the transfer.
   *
   * @generated from field: string from = 1;
   */
  from = "";

  /**
   * The addresses of the recipients of the transfer.
   *
   * @generated from field: repeated string toAddresses = 2;
   */
  toAddresses: string[] = [];

  /**
   * The balances to be transferred.
   *
   * @generated from field: repeated tokenization.Balance balances = 3;
   */
  balances: Balance[] = [];

  /**
   * If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
   * We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
   *
   * @generated from field: tokenization.PrecalculateBalancesFromApprovalDetails precalculateBalancesFromApproval = 4;
   */
  precalculateBalancesFromApproval?: PrecalculateBalancesFromApprovalDetails;

  /**
   * The Merkle proofs / solutions for all Merkle challenges required for the transfer.
   *
   * @generated from field: repeated tokenization.MerkleProof merkleProofs = 5;
   */
  merkleProofs: MerkleProof[] = [];

  /**
   * The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.
   *
   * @generated from field: repeated tokenization.ETHSignatureProof ethSignatureProofs = 6;
   */
  ethSignatureProofs: ETHSignatureProof[] = [];

  /**
   * The memo for the transfer.
   *
   * @generated from field: string memo = 7;
   */
  memo = "";

  /**
   * The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
   * This field can be used to prioritize specific approvals and scan through them first.
   *
   * @generated from field: repeated tokenization.ApprovalIdentifierDetails prioritizedApprovals = 8;
   */
  prioritizedApprovals: ApprovalIdentifierDetails[] = [];

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedCollectionApprovals = 9;
   */
  onlyCheckPrioritizedCollectionApprovals = false;

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedIncomingApprovals = 10;
   */
  onlyCheckPrioritizedIncomingApprovals = false;

  /**
   * Whether to only check prioritized approvals for the transfer. 
   * If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
   * If false, we will check the prioritized approvals first and then scan through the rest of the approvals. 
   *
   * @generated from field: bool onlyCheckPrioritizedOutgoingApprovals = 11;
   */
  onlyCheckPrioritizedOutgoingApprovals = false;

  constructor(data?: PartialMessage<Transfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.Transfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "toAddresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "balances", kind: "message", T: Balance, repeated: true },
    { no: 4, name: "precalculateBalancesFromApproval", kind: "message", T: PrecalculateBalancesFromApprovalDetails },
    { no: 5, name: "merkleProofs", kind: "message", T: MerkleProof, repeated: true },
    { no: 6, name: "ethSignatureProofs", kind: "message", T: ETHSignatureProof, repeated: true },
    { no: 7, name: "memo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "prioritizedApprovals", kind: "message", T: ApprovalIdentifierDetails, repeated: true },
    { no: 9, name: "onlyCheckPrioritizedCollectionApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "onlyCheckPrioritizedIncomingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "onlyCheckPrioritizedOutgoingApprovals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transfer {
    return new Transfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transfer {
    return new Transfer().fromJsonString(jsonString, options);
  }

  static equals(a: Transfer | PlainMessage<Transfer> | undefined, b: Transfer | PlainMessage<Transfer> | undefined): boolean {
    return proto3.util.equals(Transfer, a, b);
  }
}

/**
 * PrecalculateBalancesFromApprovalDetails defines the details for precalculating balances from an approval.
 *
 * @generated from message tokenization.PrecalculateBalancesFromApprovalDetails
 */
export class PrecalculateBalancesFromApprovalDetails extends Message<PrecalculateBalancesFromApprovalDetails> {
  /**
   * The ID of the approval.
   *
   * @generated from field: string approvalId = 1;
   */
  approvalId = "";

  /**
   * The level of the approval. Can be "collection", "incoming", or "outgoing".
   *
   * @generated from field: string approvalLevel = 2;
   */
  approvalLevel = "";

  /**
   * The address of the approver. Leave blank "" if approvalLevel == "collection".
   *
   * @generated from field: string approverAddress = 3;
   */
  approverAddress = "";

  /**
   * The version of the approval.
   *
   * @generated from field: string version = 4;
   */
  version = "";

  /**
   * The options for precalculating the balances.
   *
   * @generated from field: tokenization.PrecalculationOptions precalculationOptions = 5;
   */
  precalculationOptions?: PrecalculationOptions;

  constructor(data?: PartialMessage<PrecalculateBalancesFromApprovalDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.PrecalculateBalancesFromApprovalDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "approvalId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "approvalLevel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "approverAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "precalculationOptions", kind: "message", T: PrecalculationOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrecalculateBalancesFromApprovalDetails {
    return new PrecalculateBalancesFromApprovalDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrecalculateBalancesFromApprovalDetails {
    return new PrecalculateBalancesFromApprovalDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrecalculateBalancesFromApprovalDetails {
    return new PrecalculateBalancesFromApprovalDetails().fromJsonString(jsonString, options);
  }

  static equals(a: PrecalculateBalancesFromApprovalDetails | PlainMessage<PrecalculateBalancesFromApprovalDetails> | undefined, b: PrecalculateBalancesFromApprovalDetails | PlainMessage<PrecalculateBalancesFromApprovalDetails> | undefined): boolean {
    return proto3.util.equals(PrecalculateBalancesFromApprovalDetails, a, b);
  }
}

