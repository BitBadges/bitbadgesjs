// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file tokenization/collections.proto (package tokenization, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { CollectionMetadata, PathMetadata, TokenMetadata } from "./metadata_pb.js";
import { CollectionPermissions } from "./permissions_pb.js";
import { CollectionApproval } from "./approvals_pb.js";
import { UserBalanceStore } from "./user_balance_store_pb.js";
import { Balance, UintRange } from "./balances_pb.js";

/**
 *
 * A TokenCollection is the top-level object for a collection of tokens. 
 * It defines everything about the collection, such as the manager, metadata, etc.
 *
 * All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).
 *
 * All collections can have a manager who is responsible for managing the collection and can be granted certain admin
 * permissions, such as the ability to mint new tokens.
 *
 * Collections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.
 *
 * See documentation for more details.
 *
 * @generated from message tokenization.TokenCollection
 */
export class TokenCollection extends Message<TokenCollection> {
  /**
   * The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
   *
   * @generated from field: string collectionId = 1;
   */
  collectionId = "";

  /**
   * The metadata for the collection itself.
   *
   * @generated from field: tokenization.CollectionMetadata collectionMetadata = 2;
   */
  collectionMetadata?: CollectionMetadata;

  /**
   * The metadata for each token in the collection.
   *
   * @generated from field: repeated tokenization.TokenMetadata tokenMetadata = 3;
   */
  tokenMetadata: TokenMetadata[] = [];

  /**
   * An arbitrary field that can store any data.
   *
   * @generated from field: string customData = 4;
   */
  customData = "";

  /**
   * The address of the manager of this collection.
   *
   * @generated from field: string manager = 5;
   */
  manager = "";

  /**
   * Permissions that define what the manager of the collection can do or not do.
   *
   * @generated from field: tokenization.CollectionPermissions collectionPermissions = 6;
   */
  collectionPermissions?: CollectionPermissions;

  /**
   * Transferability of the collection for collections with standard balances, subject to changes over time.
   * Overrides user approvals for a transfer if specified.
   * Transfer must satisfy both user and collection-level approvals.
   * Only applicable to on-chain balances.
   *
   * @generated from field: repeated tokenization.CollectionApproval collectionApprovals = 7;
   */
  collectionApprovals: CollectionApproval[] = [];

  /**
   * Standards that define how to interpret the fields of the collection.
   *
   * @generated from field: repeated string standards = 8;
   */
  standards: string[] = [];

  /**
   * Whether the collection is archived or not.
   * When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
   *
   * @generated from field: bool isArchived = 9;
   */
  isArchived = false;

  /**
   * The default store of a balance / approvals for a user, upon genesis.
   *
   * @generated from field: tokenization.UserBalanceStore defaultBalances = 10;
   */
  defaultBalances?: UserBalanceStore;

  /**
   * The user or entity who created the collection.
   *
   * @generated from field: string createdBy = 11;
   */
  createdBy = "";

  /**
   * The valid token IDs for this collection.
   *
   * @generated from field: repeated tokenization.UintRange validTokenIds = 12;
   */
  validTokenIds: UintRange[] = [];

  /**
   * The generated address of the collection. Also used to escrow Mint balances.
   *
   * @generated from field: string mintEscrowAddress = 13;
   */
  mintEscrowAddress = "";

  /**
   * The IBC wrapper (sdk.coin) paths for the collection.
   *
   * @generated from field: repeated tokenization.CosmosCoinWrapperPath cosmosCoinWrapperPaths = 14;
   */
  cosmosCoinWrapperPaths: CosmosCoinWrapperPath[] = [];

  /**
   * Collection-level invariants that cannot be broken.
   * These are set upon genesis and cannot be modified.
   *
   * @generated from field: tokenization.CollectionInvariants invariants = 15;
   */
  invariants?: CollectionInvariants;

  /**
   * The alias (non-wrapping) paths for the collection.
   *
   * @generated from field: repeated tokenization.AliasPath aliasPaths = 16;
   */
  aliasPaths: AliasPath[] = [];

  constructor(data?: PartialMessage<TokenCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.TokenCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collectionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collectionMetadata", kind: "message", T: CollectionMetadata },
    { no: 3, name: "tokenMetadata", kind: "message", T: TokenMetadata, repeated: true },
    { no: 4, name: "customData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "manager", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "collectionPermissions", kind: "message", T: CollectionPermissions },
    { no: 7, name: "collectionApprovals", kind: "message", T: CollectionApproval, repeated: true },
    { no: 8, name: "standards", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "isArchived", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "defaultBalances", kind: "message", T: UserBalanceStore },
    { no: 11, name: "createdBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "validTokenIds", kind: "message", T: UintRange, repeated: true },
    { no: 13, name: "mintEscrowAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "cosmosCoinWrapperPaths", kind: "message", T: CosmosCoinWrapperPath, repeated: true },
    { no: 15, name: "invariants", kind: "message", T: CollectionInvariants },
    { no: 16, name: "aliasPaths", kind: "message", T: AliasPath, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TokenCollection {
    return new TokenCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TokenCollection {
    return new TokenCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TokenCollection {
    return new TokenCollection().fromJsonString(jsonString, options);
  }

  static equals(a: TokenCollection | PlainMessage<TokenCollection> | undefined, b: TokenCollection | PlainMessage<TokenCollection> | undefined): boolean {
    return proto3.util.equals(TokenCollection, a, b);
  }
}

/**
 * Conversion defines a bidirectional conversion between a cosmos coin (with denom) and badge balances.
 *
 * @generated from message tokenization.Conversion
 */
export class Conversion extends Message<Conversion> {
  /**
   * Side A: The cosmos coin side of the conversion (amount + denom).
   *
   * @generated from field: tokenization.ConversionSideAWithDenom sideA = 1;
   */
  sideA?: ConversionSideAWithDenom;

  /**
   * Side B: The badge balances side of the conversion.
   *
   * @generated from field: repeated tokenization.Balance sideB = 2;
   */
  sideB: Balance[] = [];

  constructor(data?: PartialMessage<Conversion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.Conversion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sideA", kind: "message", T: ConversionSideAWithDenom },
    { no: 2, name: "sideB", kind: "message", T: Balance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Conversion {
    return new Conversion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Conversion {
    return new Conversion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Conversion {
    return new Conversion().fromJsonString(jsonString, options);
  }

  static equals(a: Conversion | PlainMessage<Conversion> | undefined, b: Conversion | PlainMessage<Conversion> | undefined): boolean {
    return proto3.util.equals(Conversion, a, b);
  }
}

/**
 * ConversionSideAWithDenom represents the cosmos coin side of a conversion with denomination.
 *
 * @generated from message tokenization.ConversionSideAWithDenom
 */
export class ConversionSideAWithDenom extends Message<ConversionSideAWithDenom> {
  /**
   * The amount of the cosmos coin (0 decimals).
   *
   * @generated from field: string amount = 1;
   */
  amount = "";

  /**
   * The denomination of the cosmos coin.
   *
   * @generated from field: string denom = 2;
   */
  denom = "";

  constructor(data?: PartialMessage<ConversionSideAWithDenom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.ConversionSideAWithDenom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConversionSideAWithDenom {
    return new ConversionSideAWithDenom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConversionSideAWithDenom {
    return new ConversionSideAWithDenom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConversionSideAWithDenom {
    return new ConversionSideAWithDenom().fromJsonString(jsonString, options);
  }

  static equals(a: ConversionSideAWithDenom | PlainMessage<ConversionSideAWithDenom> | undefined, b: ConversionSideAWithDenom | PlainMessage<ConversionSideAWithDenom> | undefined): boolean {
    return proto3.util.equals(ConversionSideAWithDenom, a, b);
  }
}

/**
 * ConversionWithoutDenom defines a bidirectional conversion between a cosmos coin amount (without denom) and badge balances.
 * The denom is stored at the base level (e.g., in AliasPath or CosmosCoinWrapperPath).
 *
 * @generated from message tokenization.ConversionWithoutDenom
 */
export class ConversionWithoutDenom extends Message<ConversionWithoutDenom> {
  /**
   * Side A: The cosmos coin amount side of the conversion (amount only, denom stored separately).
   *
   * @generated from field: tokenization.ConversionSideA sideA = 1;
   */
  sideA?: ConversionSideA;

  /**
   * Side B: The badge balances side of the conversion.
   *
   * @generated from field: repeated tokenization.Balance sideB = 2;
   */
  sideB: Balance[] = [];

  constructor(data?: PartialMessage<ConversionWithoutDenom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.ConversionWithoutDenom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sideA", kind: "message", T: ConversionSideA },
    { no: 2, name: "sideB", kind: "message", T: Balance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConversionWithoutDenom {
    return new ConversionWithoutDenom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConversionWithoutDenom {
    return new ConversionWithoutDenom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConversionWithoutDenom {
    return new ConversionWithoutDenom().fromJsonString(jsonString, options);
  }

  static equals(a: ConversionWithoutDenom | PlainMessage<ConversionWithoutDenom> | undefined, b: ConversionWithoutDenom | PlainMessage<ConversionWithoutDenom> | undefined): boolean {
    return proto3.util.equals(ConversionWithoutDenom, a, b);
  }
}

/**
 * ConversionSideA represents the cosmos coin amount side of a conversion without denomination.
 *
 * @generated from message tokenization.ConversionSideA
 */
export class ConversionSideA extends Message<ConversionSideA> {
  /**
   * The amount of the cosmos coin (0 decimals).
   *
   * @generated from field: string amount = 1;
   */
  amount = "";

  constructor(data?: PartialMessage<ConversionSideA>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.ConversionSideA";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConversionSideA {
    return new ConversionSideA().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConversionSideA {
    return new ConversionSideA().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConversionSideA {
    return new ConversionSideA().fromJsonString(jsonString, options);
  }

  static equals(a: ConversionSideA | PlainMessage<ConversionSideA> | undefined, b: ConversionSideA | PlainMessage<ConversionSideA> | undefined): boolean {
    return proto3.util.equals(ConversionSideA, a, b);
  }
}

/**
 * @generated from message tokenization.CosmosCoinWrapperPath
 */
export class CosmosCoinWrapperPath extends Message<CosmosCoinWrapperPath> {
  /**
   * The BitBadges address associated with this wrapper path. Used for routing and identifying the wrapper.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * The denomination (denom) to be used for the wrapped coin or the alias denom.
   *
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * The conversion between cosmos coin and badge balances.
   *
   * @generated from field: tokenization.ConversionWithoutDenom conversion = 3;
   */
  conversion?: ConversionWithoutDenom;

  /**
   * The symbol for the wrapped coin (e.g., "BADGE", "NFT"). Used for display purposes. Note that this may not be the default.
   *
   * @generated from field: string symbol = 4;
   */
  symbol = "";

  /**
   * Denomination units for the wrapped coin. Defines how the coin can be displayed with different
   * decimal places and symbols (e.g., base unit, display unit). You can specify which is the default display unit (base level or one of these).
   *
   * @generated from field: repeated tokenization.DenomUnit denomUnits = 5;
   */
  denomUnits: DenomUnit[] = [];

  /**
   * If true, allows this wrapper path to be used with any valid token ID in the collection via an {id} placeholder.
   *
   * @generated from field: bool allowOverrideWithAnyValidToken = 6;
   */
  allowOverrideWithAnyValidToken = false;

  /**
   * The metadata for this wrapper path.
   *
   * @generated from field: tokenization.PathMetadata metadata = 7;
   */
  metadata?: PathMetadata;

  constructor(data?: PartialMessage<CosmosCoinWrapperPath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.CosmosCoinWrapperPath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "conversion", kind: "message", T: ConversionWithoutDenom },
    { no: 4, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "denomUnits", kind: "message", T: DenomUnit, repeated: true },
    { no: 6, name: "allowOverrideWithAnyValidToken", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "metadata", kind: "message", T: PathMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CosmosCoinWrapperPath {
    return new CosmosCoinWrapperPath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPath {
    return new CosmosCoinWrapperPath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CosmosCoinWrapperPath {
    return new CosmosCoinWrapperPath().fromJsonString(jsonString, options);
  }

  static equals(a: CosmosCoinWrapperPath | PlainMessage<CosmosCoinWrapperPath> | undefined, b: CosmosCoinWrapperPath | PlainMessage<CosmosCoinWrapperPath> | undefined): boolean {
    return proto3.util.equals(CosmosCoinWrapperPath, a, b);
  }
}

/**
 * @generated from message tokenization.AliasPath
 */
export class AliasPath extends Message<AliasPath> {
  /**
   * The denomination (denom) to be used for the alias.
   *
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * The conversion between cosmos coin and badge balances.
   *
   * @generated from field: tokenization.ConversionWithoutDenom conversion = 2;
   */
  conversion?: ConversionWithoutDenom;

  /**
   * The symbol for the alias (e.g., "BADGE", "NFT"). Used for display purposes. Note that this may not be the default.
   *
   * @generated from field: string symbol = 3;
   */
  symbol = "";

  /**
   * Denomination units for the alias. Defines how the coin can be displayed with different decimal places and symbols.
   *
   * @generated from field: repeated tokenization.DenomUnit denomUnits = 4;
   */
  denomUnits: DenomUnit[] = [];

  /**
   * The metadata for this alias path.
   *
   * @generated from field: tokenization.PathMetadata metadata = 5;
   */
  metadata?: PathMetadata;

  constructor(data?: PartialMessage<AliasPath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.AliasPath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "conversion", kind: "message", T: ConversionWithoutDenom },
    { no: 3, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "denomUnits", kind: "message", T: DenomUnit, repeated: true },
    { no: 5, name: "metadata", kind: "message", T: PathMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AliasPath {
    return new AliasPath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AliasPath {
    return new AliasPath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AliasPath {
    return new AliasPath().fromJsonString(jsonString, options);
  }

  static equals(a: AliasPath | PlainMessage<AliasPath> | undefined, b: AliasPath | PlainMessage<AliasPath> | undefined): boolean {
    return proto3.util.equals(AliasPath, a, b);
  }
}

/**
 * @generated from message tokenization.CosmosCoinBackedPath
 */
export class CosmosCoinBackedPath extends Message<CosmosCoinBackedPath> {
  /**
   * The address associated with this backed path. Used for routing and escrowing IBC tokens.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * The conversion between IBC cosmos coin and badge balances.
   *
   * @generated from field: tokenization.Conversion conversion = 2;
   */
  conversion?: Conversion;

  constructor(data?: PartialMessage<CosmosCoinBackedPath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.CosmosCoinBackedPath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "conversion", kind: "message", T: Conversion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CosmosCoinBackedPath {
    return new CosmosCoinBackedPath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CosmosCoinBackedPath {
    return new CosmosCoinBackedPath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CosmosCoinBackedPath {
    return new CosmosCoinBackedPath().fromJsonString(jsonString, options);
  }

  static equals(a: CosmosCoinBackedPath | PlainMessage<CosmosCoinBackedPath> | undefined, b: CosmosCoinBackedPath | PlainMessage<CosmosCoinBackedPath> | undefined): boolean {
    return proto3.util.equals(CosmosCoinBackedPath, a, b);
  }
}

/**
 * @generated from message tokenization.DenomUnit
 */
export class DenomUnit extends Message<DenomUnit> {
  /**
   * The number of decimal places for this unit. Defines the precision of the unit.
   *
   * @generated from field: string decimals = 1;
   */
  decimals = "";

  /**
   * The symbol for this unit (e.g., "BADGE", "nBADGE"). Used for display purposes.
   *
   * @generated from field: string symbol = 2;
   */
  symbol = "";

  /**
   * If true, this is the default display unit. Only one unit should be marked as the default display unit.
   * This unit will be used by default when displaying the coin amount. If none are marked default, we use the base level.
   *
   * @generated from field: bool isDefaultDisplay = 3;
   */
  isDefaultDisplay = false;

  /**
   * The metadata for this denomination unit.
   *
   * @generated from field: tokenization.PathMetadata metadata = 4;
   */
  metadata?: PathMetadata;

  constructor(data?: PartialMessage<DenomUnit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.DenomUnit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "decimals", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isDefaultDisplay", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "metadata", kind: "message", T: PathMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenomUnit {
    return new DenomUnit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenomUnit {
    return new DenomUnit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenomUnit {
    return new DenomUnit().fromJsonString(jsonString, options);
  }

  static equals(a: DenomUnit | PlainMessage<DenomUnit> | undefined, b: DenomUnit | PlainMessage<DenomUnit> | undefined): boolean {
    return proto3.util.equals(DenomUnit, a, b);
  }
}

/**
 * CollectionInvariants defines the invariants that apply to a collection.
 *
 * @generated from message tokenization.CollectionInvariants
 */
export class CollectionInvariants extends Message<CollectionInvariants> {
  /**
   * If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
   * This prevents time-based restrictions on token ownership.
   *
   * @generated from field: bool noCustomOwnershipTimes = 1;
   */
  noCustomOwnershipTimes = false;

  /**
   * Maximum supply per token ID. If set, no balance can exceed this amount.
   * This prevents any single token ID from having more than the specified supply.
   *
   * @generated from field: string maxSupplyPerId = 2;
   */
  maxSupplyPerId = "";

  /**
   * The IBC backed (sdk.coin) path for the collection. Only one path is allowed.
   *
   * @generated from field: tokenization.CosmosCoinBackedPath cosmosCoinBackedPath = 3;
   */
  cosmosCoinBackedPath?: CosmosCoinBackedPath;

  /**
   * If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.
   * This prevents forceful transfers that bypass user-level approvals.
   * This only applies to transfers where the from address does not equal "Mint".
   *
   * @generated from field: bool noForcefulPostMintTransfers = 4;
   */
  noForcefulPostMintTransfers = false;

  /**
   * If true, disallows pool creation with this collection's assets.
   * When true, any attempt to create a pool with tokenization assets from this collection will fail.
   *
   * @generated from field: bool disablePoolCreation = 5;
   */
  disablePoolCreation = false;

  constructor(data?: PartialMessage<CollectionInvariants>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tokenization.CollectionInvariants";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "noCustomOwnershipTimes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "maxSupplyPerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cosmosCoinBackedPath", kind: "message", T: CosmosCoinBackedPath },
    { no: 4, name: "noForcefulPostMintTransfers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "disablePoolCreation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionInvariants {
    return new CollectionInvariants().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionInvariants {
    return new CollectionInvariants().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionInvariants {
    return new CollectionInvariants().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionInvariants | PlainMessage<CollectionInvariants> | undefined, b: CollectionInvariants | PlainMessage<CollectionInvariants> | undefined): boolean {
    return proto3.util.equals(CollectionInvariants, a, b);
  }
}

